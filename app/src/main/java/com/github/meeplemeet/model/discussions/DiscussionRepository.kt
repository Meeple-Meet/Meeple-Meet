package com.github.meeplemeet.model.discussions

// Docs generated by Claude

import android.content.Context
import com.github.meeplemeet.RepositoryProvider
import com.github.meeplemeet.model.DiscussionNotFoundException
import com.github.meeplemeet.model.FirestoreRepository
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.AccountRepository
import com.github.meeplemeet.model.images.ImageRepository
import com.google.firebase.Timestamp
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import com.google.firebase.firestore.WriteBatch
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

private const val PHOTO_MESSAGE_PREVIEW = "ðŸ“· Photo"
private const val FIELD_CREATED_AT = "createdAt"
private const val MESSAGES_SUB_COLLECTION = "messages"

/**
 * Repository for managing discussion data in Firestore.
 *
 * Provides comprehensive CRUD operations, real-time listeners, and specialized functionality for
 * discussions including messaging, polls, photo attachments, and participant management.
 *
 * ## Architecture
 * - **Main documents**: Stored at `discussions/{discussionId}` in Firestore
 * - **Messages subcollection**: Each discussion has a `messages` subcollection at
 *   `discussions/{discussionId}/messages/{messageId}` for scalability and efficient real-time
 *   updates
 * - **Previews**: Lightweight discussion metadata stored in each account document at
 *   `accounts/{accountId}/previews/{discussionId}`
 *
 * ## Features
 * - **Basic CRUD**: Create, read, update, delete discussions
 * - **Participant management**: Add/remove participants and admins
 * - **Messaging**: Send text messages, photo messages, and poll messages
 * - **Photos**: Profile pictures and message photo attachments (integrated with [ImageRepository])
 * - **Polls**: Create polls, vote, track results
 * - **Real-time updates**: Flow-based listeners for discussions and messages
 * - **Unread tracking**: Automatic unread count management in discussion previews
 *
 * ## Message Subcollection Benefits
 * - Scalable: Doesn't load all messages when fetching discussion metadata
 * - Efficient: Real-time listeners only stream new messages
 * - Flexible: Messages can be queried, paginated, and filtered independently
 *
 * ## Preview Updates
 * All messaging operations (text, photo, poll) automatically update discussion previews for all
 * participants, including:
 * - Last message content (with special formatting for photos and polls "ðŸ“Š Poll: ...")
 * - Last message sender and timestamp
 * - Unread count (incremented for all participants except sender)
 *
 * @property accountRepository Reference to AccountRepository for preview management
 * @see Discussion for discussion data structure
 * @see Message for message data structure
 * @see Poll for poll functionality
 * @see ImageRepository for photo upload/download operations
 */
class DiscussionRepository(
    accountRepository: AccountRepository = RepositoryProvider.accounts,
    private val imageRepository: ImageRepository = RepositoryProvider.images
) : FirestoreRepository("discussions", listOf(MESSAGES_SUB_COLLECTION)) {
  private val accounts = accountRepository.collection

  /**
   * Get the messages subcollection reference for a specific discussion.
   *
   * Messages are stored in a subcollection rather than as an array field to enable:
   * - Scalable storage (no document size limits)
   * - Efficient queries and pagination
   * - Real-time streaming of new messages only
   *
   * @param discussionId The discussion UID.
   * @return CollectionReference to `discussions/{discussionId}/messages`
   */
  private fun messagesCollection(discussionId: String) =
      collection.document(discussionId).collection(MESSAGES_SUB_COLLECTION)

  /** Create a new discussion and store an empty preview for the creator. */
  suspend fun createDiscussion(
      name: String,
      description: String,
      creatorId: String,
      participants: List<String> = emptyList()
  ): Discussion {
    val discussion =
        Discussion(
            newUUID(),
            creatorId,
            name,
            description,
            participants + creatorId,
            listOf(creatorId),
            Timestamp.now(),
            null)

    val batch = db.batch()
    batch.set(collection.document(discussion.uid), toNoUid(discussion))
    (participants + creatorId).forEach { id ->
      val ref = accounts.document(id).collection(Account::previews.name).document(discussion.uid)
      batch.set(ref, DiscussionPreviewNoUid())
    }
    batch.commit().await()

    return discussion
  }

  /**
   * Checks if a discussion preview is valid by verifying the discussion document exists.
   *
   * Used to clean up orphaned preview documents that reference deleted discussions. This prevents
   * the UI from showing stale previews for non-existent discussions.
   *
   * @param discussionId The discussion ID to check
   * @return true if the discussion document exists in Firestore, false otherwise
   */
  suspend fun previewIsValid(discussionId: String): Boolean =
      collection.document(discussionId).get().await().exists()

  /** Retrieve a discussion document by ID. */
  suspend fun getDiscussion(id: String): Discussion {
    val snapshot = collection.document(id).get().await()
    val discussion = snapshot.toObject(DiscussionNoUid::class.java)
    if (discussion != null) return fromNoUid(id, discussion)
    throw DiscussionNotFoundException()
  }

  /** Update a discussion's name. */
  suspend fun setDiscussionName(id: String, name: String) {
    collection.document(id).update(Discussion::name.name, name).await()
  }

  /** Update a discussion's description. */
  suspend fun setDiscussionDescription(id: String, description: String) {
    collection.document(id).update(Discussion::description.name, description).await()
  }

  /**
   * Update a discussion's profile picture URL.
   *
   * This method updates the `profilePictureUrl` field in the discussion document. The actual photo
   * upload to Firebase Storage should be done via [ImageRepository.saveDiscussionProfilePicture]
   * before calling this method.
   *
   * ## Typical Usage Flow
   * 1. User selects/captures photo â†’ cached via [com.github.meeplemeet.model.images.ImageFileUtils]
   * 2. Upload to Storage â†’ [ImageRepository.saveDiscussionProfilePicture] returns URL
   * 3. Update discussion â†’ this method saves URL to discussion document
   * 4. UI displays photo using the URL
   *
   * ## Permission Requirements
   * Caller should verify user is an admin before calling this method.
   *
   * @param id The discussion UID.
   * @param profilePictureUrl HTTPS URL from Firebase Storage pointing to the uploaded profile
   *   picture.
   * @see ImageRepository.saveDiscussionProfilePicture for uploading photos
   * @see DiscussionDetailsViewModel.setDiscussionProfilePicture for high-level API with permission
   *   checks
   */
  suspend fun setDiscussionProfilePictureUrl(id: String, profilePictureUrl: String) {
    collection.document(id).update(Discussion::profilePictureUrl.name, profilePictureUrl).await()
  }

  /**
   * Delete a discussion document and all associated images.
   *
   * Deletes:
   * - The discussion document from Firestore
   * - All discussion previews from participants' accounts
   * - Discussion profile picture from Firebase Storage
   * - All message photo attachments from Firebase Storage
   *
   * @param context Android context for accessing cache directory
   * @param discussion The discussion to delete
   */
  suspend fun deleteDiscussion(context: Context, discussion: Discussion) {
    // Delete images first (profile picture and all message photos)
    try {
      imageRepository.deleteDiscussionPhotoMessages(context, discussion.uid)
    } catch (_: Exception) {
      // Error happens only in extremely niche cases
    }

    // Delete Firestore documents
    val batch = db.batch()
    fullyDeleteDocument(collection.document(discussion.uid))
    discussion.participants.forEach { id ->
      val ref = accounts.document(id).collection(Account::previews.name).document(discussion.uid)
      batch.delete(ref)
    }
    batch.commit().await()
  }

  /** Add a user to the participants array. */
  suspend fun addUserToDiscussion(discussionId: String, userId: String) {
    collection
        .document(discussionId)
        .update(Discussion::participants.name, FieldValue.arrayUnion(userId))
        .await()

    // Get the last message to populate the preview
    val lastMessage = getLastMessage(discussionId)

    accounts
        .document(userId)
        .collection(Account::previews.name)
        .document(discussionId)
        .set(toPreview(discussionId, lastMessage))
        .await()
  }

  /** Remove a user from the participants and admins array */
  suspend fun removeUserFromDiscussion(
      discussion: Discussion,
      userId: String,
      changeOwner: Boolean = false
  ) {
    val updates =
        mutableMapOf<String, Any>(
            Discussion::participants.name to FieldValue.arrayRemove(userId),
            Discussion::admins.name to FieldValue.arrayRemove(userId))

    // If the user being removed is the owner, reassign ownership
    if (changeOwner) {
      val remainingParticipants = discussion.participants.filter { it != userId }

      // Try to find a random admin first (excluding the user being removed)
      val remainingAdmins = discussion.admins.filter { it != userId }
      val newOwner = remainingAdmins.randomOrNull() ?: remainingParticipants.randomOrNull()

      // Only update owner if there's someone to assign it to
      if (newOwner != null) {
        updates[DiscussionNoUid::creatorId.name] = newOwner

        // Add new owner to admins if they're not already an admin
        if (newOwner !in remainingAdmins) {
          updates[Discussion::admins.name] = FieldValue.arrayUnion(newOwner)
        }
      }
    }

    collection.document(discussion.uid).update(updates).await()
    accounts
        .document(userId)
        .collection(Account::previews.name)
        .document(discussion.uid)
        .delete()
        .await()
  }

  /** Add multiple users to the participants array. */
  suspend fun addUsersToDiscussion(discussion: Discussion, userIds: List<String>) {
    collection
        .document(discussion.uid)
        .update(Discussion::participants.name, FieldValue.arrayUnion(*userIds.toTypedArray()))
        .await()

    // Get the last message to populate the preview
    val lastMessage = getLastMessage(discussion.uid)

    val batch = db.batch()
    userIds.forEach { id ->
      val ref = accounts.document(id).collection(Account::previews.name).document(discussion.uid)
      batch.set(ref, toPreview(discussion.uid, lastMessage))
    }
    batch.commit().await()
  }

  /** Remove multiple users from the participants and admins array. */
  suspend fun removeUsersFromDiscussion(discussion: Discussion, userIds: List<String>) {
    collection
        .document(discussion.uid)
        .update(
            Discussion::participants.name,
            FieldValue.arrayRemove(*userIds.toTypedArray()),
            Discussion::admins.name,
            FieldValue.arrayRemove(*userIds.toTypedArray()))
        .await()
    val batch = db.batch()
    userIds.forEach { id ->
      val ref = accounts.document(id).collection(Account::previews.name).document(discussion.uid)
      batch.delete(ref)
    }
    batch.commit().await()
  }

  /** Add a user as admin (and participant if missing). */
  suspend fun addAdminToDiscussion(discussion: Discussion, userId: String) {
    if (!discussion.participants.contains(userId)) addUserToDiscussion(discussion.uid, userId)
    collection
        .document(discussion.uid)
        .update(Discussion::admins.name, FieldValue.arrayUnion(userId))
        .await()
  }

  /** Remove a user from the admins array */
  suspend fun removeAdminFromDiscussion(discussion: Discussion, userId: String) {
    collection
        .document(discussion.uid)
        .update(Discussion::admins.name, FieldValue.arrayRemove(userId))
        .await()
  }

  /** Add multiple admins (and participants if missing). */
  suspend fun addAdminsToDiscussion(discussion: Discussion, adminIds: List<String>) {
    val current = discussion.participants.toSet()
    val newParticipants = adminIds.filterNot { it in current }
    if (newParticipants.isNotEmpty()) {
      collection
          .document(discussion.uid)
          .update(
              Discussion::participants.name, FieldValue.arrayUnion(*newParticipants.toTypedArray()))
          .await()
    }

    val currentAdmins = discussion.admins.toSet()
    val newAdmins = adminIds.filterNot { it in currentAdmins }
    if (newAdmins.isNotEmpty()) {
      collection
          .document(discussion.uid)
          .update(Discussion::admins.name, FieldValue.arrayUnion(*newAdmins.toTypedArray()))
          .await()
    }
  }

  /** Remove multiple users from the admins array. */
  suspend fun removeAdminsFromDiscussion(discussion: Discussion, userIds: List<String>) {
    collection
        .document(discussion.uid)
        .update(Discussion::admins.name, FieldValue.arrayRemove(*userIds.toTypedArray()))
        .await()
  }

  /**
   * Send a text message to the discussion and update all participants' previews.
   *
   * Creates a new message document in the `messages` subcollection and atomically updates all
   * participants' discussion previews in a single batch operation.
   *
   * ## Preview Updates
   * For each participant:
   * - Sets `lastMessage` to the text content
   * - Sets `lastMessageSender` to sender's UID
   * - Sets `lastMessageAt` to current timestamp
   * - Increments `unreadCount` by 1 (except for sender, who gets 0)
   *
   * ## Batch Operation
   * Uses Firestore batch writes to ensure atomicity - either all writes succeed or all fail. Can
   * optionally use a custom batch to combine this operation with other writes (useful for message
   * editing).
   *
   * @param discussion The discussion to send the message to.
   * @param sender The account sending the message.
   * @param content The text content of the message.
   * @param batch Optional WriteBatch to use for the operation. Defaults to a new batch. Useful for
   *   combining this operation with others (e.g., when editing the last message).
   * @param editUid Optional message UID to use instead of generating a new one. Used when editing
   *   the last message to preserve the message ID. Defaults to empty string (generates new UID).
   * @see sendPhotoMessageToDiscussion for messages with photo attachments
   * @see createPoll for creating poll messages
   * @see editMessage for message editing use case
   */
  suspend fun sendMessageToDiscussion(
      discussion: Discussion,
      sender: Account,
      content: String,
      batch: WriteBatch = db.batch(),
      editUid: String = ""
  ) {
    val timestamp = Timestamp.now()
    val messageNoUid = MessageNoUid(sender.uid, content, timestamp)

    // Add message to subcollection
    val messageRef =
        if (editUid.isEmpty()) messagesCollection(discussion.uid).document()
        else messagesCollection(discussion.uid).document(editUid)
    batch.set(messageRef, messageNoUid)

    // Update previews for all participants
    discussion.participants.forEach { userId ->
      val ref =
          accounts.document(userId).collection(Account::previews.name).document(discussion.uid)
      val unreadCountValue = if (userId == sender.uid) 0 else FieldValue.increment(1)
      batch.set(
          ref,
          mapOf(
              "lastMessage" to content,
              "lastMessageSender" to sender.uid,
              "lastMessageAt" to timestamp,
              "unreadCount" to unreadCountValue),
          SetOptions.merge())
    }

    batch.commit().await()
  }

  /**
   * Edit a message's content in a discussion.
   *
   * Handles two different edit scenarios based on whether the message is the most recent one:
   * - **Last message**: Deletes the old message and sends a new one (to update discussion previews)
   * - **Earlier message**: Updates the message content in place and marks it as edited
   *
   * ## Last Message Behavior
   * When editing the most recent message, a batch operation is used to:
   * 1. Delete the old message document
   * 2. Create a new message with the updated content
   * 3. Update all participants' discussion previews
   *
   * This ensures the preview reflects the edited content.
   *
   * ## Earlier Message Behavior
   * For messages that are not the most recent, only the message document is updated with:
   * - The new content
   * - An `edited` flag set to true (to indicate the message was modified)
   *
   * Previews are not updated since they already show the most recent message.
   *
   * @param messageId The UID of the message to edit.
   * @param newMessageContent The new text content for the message.
   * @param discussion The discussion containing the message.
   * @param sender The account editing the message (must be original sender).
   * @throws IllegalArgumentException if no message exists to edit.
   * @see deleteMessage for removing messages
   * @see sendMessageToDiscussion for creating new messages
   */
  suspend fun editMessage(
      discussion: Discussion,
      sender: Account,
      messageId: String,
      newMessageContent: String,
  ) {
    val message = getLastMessage(discussion.uid)
    val isLast =
        message?.let { it.uid == messageId } ?: throw IllegalArgumentException("No message to edit")

    if (isLast) {
      val batch = db.batch()
      batch.delete(messagesCollection(discussion.uid).document(messageId))
      sendMessageToDiscussion(discussion, sender, newMessageContent, batch, messageId)
    } else {
      messagesCollection(discussion.uid)
          .document(messageId)
          .update(
              Message::content.name,
              newMessageContent,
              Message::edited.name,
              true,
          )
          .await()
    }
  }

  /**
   * Delete a message from a discussion.
   *
   * Removes the message document from the discussion's messages subcollection. This operation only
   * deletes the message itself and does not update discussion previews.
   *
   * ## Important Notes
   * - If the deleted message is the most recent one, the discussion preview will still show its
   *   content until a new message is sent
   * - The message document is permanently deleted and cannot be recovered
   * - If the message has a photo attachment, the photo in Firebase Storage is NOT automatically
   *   deleted (consider using [ImageRepository] if photo cleanup is needed)
   *
   * @param messageId The UID of the message to delete (document ID in messages subcollection).
   * @param discussionId The UID of the discussion containing the message.
   * @see editMessage for modifying message content instead of deleting
   * @see messagesCollection for accessing the messages subcollection
   */
  suspend fun deleteMessage(discussionId: String, messageId: String) {
    messagesCollection(discussionId).document(messageId).delete().await()
  }

  /**
   * Send a message with a photo attachment to the discussion.
   *
   * Creates a new message document with a `photoUrl` field and updates all participants' previews
   * with special photo formatting.
   *
   * ## Usage Flow
   * 1. User selects/captures photo
   * 2. Photo is cached via [com.github.meeplemeet.model.images.ImageFileUtils.cacheUriToFile]
   * 3. Photo is uploaded via [ImageRepository.saveDiscussionPhotoMessages]
   * 4. This method is called with the returned download URL
   * 5. Message is created and previews are updated
   *
   * ## Preview Formatting
   * The preview text shown in discussion lists will use a photo icon prefix.
   *
   * @param discussion The discussion to send the message to.
   * @param sender The account sending the message.
   * @param content Optional caption/description for the photo. Can be empty string.
   * @param photoUrl HTTPS URL from Firebase Storage pointing to the uploaded photo.
   * @return The message document ID (UID) of the created message.
   * @see ImageRepository.saveDiscussionPhotoMessages for uploading photos
   * @see DiscussionViewModel.sendMessageWithPhoto for high-level API
   * @see Message.photoUrl for photo URL storage
   */
  suspend fun sendPhotoMessageToDiscussion(
      discussion: Discussion,
      sender: Account,
      content: String,
      photoUrl: String
  ): String {
    val timestamp = Timestamp.now()
    val messageNoUid =
        MessageNoUid(sender.uid, content, timestamp, poll = null, photoUrl = photoUrl)
    return sendMessageToDiscussion(discussion, messageNoUid)
  }

  /**
   * Internal method to send a message to the discussion with intelligent preview formatting.
   *
   * This private overload handles all message types (text, photo, poll) and formats the preview
   * text appropriately:
   * - **Text messages**: Shows full content
   * - **Photo messages**: Shows photo icon prefix
   * - **Poll messages**: Shows "ðŸ“Š Poll: {question}" format
   *
   * Used internally by:
   * - [sendMessageToDiscussion] for text messages
   * - [sendPhotoMessageToDiscussion] for photo messages
   * - [createPoll] for poll messages
   *
   * @param discussion The discussion to send the message to.
   * @param messageNoUid The message data without UID (UID is generated by Firestore).
   * @return The message document ID (UID) of the created message.
   */
  private suspend fun sendMessageToDiscussion(
      discussion: Discussion,
      messageNoUid: MessageNoUid
  ): String {
    val batch = FirebaseFirestore.getInstance().batch()

    // Add message to subcollection
    val messageRef = messagesCollection(discussion.uid).document()
    batch.set(messageRef, messageNoUid)

    // Update previews for all participants
    discussion.participants.forEach { userId ->
      val ref =
          accounts.document(userId).collection(Account::previews.name).document(discussion.uid)
      val unreadCountValue = if (userId == messageNoUid.senderId) 0 else FieldValue.increment(1)

      // Determine preview text based on message type
      val previewText =
          when {
            messageNoUid.poll != null -> "Poll: ${messageNoUid.poll.question}"
            messageNoUid.photoUrl != null -> PHOTO_MESSAGE_PREVIEW
            else -> messageNoUid.content
          }

      batch.set(
          ref,
          mapOf(
              "lastMessage" to previewText,
              "lastMessageSender" to messageNoUid.senderId,
              "lastMessageAt" to messageNoUid.createdAt,
              "unreadCount" to unreadCountValue),
          SetOptions.merge())
    }

    batch.commit().await()
    return messageRef.id
  }

  /** Reset unread count for a given discussion for this account. */
  suspend fun readDiscussionMessages(accountId: String, discussionId: String, message: Message) {
    val ref = accounts.document(accountId).collection(Account::previews.name).document(discussionId)
    val snapshot = ref.get().await()
    val existing = snapshot.toObject(DiscussionPreviewNoUid::class.java)

    if (existing != null) ref.set(existing.copy(unreadCount = 0))
    else ref.set(DiscussionPreviewNoUid(message.content, message.senderId, message.createdAt, 0))
  }

  /**
   * Listen for changes to a specific discussion document.
   *
   * Emits a new [Discussion] every time the Firestore snapshot updates.
   */
  fun listenDiscussion(discussionId: String): Flow<Discussion> = callbackFlow {
    val reg =
        collection.document(discussionId).addSnapshotListener { snap, e ->
          if (e != null) {
            close(e)
            return@addSnapshotListener
          }
          if (snap != null && snap.exists()) {
            snap.toObject(DiscussionNoUid::class.java)?.let { trySend(fromNoUid(snap.id, it)) }
          }
        }
    awaitClose { reg.remove() }
  }

  /**
   * Retrieve messages for a discussion, ordered by creation time (newest first).
   *
   * Fetches message documents from the `messages` subcollection with optional limit for pagination.
   * By default, returns the most recent 50 messages. Messages are returned in chronological order
   * (oldest first) for display purposes.
   *
   * ## Pagination Strategy
   * - Queries messages in descending order (newest first)
   * - Applies limit to get most recent N messages
   * - Reverses results to return oldest-to-newest for display
   * - Use [getMessagesBeforeTimestamp] to load older messages when user scrolls up
   *
   * ## Performance Considerations
   * - Default limit prevents loading all messages at once
   * - Use [listenMessages] for real-time updates instead of polling this method
   *
   * @param discussionId The discussion UID.
   * @param limit Maximum number of messages to fetch (default: 50).
   * @return List of messages ordered by createdAt timestamp (oldest first, limited to most recent).
   * @see getMessagesBeforeTimestamp to fetch older messages for pagination
   * @see getMessage to fetch a single message by ID
   * @see listenMessages for real-time message updates via Flow
   */
  suspend fun getMessages(discussionId: String, limit: Int = 50): List<Message> {
    val snapshot =
        messagesCollection(discussionId)
            .orderBy(FIELD_CREATED_AT, com.google.firebase.firestore.Query.Direction.DESCENDING)
            .limit(limit.toLong())
            .get()
            .await()
    return snapshot.documents
        .mapNotNull { doc -> doc.toObject(MessageNoUid::class.java)?.let { fromNoUid(doc.id, it) } }
        .reversed() // Reverse to get oldest-to-newest for display
  }

  /**
   * Retrieve older messages before a specific timestamp for pagination.
   *
   * Fetches messages that were created before the given timestamp, useful for implementing "load
   * more" functionality when the user scrolls to the top of the message list.
   *
   * ## Typical Usage Flow
   * 1. Initial load: `getMessages(discussionId)` fetches most recent 50 messages
   * 2. User scrolls to top: Get oldest message's timestamp
   * 3. Load more: `getMessagesBeforeTimestamp(discussionId, oldestTimestamp, 50)`
   * 4. Prepend results to existing messages
   *
   * ## Example
   *
   * ```kotlin
   * val initialMessages = getMessages(discussionId)
   * val oldestTimestamp = initialMessages.firstOrNull()?.createdAt
   * if (oldestTimestamp != null) {
   *   val olderMessages = getMessagesBeforeTimestamp(discussionId, oldestTimestamp, 50)
   *   val allMessages = olderMessages + initialMessages
   * }
   * ```
   *
   * @param discussionId The discussion UID.
   * @param beforeTimestamp Fetch messages created before this timestamp.
   * @param limit Maximum number of messages to fetch (default: 50).
   * @return List of messages ordered by createdAt timestamp (oldest first), created before the
   *   given timestamp.
   * @see getMessages for initial message load
   */
  suspend fun getMessagesBeforeTimestamp(
      discussionId: String,
      beforeTimestamp: Timestamp,
      limit: Int = 50
  ): List<Message> {
    val snapshot =
        messagesCollection(discussionId)
            .orderBy(FIELD_CREATED_AT, com.google.firebase.firestore.Query.Direction.DESCENDING)
            .whereLessThan(FIELD_CREATED_AT, beforeTimestamp)
            .limit(limit.toLong())
            .get()
            .await()
    return snapshot.documents
        .mapNotNull { doc -> doc.toObject(MessageNoUid::class.java)?.let { fromNoUid(doc.id, it) } }
        .reversed() // Reverse to get oldest-to-newest for display
  }

  /**
   * Retrieve the most recent message in a discussion.
   *
   * Efficiently fetches only the last message by ordering by creation time descending and limiting
   * to 1 result. This is much more efficient than calling `getMessages().lastOrNull()`.
   *
   * ## Use Cases
   * - Populating discussion previews when adding new participants
   * - Marking messages as read (need last message timestamp)
   * - Checking if discussion has any messages
   *
   * @param discussionId The discussion UID.
   * @return The most recent message if any exist, null if discussion has no messages.
   * @see getMessages to fetch multiple recent messages
   * @see getMessage to fetch a specific message by ID
   */
  suspend fun getLastMessage(discussionId: String): Message? {
    val snapshot =
        messagesCollection(discussionId)
            .orderBy(FIELD_CREATED_AT, com.google.firebase.firestore.Query.Direction.DESCENDING)
            .limit(1)
            .get()
            .await()
    return snapshot.documents.firstOrNull()?.let { doc ->
      doc.toObject(MessageNoUid::class.java)?.let { fromNoUid(doc.id, it) }
    }
  }

  /**
   * Retrieve a specific message by ID.
   *
   * Fetches a single message document from the messages subcollection. Useful for operations that
   * need current message state, such as poll voting.
   *
   * @param discussionId The discussion UID.
   * @param messageId The message UID (document ID in messages subcollection).
   * @return The message if found, null if the message doesn't exist.
   * @see getMessages to fetch all messages for a discussion
   * @see voteOnPoll which uses this to get current poll state before voting
   */
  suspend fun getMessage(discussionId: String, messageId: String): Message? {
    val snapshot = messagesCollection(discussionId).document(messageId).get().await()
    return snapshot.toObject(MessageNoUid::class.java)?.let { fromNoUid(snapshot.id, it) }
  }

  /**
   * Listen for real-time changes to messages in a discussion.
   *
   * Returns a Flow that emits the complete list of messages whenever the messages subcollection
   * changes (new message added, message updated, etc.). Messages are ordered by creation time.
   *
   * ## Flow Behavior
   * - Initial emission contains all existing messages
   * - Subsequent emissions contain updated full message list when any change occurs
   * - Flow completes when listener is removed (via awaitClose)
   * - Errors cause the Flow to close with an exception
   *
   * ## Usage Example
   *
   * ```kotlin
   * discussionRepository.listenMessages(discussionId)
   *   .collect { messages ->
   *     // Update UI with new message list
   *   }
   * ```
   *
   * @param discussionId The discussion UID.
   * @return Flow emitting lists of messages ordered by createdAt timestamp.
   * @see getMessages for one-time message fetch
   * @see listenDiscussion for real-time discussion metadata updates
   */
  fun listenMessages(discussionId: String): Flow<List<Message>> = callbackFlow {
    val reg =
        messagesCollection(discussionId).orderBy(FIELD_CREATED_AT).addSnapshotListener { snap, e ->
          if (e != null) {
            close(e)
            return@addSnapshotListener
          }
          if (snap != null) {
            val messages =
                snap.documents.mapNotNull { doc ->
                  doc.toObject(MessageNoUid::class.java)?.let { fromNoUid(doc.id, it) }
                }
            trySend(messages)
          }
        }
    awaitClose { reg.remove() }
  }

  // ============================================================================
  // Poll Methods
  // ============================================================================

  /**
   * Create a new poll in a discussion by sending a message with poll data.
   *
   * @param discussion The discussion where the poll will be created.
   * @param creatorId The ID of the account creating the poll.
   * @param question The poll question.
   * @param options List of options users can vote for.
   * @param allowMultipleVotes Whether users can vote multiple times.
   * @return The created poll message with its UID.
   */
  suspend fun createPoll(
      discussion: Discussion,
      creatorId: String,
      question: String,
      options: List<String>,
      allowMultipleVotes: Boolean = false
  ): Message {
    val poll =
        Poll(
            question = question,
            options = options,
            votes = emptyMap(),
            allowMultipleVotes = allowMultipleVotes)

    val timestamp = Timestamp.now()
    val messageNoUid =
        MessageNoUid(senderId = creatorId, content = question, createdAt = timestamp, poll = poll)

    val messageId = sendMessageToDiscussion(discussion, messageNoUid)

    return Message(messageId, creatorId, question, timestamp, poll)
  }

  /**
   * Vote on a poll option.
   *
   * @param discussionId The discussion UID containing the poll.
   * @param messageId The message UID containing the poll.
   * @param userId The user's UID.
   * @param optionIndex The index of the option to vote for.
   */
  suspend fun voteOnPoll(
      discussionId: String,
      messageId: String,
      userId: String,
      optionIndex: Int
  ) {
    // Get the current message
    val currentMessage =
        getMessage(discussionId, messageId) ?: throw IllegalArgumentException("Message not found")

    val currentPoll =
        currentMessage.poll ?: throw IllegalArgumentException("Message does not contain a poll")

    if (optionIndex !in currentPoll.options.indices) {
      throw IllegalArgumentException("Invalid option index")
    }

    // Calculate updated votes
    val updatedVotes = currentPoll.votes.toMutableMap()
    val currentVotes = updatedVotes[userId]?.toMutableList() ?: mutableListOf()

    if (currentPoll.allowMultipleVotes) {
      // Multiple vote mode: add to user's votes if not already voted for this option
      if (optionIndex !in currentVotes) {
        currentVotes.add(optionIndex)
        updatedVotes[userId] = currentVotes
      }
    } else {
      // Single vote mode: replace with single option
      updatedVotes[userId] = listOf(optionIndex)
    }

    // Update the message document with new poll data
    val updatedPoll = currentPoll.copy(votes = updatedVotes)
    messagesCollection(discussionId).document(messageId).update("poll", updatedPoll).await()
  }

  /**
   * Remove a user's vote for a specific poll option. Called when user clicks an option they
   * previously selected to deselect it.
   *
   * @param discussionId The discussion UID containing the poll.
   * @param messageId The message UID containing the poll.
   * @param userId The user's UID.
   * @param optionIndex The specific option index to remove.
   */
  suspend fun removeVoteFromPoll(
      discussionId: String,
      messageId: String,
      userId: String,
      optionIndex: Int
  ) {
    // Get the current message
    val currentMessage =
        getMessage(discussionId, messageId) ?: throw IllegalArgumentException("Message not found")

    val currentPoll =
        currentMessage.poll ?: throw IllegalArgumentException("Message does not contain a poll")

    // Check if user has voted
    val currentVotes = currentPoll.votes[userId]
    if (currentVotes == null || currentVotes.isEmpty()) {
      throw IllegalArgumentException("User has not voted on this poll")
    }

    // Verify user voted for this specific option
    if (optionIndex !in currentVotes) {
      throw IllegalArgumentException("User did not vote for option $optionIndex")
    }

    // Calculate updated votes
    val updatedVotes = currentPoll.votes.toMutableMap()
    val updatedUserVotes = currentVotes.toMutableList()
    updatedUserVotes.remove(optionIndex)

    if (updatedUserVotes.isEmpty()) {
      // If no votes left, remove user from votes map entirely
      updatedVotes.remove(userId)
    } else {
      updatedVotes[userId] = updatedUserVotes
    }

    // Update the message document with new poll data
    val updatedPoll = currentPoll.copy(votes = updatedVotes)
    messagesCollection(discussionId).document(messageId).update("poll", updatedPoll).await()
  }
}
