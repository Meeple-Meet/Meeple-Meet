// All components were done by hand primarily
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.sessions

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.onFocusChanged
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.FriendsScreenViewModel
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.rental.RentalViewModel
import com.github.meeplemeet.model.sessions.Session
import com.github.meeplemeet.model.sessions.SessionEditViewModel
import com.github.meeplemeet.model.shared.GameUIState
import com.github.meeplemeet.model.shared.location.Location
import com.github.meeplemeet.ui.FocusableInputField
import com.github.meeplemeet.ui.UiBehaviorConfig
import com.github.meeplemeet.ui.components.DateAndTimePicker
import com.github.meeplemeet.ui.components.SectionCard
import com.github.meeplemeet.ui.components.SessionGameSearchBar
import com.github.meeplemeet.ui.components.SessionParticipantAvatar
import com.github.meeplemeet.ui.components.TopBarWithDivider
import com.github.meeplemeet.ui.components.timestampToLocal
import com.github.meeplemeet.ui.rental.SessionLocationSearchWithRental
import com.github.meeplemeet.ui.theme.Dimensions
import com.github.meeplemeet.ui.theme.Elevation
import kotlinx.coroutines.launch

/* ─────────────────────────────────────────────────────────────────────────────
 *  Test tags
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** Test tags for Session Edit screen */
object SessionEditTestTags {
  const val SCAFFOLD = "edit_session_scaffold"
  const val SNACKBAR_HOST = "edit_session_snackbar_host"
  const val CONTENT_COLUMN = "edit_session_content_column"

  const val ORG_SECTION = "edit_session_organisation_section"
  const val PARTICIPANTS_SECTION = "edit_session_participants_section"
  const val PARTICIPANT_SEARCH = "edit_session_participant_search"
  const val PARTICIPANT_SEARCH_DROPDOWN = "edit_session_participant_search_dropdown"

  const val BUTTON_ROW = "edit_session_button_row"
  const val DELETE_BUTTON = "edit_session_delete_button"
  const val DELETE_ICON = "edit_session_delete_icon"
  const val SAVE_BUTTON = "edit_session_save_button"
  const val SAVE_ICON = "edit_session_save_icon"
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Magic strings / numbers
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** Placeholder label for unknown game */
object SessionEditNumbers {
  const val MAX_EDIT_TITLE_LENGTH: Int = 100
  const val SEARCH_ALPHA = 0.9f
}

/** Placeholder label for unknown game */
object SessionEditStrings {
  const val EDIT_SCREEN_TITLE = "Edit Session"
  const val LABEL_SAVE = "Save"
  const val LABEL_DELETE = "Delete"
  const val LABEL_EDIT_TITLE = "Edit Title"
  const val LABEL_PARTICIPANTS = "Participants"
  const val LABEL_PARTICIPANT_SEARCH = "Add members"
  const val TEXT_NO_SESSION = "No session to edit"
  const val SCHEDULE_AND_LOCATION_TEXT = "Where & When"
  const val TITLE_TEXT = "Title"
  const val INFO_SECTION_TEXT = "Basic Info"
  const val FAILING_UPDATE_SESSION = "Failed to update session"
  const val FAILING_DELETE_SESSION = "Failed to delete session"
  const val FAILING_LOAD_GAME = "Failed to load game"
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Helpers
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** State for managing participants in session edit screen */
private data class SessionEditParticipantState(
    val form: SessionForm,
    val participantSearchQuery: String,
    val suggestions: List<Account>,
    val allDiscussionMembers: List<Account>,
)

/** Callbacks for session edit interactions */
private data class SessionEditCallbacks(
    val onFormChange: (SessionForm) -> Unit,
    val onParticipantSearchQueryChange: (String) -> Unit,
    val onClearQuery: () -> Unit,
    val onAllDiscussionMembersChange: (List<Account>) -> Unit,
    val onFocusChanged: (Boolean) -> Unit,
)

/* ─────────────────────────────────────────────────────────────────────────────
 *  Main screen
 * ─────────────────────────────────────────────────────────────────────────────
 */

/**
 * Screen for editing an existing session within a discussion.
 *
 * @param account The current user's account.
 * @param discussion The discussion containing the session to edit.
 * @param viewModel The session view model.
 * @param rentalViewModel The viewmodel for rent operations.
 * @param onBack Callback invoked to navigate back from the screen.
 */
@Composable
fun SessionEditScreen(
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel = viewModel(key = discussion.uid),
    rentalViewModel: RentalViewModel = viewModel(),
    onBack: () -> Unit = {},
) {
  val session: Session? = discussion.session

  if (session == null) {
    EmptySessionEditScreen(onBack)
    return
  }

  var form by remember { mutableStateOf(SessionForm()) }
  var allDiscussionMembers by remember { mutableStateOf<List<Account>>(emptyList()) }
  var selectedRentalId by remember { mutableStateOf(session.rentalId) }

  val gameUi: GameUIState by viewModel.gameUIState.collectAsState()
  val locationUi by viewModel.locationUIState.collectAsState()

  val snackbar = remember { SnackbarHostState() }
  val scope = rememberCoroutineScope()
  val focusManager = LocalFocusManager.current
  val context = LocalContext.current

  var isInputFocused by remember { mutableStateOf(false) }
  var participantSearchQuery by rememberSaveable { mutableStateOf("") }
  val trimmedQuery = remember(participantSearchQuery) { participantSearchQuery.trim() }

  val searchViewModel: FriendsScreenViewModel = viewModel()
  val rawSuggestions by searchViewModel.handleSuggestions.collectAsStateWithLifecycle()

  LaunchedEffect(trimmedQuery) { searchViewModel.searchByHandle(trimmedQuery) }

  val suggestions =
      remember(rawSuggestions, trimmedQuery) {
        if (trimmedQuery.isBlank()) emptyList() else rawSuggestions
      }

  val showError: (String) -> Unit = { msg -> scope.launch { snackbar.showSnackbar(msg) } }

  // Load users active rentals
  LaunchedEffect(account.uid) { rentalViewModel.loadActiveSpaceRentals(account.uid) }

  LaunchedEffect(discussion.uid) {
    val (date, time) = timestampToLocal(session.date)

    val allIds = (discussion.participants + session.participants).distinct()

    viewModel.getAccounts(allIds, context) { accounts ->
      val resolved = accounts.filterNotNull()

      allDiscussionMembers = resolved.distinctBy { it.uid }
      val participantAccounts = resolved.filter { it.uid in session.participants }

      form =
          SessionForm(
              title = session.name,
              proposedGameString = session.gameId,
              participants = participantAccounts,
              date = date,
              time = time,
              locationText = session.location.name,
          )
    }

    if (session.gameId.isNotBlank()) {
      runCatching { viewModel.getGameFromId(session.gameId) }
          .onFailure { e -> showError(e.message ?: SessionEditStrings.FAILING_LOAD_GAME) }
    }
  }

  val discussionMembersForList =
      remember(allDiscussionMembers, form.participants, discussion.creatorId) {
        val merged = (allDiscussionMembers + form.participants).distinctBy { it.uid }

        val (ownerList, others) = merged.partition { it.uid == discussion.creatorId }

        others + ownerList
      }

  val isPast = isDateTimeInPast(form.date, form.time)
  val canSave = form.title.isNotBlank() && form.date != null && form.time != null && !isPast

  val participantState =
      SessionEditParticipantState(
          form = form,
          participantSearchQuery = participantSearchQuery,
          suggestions = suggestions,
          allDiscussionMembers = allDiscussionMembers,
      )

  val callbacks =
      SessionEditCallbacks(
          onFormChange = { form = it },
          onParticipantSearchQueryChange = { participantSearchQuery = it },
          onClearQuery = { participantSearchQuery = "" },
          onAllDiscussionMembersChange = { allDiscussionMembers = it },
          onFocusChanged = { isInputFocused = it },
      )

  Scaffold(
      modifier = Modifier.testTag(SessionEditTestTags.SCAFFOLD),
      topBar = {
        TopBarWithDivider(
            text = SessionEditStrings.EDIT_SCREEN_TITLE,
            onReturn = { onBack() },
        )
      },
      snackbarHost = {
        SnackbarHost(
            hostState = snackbar, modifier = Modifier.testTag(SessionEditTestTags.SNACKBAR_HOST))
      },
      bottomBar = {
        val shouldHide = UiBehaviorConfig.hideBottomBarWhenInputFocused
        if (!(shouldHide && isInputFocused)) {
          Row(
              modifier =
                  Modifier.fillMaxWidth()
                      .padding(
                          horizontal = Dimensions.Padding.xxxLarge,
                          vertical = Dimensions.Padding.xxLarge)
                      .testTag(SessionEditTestTags.BUTTON_ROW),
              horizontalArrangement = Arrangement.spacedBy(Dimensions.Spacing.extraLarge)) {
                DeleteSessionButton(
                    modifier = Modifier.weight(weight = 1f),
                    onDelete = {
                      val result = runCatching { viewModel.deleteSession(account, discussion) }
                      result.onFailure { e ->
                        showError(e.message ?: SessionEditStrings.FAILING_DELETE_SESSION)
                      }
                      result.onSuccess { onBack() }
                    },
                )

                SaveSessionButton(
                    formToSubmit = form,
                    enabled = canSave,
                    modifier = Modifier.weight(weight = 1f),
                    onSave = { updated ->
                      val result =
                          runCatching {
                                val selectedResult = gameUi.selectedGameSearchResult

                                val finalGameId =
                                    selectedResult?.id
                                        ?: updated.proposedGameString.ifBlank {
                                          session.gameId.ifBlank { LABEL_UNKNOWN_GAME }
                                        }

                                val finalGameName =
                                    selectedResult?.name
                                        ?: session.gameName.ifBlank { LABEL_UNKNOWN_GAME }

                                val finalParticipantIds = updated.participants.map { it.uid }

                                viewModel.updateSession(
                                    requester = account,
                                    discussion = discussion,
                                    name = updated.title,
                                    gameId = finalGameId,
                                    gameName = finalGameName,
                                    date = toTimestamp(updated.date, updated.time),
                                    location = locationUi.selectedLocation ?: session.location,
                                    participants = finalParticipantIds,
                                    rentalId = selectedRentalId)

                                if (selectedRentalId != session.rentalId) {
                                  scope.launch {
                                    try {
                                      // Dissociate old rental ID if it exists
                                      session.rentalId?.let { oldRentalId ->
                                        rentalViewModel.dissociateRentalFromSession(oldRentalId)
                                      }
                                      // Associate new rental ID if it exists
                                      selectedRentalId?.let { newRentalId ->
                                        rentalViewModel.associateRentalWithSession(
                                            rentalId = newRentalId, sessionId = discussion.uid)
                                      }
                                    } catch (e: Exception) {
                                      e.printStackTrace()
                                    }
                                  }
                                }
                              }
                              .onFailure { e ->
                                showError(e.message ?: SessionEditStrings.FAILING_UPDATE_SESSION)
                                return@SaveSessionButton
                              }

                      result.onSuccess { onBack() }
                    },
                )
              }
        }
      }) { innerPadding ->
        Column(
            modifier =
                Modifier.fillMaxSize()
                    .background(MaterialTheme.colorScheme.background)
                    .padding(innerPadding)
                    .padding(
                        horizontal = Dimensions.Padding.extraLarge,
                        vertical = Dimensions.Padding.medium)
                    .pointerInput(Unit) { detectTapGestures(onTap = { focusManager.clearFocus() }) }
                    .verticalScroll(rememberScrollState())
                    .testTag(SessionEditTestTags.CONTENT_COLUMN),
            verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.none)) {
              EditOrganisationSection(
                  account = account,
                  discussion = discussion,
                  form = form,
                  gameUi = gameUi,
                  viewModel = viewModel,
                  rentalViewModel = rentalViewModel,
                  onFormChange = callbacks.onFormChange,
                  onFocusChanged = callbacks.onFocusChanged,
                  onRentalSelected = { rentalId, location ->
                    selectedRentalId = rentalId
                    viewModel.setLocation(account, discussion, location)
                  })

              SessionEditParticipantsBlock(
                  account = account,
                  gameUi = gameUi,
                  discussionMembersForList = discussionMembersForList,
                  participantState = participantState,
                  callbacks = callbacks,
              )
            }
      }
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Components
 * ─────────────────────────────────────────────────────────────────────────────
 */

/**
 * Participants management block including search bar and participants list.
 *
 * @param account The current user's account.
 * @param gameUi The current game UI state.
 * @param discussionMembersForList The list of discussion members for displaying in the participants
 *   list.
 * @param participantState The current participant state.
 * @param callbacks The callbacks for handling participant interactions.
 */
@Composable
private fun ColumnScope.SessionEditParticipantsBlock(
    account: Account,
    gameUi: GameUIState,
    discussionMembersForList: List<Account>,
    participantState: SessionEditParticipantState,
    callbacks: SessionEditCallbacks,
) {
  val form = participantState.form
  val participantSearchQuery = participantState.participantSearchQuery
  val suggestions = participantState.suggestions
  val allDiscussionMembers = participantState.allDiscussionMembers

  Spacer(Modifier.height(Dimensions.Spacing.extraLarge))

  ParticipantSearchBar(
      query = participantSearchQuery,
      onQueryChange = callbacks.onParticipantSearchQueryChange,
      onClearQuery = callbacks.onClearQuery,
      onFocusChanged = callbacks.onFocusChanged,
      modifier = Modifier.align(Alignment.CenterHorizontally),
  )

  val currentParticipantIds =
      remember(form.participants) { form.participants.map { it.uid }.toSet() }

  if (suggestions.isNotEmpty() && participantSearchQuery.trim().isNotBlank()) {
    Spacer(Modifier.height(Dimensions.Spacing.small))

    ParticipantSearchDropdown(
        currentAccount = account,
        results = suggestions,
        existingParticipantIds = currentParticipantIds,
        onAddToSession = { user ->
          val updatedForm =
              form.copy(
                  participants = (form.participants + user).distinctBy { it.uid },
              )
          callbacks.onFormChange(updatedForm)

          val updatedMembers = (allDiscussionMembers + user).distinctBy { it.uid }
          callbacks.onAllDiscussionMembersChange(updatedMembers)
        },
        onClearFocus = { callbacks.onFocusChanged(false) },
        modifier = Modifier.align(Alignment.CenterHorizontally),
    )
  }

  Spacer(Modifier.height(Dimensions.Spacing.medium))

  ParticipantsSection(
      account = account,
      selected = form.participants,
      allCandidates = discussionMembersForList,
      minPlayers = gameUi.fetchedGame?.minPlayers ?: 0,
      maxPlayers = gameUi.fetchedGame?.maxPlayers ?: 0,
      onAdd = { toAdd ->
        val updatedForm =
            form.copy(
                participants = (form.participants + toAdd).distinctBy { it.uid },
            )
        callbacks.onFormChange(updatedForm)
      },
      onRemove = { toRemove ->
        if (toRemove.uid != account.uid) {
          val updatedForm =
              form.copy(
                  participants = form.participants.filterNot { it.uid == toRemove.uid },
              )
          callbacks.onFormChange(updatedForm)
        }
      },
      mainSectionTitle = SessionEditStrings.LABEL_PARTICIPANTS,
      modifier = Modifier.testTag(SessionEditTestTags.PARTICIPANTS_SECTION),
  )
}

/**
 * Screen displayed when there is no session to edit.
 *
 * @param onBack Callback invoked to navigate back from the screen.
 */
@Composable
private fun EmptySessionEditScreen(onBack: () -> Unit) {
  Scaffold(
      topBar = {
        TopBarWithDivider(
            text = SessionEditStrings.EDIT_SCREEN_TITLE,
            onReturn = onBack,
        )
      }) { innerPadding ->
        Box(
            modifier =
                Modifier.fillMaxSize()
                    .padding(innerPadding)
                    .background(MaterialTheme.colorScheme.background),
            contentAlignment = Alignment.Center) {
              Text(
                  text = SessionEditStrings.TEXT_NO_SESSION,
                  style = MaterialTheme.typography.bodyMedium,
                  color = MaterialTheme.colorScheme.onBackground)
            }
      }
}

/**
 * Organisation section containing title, game, schedule, and location inputs.
 *
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param form The current session form state.
 * @param gameUi The current game UI state.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditOrganisationSection(
    account: Account,
    discussion: Discussion,
    form: SessionForm,
    gameUi: GameUIState,
    viewModel: SessionEditViewModel,
    rentalViewModel: RentalViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
    onRentalSelected: (String, Location) -> Unit = { _, _ -> }
) {
  SectionCard(
      Modifier.testTag(SessionEditTestTags.ORG_SECTION)
          .fillMaxWidth()
          .background(MaterialTheme.colorScheme.background, MaterialTheme.shapes.large)) {
        EditTitleAndGameSection(
            form = form,
            gameUi = gameUi,
            account = account,
            discussion = discussion,
            viewModel = viewModel,
            onFormChange = onFormChange,
            onFocusChanged = onFocusChanged,
        )

        Spacer(Modifier.height(Dimensions.Spacing.xLarge))

        EditScheduleAndLocationSection(
            form = form,
            account = account,
            discussion = discussion,
            viewModel = viewModel,
            rentalViewModel = rentalViewModel,
            onFormChange = onFormChange,
            onFocusChanged = onFocusChanged,
            onRentalSelected = onRentalSelected)
      }
}

/**
 * Title and game selection section
 *
 * @param form The current session form state.
 * @param gameUi The current game UI state.
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditTitleAndGameSection(
    form: SessionForm,
    gameUi: GameUIState,
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
) {
  Text(
      text = SessionEditStrings.INFO_SECTION_TEXT,
      style = MaterialTheme.typography.titleLarge,
      color = MaterialTheme.colorScheme.onBackground)

  Spacer(Modifier.height(Dimensions.Spacing.small))

  FocusableInputField(
      value = form.title,
      onValueChange = { newTitle ->
        if (newTitle.length <= SessionEditNumbers.MAX_EDIT_TITLE_LENGTH) {
          onFormChange(form.copy(title = newTitle))
        }
      },
      label = { Text(text = SessionEditStrings.TITLE_TEXT) },
      leadingIcon = {
        Icon(
            imageVector = Icons.Default.Edit,
            contentDescription = SessionEditStrings.LABEL_EDIT_TITLE,
            tint = MaterialTheme.colorScheme.onBackground)
      },
      modifier =
          Modifier.fillMaxWidth().testTag(SessionCreationTestTags.FORM_TITLE_FIELD).onFocusChanged {
            onFocusChanged(it.isFocused)
          },
  )

  Spacer(Modifier.height(Dimensions.Spacing.extraMedium))

  Box(Modifier.onFocusChanged { onFocusChanged(it.isFocused) }) {
    SessionGameSearchBar(
        account = account,
        discussion = discussion,
        viewModel = viewModel,
        initial = gameUi.selectedGameSearchResult,
    )
  }
}

/**
 * Schedule and location section
 *
 * @param form The current session form state.
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditScheduleAndLocationSection(
    form: SessionForm,
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel,
    rentalViewModel: RentalViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
    onRentalSelected: (String, Location) -> Unit = { _, _ -> }
) {
  Text(
      text = SessionEditStrings.SCHEDULE_AND_LOCATION_TEXT,
      style = MaterialTheme.typography.titleLarge,
      color = MaterialTheme.colorScheme.onBackground)

  Spacer(Modifier.height(Dimensions.Spacing.small))

  DateAndTimePicker(
      date = form.date,
      time = form.time,
      onDateChange = { newDate -> onFormChange(form.copy(date = newDate)) },
      onFocusChanged = onFocusChanged,
      onTimeChange = { newTime -> onFormChange(form.copy(time = newTime)) },
  )

  Spacer(Modifier.height(Dimensions.Spacing.extraMedium))

  Box(Modifier.onFocusChanged { onFocusChanged(it.isFocused) }) {
    SessionLocationSearchWithRental(
        account = account,
        discussion = discussion,
        sessionViewModel = viewModel,
        rentalViewModel = rentalViewModel,
        sessionDate = form.date,
        sessionTime = form.time,
        onDateTimeUpdate = { newDate, newTime ->
          onFormChange(form.copy(date = newDate, time = newTime))
        },
        onRentalSelected = onRentalSelected)
  }
}

/**
 * Search bar for adding participants by global handle search
 *
 * @param query The current search query.
 * @param onQueryChange Callback invoked when the query changes.
 * @param onClearQuery Callback invoked to clear the current query.
 * @param onFocusChanged Callback invoked when the focus state changes.
 * @param modifier Modifier to be applied to the search bar container.
 */
@Composable
private fun ParticipantSearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    onClearQuery: () -> Unit,
    onFocusChanged: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
) {
  val fieldShape = CircleShape

  FocusableInputField(
      value = query,
      onValueChange = onQueryChange,
      modifier =
          modifier
              .fillMaxWidth(fraction = SessionEditNumbers.SEARCH_ALPHA)
              .height(Dimensions.ContainerSize.timeFieldHeight)
              .border(
                  BorderStroke(
                      width = Dimensions.DividerThickness.standard,
                      color = MaterialTheme.colorScheme.onSurfaceVariant,
                  ),
                  shape = fieldShape,
              )
              .testTag(SessionEditTestTags.PARTICIPANT_SEARCH),
      placeholder = {
        Text(
            text = SessionEditStrings.LABEL_PARTICIPANT_SEARCH,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis,
        )
      },
      singleLine = true,
      leadingIcon = { Spacer(modifier = Modifier.width(Dimensions.Spacing.medium)) },
      trailingIcon = {
        if (query.isNotEmpty()) {
          IconButton(onClick = onClearQuery) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Clear search",
                tint = MaterialTheme.colorScheme.onSurfaceVariant,
            )
          }
        } else {
          Icon(
              imageVector = Icons.Default.Search,
              contentDescription = "Search participants",
              tint = MaterialTheme.colorScheme.onSurfaceVariant,
          )
        }
      },
      textStyle = MaterialTheme.typography.bodyMedium,
      shape = fieldShape,
      colors =
          TextFieldDefaults.colors(
              focusedContainerColor = Color.Transparent,
              unfocusedContainerColor = Color.Transparent,
              disabledContainerColor = Color.Transparent,
              focusedIndicatorColor = Color.Transparent,
              unfocusedIndicatorColor = Color.Transparent,
              disabledIndicatorColor = Color.Transparent,
              cursorColor = MaterialTheme.colorScheme.onSurfaceVariant,
              focusedTextColor = MaterialTheme.colorScheme.onSurfaceVariant,
              unfocusedTextColor = MaterialTheme.colorScheme.onSurfaceVariant,
          ),
      onFocusChanged = onFocusChanged,
  )
}

/**
 * Dropdown list of accounts found by global handle search, allowing adding them to the session.
 *
 * @param currentAccount The account of the current user.
 * @param results The list of accounts matching the search query.
 * @param existingParticipantIds The set of user IDs already in the session.
 * @param onAddToSession Callback invoked when a user is selected to be added to the session.
 * @param onClearFocus Callback invoked to clear input focus (hiding the dropdown).
 * @param modifier Modifier to be applied to the dropdown container.
 */
@Composable
private fun ParticipantSearchDropdown(
    currentAccount: Account,
    results: List<Account>,
    existingParticipantIds: Set<String>,
    onAddToSession: (Account) -> Unit,
    onClearFocus: () -> Unit,
    modifier: Modifier = Modifier,
) {
  val visibleResults =
      remember(results, existingParticipantIds, currentAccount.uid) {
        results.filter { candidate ->
          candidate.uid != currentAccount.uid && candidate.uid !in existingParticipantIds
        }
      }

  if (visibleResults.isEmpty()) return

  Surface(
      modifier =
          modifier
              .fillMaxWidth(fraction = SessionEditNumbers.SEARCH_ALPHA)
              .testTag(SessionEditTestTags.PARTICIPANT_SEARCH_DROPDOWN)
              .clickable { onClearFocus() },
      tonalElevation = Elevation.raised,
      shadowElevation = Elevation.raised,
      shape = MaterialTheme.shapes.medium,
      color = MaterialTheme.colorScheme.outline,
  ) {
    Column(
        modifier = Modifier.fillMaxWidth().padding(vertical = Dimensions.Padding.small),
    ) {
      visibleResults.forEach { user ->
        Row(
            modifier =
                Modifier.fillMaxWidth()
                    .clickable {
                      onAddToSession(user)
                      onClearFocus()
                    }
                    .padding(
                        horizontal = Dimensions.Padding.medium,
                        vertical = Dimensions.Padding.small),
            verticalAlignment = Alignment.CenterVertically,
        ) {
          SessionParticipantAvatar(
              account = user,
              modifier = Modifier.size(Dimensions.AvatarSize.small),
          )

          Spacer(Modifier.width(Dimensions.Spacing.medium))

          Column(Modifier.weight(1f)) {
            Text(
                text = user.name,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface,
            )
            Text(
                text = "@${user.handle}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
            )
          }
        }
      }
    }
  }
}

/**
 * Button that deletes the session and returns to the previous screen
 *
 * @param modifier Modifier to be applied to the dropdown container.
 * @param onDelete Callback invoked when the button is clicked.
 */
@Composable
private fun DeleteSessionButton(
    modifier: Modifier = Modifier,
    onDelete: () -> Unit,
) {
  OutlinedButton(
      onClick = onDelete,
      modifier = modifier.testTag(SessionEditTestTags.DELETE_BUTTON),
      shape = CircleShape,
      contentPadding =
          PaddingValues(
              horizontal = Dimensions.Padding.medium, vertical = Dimensions.Padding.small),
      border = BorderStroke(Dimensions.DividerThickness.medium, MaterialTheme.colorScheme.error),
      colors = ButtonDefaults.outlinedButtonColors(contentColor = MaterialTheme.colorScheme.error),
  ) {
    Icon(
        imageVector = Icons.Default.Delete,
        contentDescription = null,
        modifier = Modifier.testTag(SessionEditTestTags.DELETE_ICON),
    )

    Spacer(Modifier.width(Dimensions.Spacing.small))

    Text(
        text = SessionEditStrings.LABEL_DELETE,
        style = MaterialTheme.typography.bodyMedium,
        maxLines = 1,
        softWrap = false,
        overflow = TextOverflow.Ellipsis,
    )
  }
}

/**
 * Button that saves the session changes and returns to the previous screen
 *
 * @param formToSubmit The session form data to submit on save.
 * @param onSave Callback invoked with the session form when the button is clicked.
 * @param modifier Modifier to be applied to the dropdown container.
 * @param enabled Whether the button is enabled or disabled.
 */
@Composable
private fun SaveSessionButton(
    formToSubmit: SessionForm,
    onSave: (SessionForm) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
) {
  Button(
      onClick = { onSave(formToSubmit) },
      enabled = enabled,
      modifier = modifier.testTag(SessionEditTestTags.SAVE_BUTTON),
      shape = CircleShape,
      elevation = ButtonDefaults.buttonElevation(defaultElevation = Elevation.raised),
      colors =
          ButtonDefaults.buttonColors(
              containerColor = MaterialTheme.colorScheme.secondary,
              contentColor = MaterialTheme.colorScheme.onBackground)) {
        Icon(
            imageVector = Icons.Default.Check,
            contentDescription = null,
            modifier = Modifier.testTag(SessionEditTestTags.SAVE_ICON))
        Spacer(Modifier.padding(horizontal = Dimensions.Spacing.medium))
        Text(
            SessionEditStrings.LABEL_SAVE,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium)
      }
}
