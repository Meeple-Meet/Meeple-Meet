// All components were done by hand primarily
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.sessions

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.onFocusChanged
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.FriendsScreenViewModel
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.sessions.SessionEditViewModel
import com.github.meeplemeet.model.shared.GameUIState
import com.github.meeplemeet.ui.FocusableInputField
import com.github.meeplemeet.ui.UiBehaviorConfig
import com.github.meeplemeet.ui.components.DateAndTimePicker
import com.github.meeplemeet.ui.components.SectionCard
import com.github.meeplemeet.ui.components.SessionGameSearchBar
import com.github.meeplemeet.ui.components.SessionLocationSearchButton
import com.github.meeplemeet.ui.components.SessionParticipantAvatar
import com.github.meeplemeet.ui.components.TopBarWithDivider
import com.github.meeplemeet.ui.components.timestampToLocal
import com.github.meeplemeet.ui.theme.Dimensions
import com.github.meeplemeet.ui.theme.Elevation
import kotlinx.coroutines.launch

/* ─────────────────────────────────────────────────────────────────────────────
 *  Test tags
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** Test tags for Session Edit screen */
object SessionEditTestTags {
  const val SCAFFOLD = "edit_session_scaffold"
  const val SNACKBAR_HOST = "edit_session_snackbar_host"
  const val CONTENT_COLUMN = "edit_session_content_column"

  const val ORG_SECTION = "edit_session_organisation_section"
  const val PARTICIPANTS_SECTION = "edit_session_participants_section"
  const val PARTICIPANT_SEARCH = "edit_session_participant_search"
  const val PARTICIPANT_SEARCH_DROPDOWN = "edit_session_participant_search_dropdown"

  const val BUTTON_ROW = "edit_session_button_row"
  const val DELETE_BUTTON = "edit_session_delete_button"
  const val DELETE_ICON = "edit_session_delete_icon"
  const val SAVE_BUTTON = "edit_session_save_button"
  const val SAVE_ICON = "edit_session_save_icon"
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Magic strings / numbers
 * ─────────────────────────────────────────────────────────────────────────────
 */

/** Placeholder label for unknown game */
object SessionEditNumbers {
  const val MAX_EDIT_TITLE_LENGTH: Int = 100
  const val SEARCH_ALPHA = 0.9f
}

/** Placeholder label for unknown game */
object SessionEditStrings {
  const val EDIT_SCREEN_TITLE = "Edit Session"
  const val LABEL_SAVE = "Save"
  const val LABEL_DELETE = "Delete"
  const val LABEL_EDIT_TITLE = "Edit Title"
  const val LABEL_PARTICIPANTS = "Participants"
  const val LABEL_PARTICIPANT_SEARCH = "Add members"
  const val TEXT_NO_SESSION = "No session to edit"
  const val SCHEDULE_AND_LOCATION_TEXT = "Where & When"
  const val TITLE_TEXT = "Title"
  const val INFO_SECTION_TEXT = "Basic Info"
  const val FAILING_UPDATE_SESSION = "Failed to update session"
  const val FAILING_DELETE_SESSION = "Failed to delete session"
  const val FAILING_LOAD_GAME = "Failed to load game"
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Main screen
 * ─────────────────────────────────────────────────────────────────────────────
 */

/**
 * Screen for editing an existing session within a discussion.
 *
 * @param account The current user's account.
 * @param discussion The discussion containing the session to edit.
 * @param viewModel The session view model.
 * @param onBack Callback invoked to navigate back from the screen.
 */
@Composable
fun SessionEditScreen(
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel = viewModel(key = discussion.uid),
    onBack: () -> Unit = {},
) {
  val session = discussion.session

  if (session == null) {
    EmptySessionEditScreen(onBack)
    return
  }

  var form by remember { mutableStateOf(SessionForm()) }
  var allDiscussionMembers by remember { mutableStateOf<List<Account>>(emptyList()) }

  val gameUi: GameUIState by viewModel.gameUIState.collectAsState()
  val locationUi by viewModel.locationUIState.collectAsState()

  val snackbar = remember { SnackbarHostState() }
  val scope = rememberCoroutineScope()
  val focusManager = LocalFocusManager.current
  val context = LocalContext.current

  var isInputFocused by remember { mutableStateOf(false) }
  var participantSearchQuery by rememberSaveable { mutableStateOf("") }
  val trimmedQuery = remember(participantSearchQuery) { participantSearchQuery.trim() }

  val searchViewModel: FriendsScreenViewModel = viewModel()
  val rawSuggestions by searchViewModel.handleSuggestions.collectAsStateWithLifecycle()

  LaunchedEffect(trimmedQuery) { searchViewModel.searchByHandle(trimmedQuery) }

  val suggestions =
      remember(rawSuggestions, trimmedQuery) {
        if (trimmedQuery.isBlank()) emptyList() else rawSuggestions
      }

  val showError: (String) -> Unit = { msg -> scope.launch { snackbar.showSnackbar(msg) } }

  LaunchedEffect(discussion.uid) {
    val (date, time) = timestampToLocal(session.date)

    val allIds = (discussion.participants + session.participants).distinct()

    viewModel.getAccounts(allIds, context) { accounts ->
      val resolved = accounts.filterNotNull()

      allDiscussionMembers = resolved.distinctBy { it.uid }
      val participantAccounts = resolved.filter { it.uid in session.participants }

      form =
          SessionForm(
              title = session.name,
              proposedGameString = session.gameId,
              participants = participantAccounts,
              date = date,
              time = time,
              locationText = session.location.name,
          )
    }

    if (session.gameId.isNotBlank()) {
      runCatching { viewModel.getGameFromId(session.gameId) }
          .onFailure { e -> showError(e.message ?: SessionEditStrings.FAILING_LOAD_GAME) }
    }
  }

  val discussionMembersForList =
      remember(allDiscussionMembers, form.participants, discussion.creatorId) {
        val merged = (allDiscussionMembers + form.participants).distinctBy { it.uid }

        val (ownerList, others) = merged.partition { it.uid == discussion.creatorId }

        others + ownerList
      }

  val isPast = isDateTimeInPast(form.date, form.time)
  val canSave = form.title.isNotBlank() && form.date != null && form.time != null && !isPast

  Scaffold(
      modifier = Modifier.testTag(SessionEditTestTags.SCAFFOLD),
      topBar = {
        TopBarWithDivider(
            text = SessionEditStrings.EDIT_SCREEN_TITLE,
            onReturn = { onBack() },
        )
      },
      snackbarHost = {
        SnackbarHost(
            hostState = snackbar, modifier = Modifier.testTag(SessionEditTestTags.SNACKBAR_HOST))
      },
      bottomBar = {
        val shouldHide = UiBehaviorConfig.hideBottomBarWhenInputFocused
        if (!(shouldHide && isInputFocused)) {
          Row(
              modifier =
                  Modifier.fillMaxWidth()
                      .padding(
                          horizontal = Dimensions.Padding.xxxLarge,
                          vertical = Dimensions.Padding.xxLarge)
                      .testTag(SessionEditTestTags.BUTTON_ROW),
              horizontalArrangement = Arrangement.spacedBy(Dimensions.Spacing.extraLarge)) {
                DeleteSessionButton(
                    modifier = Modifier.weight(weight = 1f),
                    onDelete = {
                      val result = runCatching { viewModel.deleteSession(account, discussion) }
                      result.onFailure { e ->
                        showError(e.message ?: SessionEditStrings.FAILING_DELETE_SESSION)
                      }
                      result.onSuccess { onBack() }
                    },
                )

                SaveSessionButton(
                    formToSubmit = form,
                    enabled = canSave,
                    modifier = Modifier.weight(weight = 1f),
                    onSave = { updated ->
                      val result =
                          runCatching {
                                val selectedGameId = gameUi.selectedGameUid
                                val finalGameId =
                                    when {
                                      selectedGameId.isNotBlank() -> selectedGameId
                                      updated.proposedGameString.isNotBlank() ->
                                          updated.proposedGameString
                                      session.gameId.isNotBlank() -> session.gameId
                                      else -> LABEL_UNKNOWN_GAME
                                    }

                                val finalParticipantIds = updated.participants.map { it.uid }

                                viewModel.updateSession(
                                    requester = account,
                                    discussion = discussion,
                                    name = updated.title,
                                    gameId = finalGameId,
                                    date = toTimestamp(updated.date, updated.time),
                                    location = locationUi.selectedLocation ?: session.location,
                                    participants = finalParticipantIds,
                                )
                              }
                              .onFailure { e ->
                                showError(e.message ?: SessionEditStrings.FAILING_UPDATE_SESSION)
                                return@SaveSessionButton
                              }

                      result.onSuccess { onBack() }
                    },
                )
              }
        }
      }) { innerPadding ->
        Column(
            modifier =
                Modifier.fillMaxSize()
                    .background(MaterialTheme.colorScheme.background)
                    .padding(innerPadding)
                    .padding(
                        horizontal = Dimensions.Padding.extraLarge,
                        vertical = Dimensions.Padding.medium)
                    .pointerInput(Unit) { detectTapGestures(onTap = { focusManager.clearFocus() }) }
                    .verticalScroll(rememberScrollState())
                    .testTag(SessionEditTestTags.CONTENT_COLUMN),
            verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.none)) {
              EditOrganisationSection(
                  account = account,
                  discussion = discussion,
                  form = form,
                  gameUi = gameUi,
                  viewModel = viewModel,
                  onFormChange = { form = it },
                  onFocusChanged = { isInputFocused = it },
              )

              Spacer(Modifier.height(Dimensions.Spacing.extraLarge))

              ParticipantSearchBar(
                  query = participantSearchQuery,
                  onQueryChange = { participantSearchQuery = it },
                  onClearQuery = { participantSearchQuery = "" },
                  onFocusChanged = { isInputFocused = it },
                  modifier = Modifier.align(Alignment.CenterHorizontally),
              )

              val currentParticipantIds =
                  remember(form.participants) { form.participants.map { it.uid }.toSet() }

              if (suggestions.isNotEmpty() && trimmedQuery.isNotBlank()) {
                Spacer(Modifier.height(Dimensions.Spacing.small))

                ParticipantSearchDropdown(
                    currentAccount = account,
                    results = suggestions,
                    existingParticipantIds = currentParticipantIds,
                    onAddToSession = { user ->
                      form =
                          form.copy(participants = (form.participants + user).distinctBy { it.uid })
                      allDiscussionMembers = (allDiscussionMembers + user).distinctBy { it.uid }
                    },
                    onClearFocus = {
                      isInputFocused = false
                      focusManager.clearFocus()
                    },
                    modifier = Modifier.align(Alignment.CenterHorizontally),
                )
              }

              Spacer(Modifier.height(Dimensions.Spacing.medium))

              ParticipantsSection(
                  account = account,
                  selected = form.participants,
                  allCandidates = discussionMembersForList,
                  minPlayers = gameUi.fetchedGame?.minPlayers ?: 0,
                  maxPlayers = gameUi.fetchedGame?.maxPlayers ?: 0,
                  onAdd = { toAdd ->
                    form =
                        form.copy(participants = (form.participants + toAdd).distinctBy { it.uid })
                  },
                  onRemove = { toRemove ->
                    if (toRemove.uid != account.uid) {
                      form =
                          form.copy(
                              participants = form.participants.filterNot { it.uid == toRemove.uid })
                    }
                  },
                  mainSectionTitle = SessionEditStrings.LABEL_PARTICIPANTS,
                  modifier = Modifier.testTag(SessionEditTestTags.PARTICIPANTS_SECTION),
              )
            }
      }
}

/* ─────────────────────────────────────────────────────────────────────────────
 *  Components
 * ─────────────────────────────────────────────────────────────────────────────
 */

/**
 * Screen displayed when there is no session to edit.
 *
 * @param onBack Callback invoked to navigate back from the screen.
 */
@Composable
private fun EmptySessionEditScreen(onBack: () -> Unit) {
  Scaffold(
      topBar = {
        TopBarWithDivider(
            text = SessionEditStrings.EDIT_SCREEN_TITLE,
            onReturn = onBack,
        )
      }) { innerPadding ->
        Box(
            modifier =
                Modifier.fillMaxSize()
                    .padding(innerPadding)
                    .background(MaterialTheme.colorScheme.background),
            contentAlignment = Alignment.Center) {
              Text(
                  text = SessionEditStrings.TEXT_NO_SESSION,
                  style = MaterialTheme.typography.bodyMedium,
                  color = MaterialTheme.colorScheme.onBackground)
            }
      }
}

/**
 * Organisation section containing title, game, schedule, and location inputs.
 *
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param form The current session form state.
 * @param gameUi The current game UI state.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditOrganisationSection(
    account: Account,
    discussion: Discussion,
    form: SessionForm,
    gameUi: GameUIState,
    viewModel: SessionEditViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
) {
  SectionCard(
      Modifier.testTag(SessionEditTestTags.ORG_SECTION)
          .fillMaxWidth()
          .background(MaterialTheme.colorScheme.background, MaterialTheme.shapes.large)) {
        EditTitleAndGameSection(
            form = form,
            gameUi = gameUi,
            account = account,
            discussion = discussion,
            viewModel = viewModel,
            onFormChange = onFormChange,
            onFocusChanged = onFocusChanged,
        )

        Spacer(Modifier.height(Dimensions.Spacing.xLarge))

        EditScheduleAndLocationSection(
            form = form,
            account = account,
            discussion = discussion,
            viewModel = viewModel,
            onFormChange = onFormChange,
            onFocusChanged = onFocusChanged,
        )
      }
}

/**
 * Title and game selection section
 *
 * @param form The current session form state.
 * @param gameUi The current game UI state.
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditTitleAndGameSection(
    form: SessionForm,
    gameUi: GameUIState,
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
) {
  Text(
      text = SessionEditStrings.INFO_SECTION_TEXT,
      style = MaterialTheme.typography.titleLarge,
      color = MaterialTheme.colorScheme.onBackground)

  Spacer(Modifier.height(Dimensions.Spacing.small))

  FocusableInputField(
      value = form.title,
      onValueChange = { newTitle ->
        if (newTitle.length <= SessionEditNumbers.MAX_EDIT_TITLE_LENGTH) {
          onFormChange(form.copy(title = newTitle))
        }
      },
      label = { Text(text = SessionEditStrings.TITLE_TEXT) },
      leadingIcon = {
        Icon(
            imageVector = Icons.Default.Edit,
            contentDescription = SessionEditStrings.LABEL_EDIT_TITLE,
            tint = MaterialTheme.colorScheme.onBackground)
      },
      modifier =
          Modifier.fillMaxWidth().testTag(SessionCreationTestTags.FORM_TITLE_FIELD).onFocusChanged {
            onFocusChanged(it.isFocused)
          },
  )

  Spacer(Modifier.height(Dimensions.Spacing.extraMedium))

  Box(Modifier.onFocusChanged { onFocusChanged(it.isFocused) }) {
    SessionGameSearchBar(
        account = account,
        discussion = discussion,
        viewModel = viewModel,
        initial = gameUi.fetchedGame,
    )
  }
}

/**
 * Schedule and location section
 *
 * @param form The current session form state.
 * @param account The current user's account.
 * @param discussion The discussion containing the session.
 * @param viewModel The session view model.
 * @param onFormChange Callback invoked when the form changes.
 * @param onFocusChanged Callback invoked when the focus state changes.
 */
@Composable
private fun EditScheduleAndLocationSection(
    form: SessionForm,
    account: Account,
    discussion: Discussion,
    viewModel: SessionEditViewModel,
    onFormChange: (SessionForm) -> Unit,
    onFocusChanged: (Boolean) -> Unit,
) {
  Text(
      text = SessionEditStrings.SCHEDULE_AND_LOCATION_TEXT,
      style = MaterialTheme.typography.titleLarge,
      color = MaterialTheme.colorScheme.onBackground)

  Spacer(Modifier.height(Dimensions.Spacing.small))

  DateAndTimePicker(
      date = form.date,
      time = form.time,
      onDateChange = { newDate -> onFormChange(form.copy(date = newDate)) },
      onFocusChanged = onFocusChanged,
      onTimeChange = { newTime -> onFormChange(form.copy(time = newTime)) },
  )

  Spacer(Modifier.height(Dimensions.Spacing.extraMedium))

  Box(Modifier.onFocusChanged { onFocusChanged(it.isFocused) }) {
    SessionLocationSearchButton(
        account = account,
        discussion = discussion,
        viewModel = viewModel,
    )
  }
}

/**
 * Search bar for adding participants by global handle search
 *
 * @param query The current search query.
 * @param onQueryChange Callback invoked when the query changes.
 * @param onClearQuery Callback invoked to clear the current query.
 * @param onFocusChanged Callback invoked when the focus state changes.
 * @param modifier Modifier to be applied to the search bar container.
 */
@Composable
private fun ParticipantSearchBar(
    query: String,
    onQueryChange: (String) -> Unit,
    onClearQuery: () -> Unit,
    onFocusChanged: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
) {
  val fieldShape = CircleShape

  FocusableInputField(
      value = query,
      onValueChange = onQueryChange,
      modifier =
          modifier
              .fillMaxWidth(fraction = SessionEditNumbers.SEARCH_ALPHA)
              .height(Dimensions.ContainerSize.timeFieldHeight)
              .border(
                  BorderStroke(
                      width = Dimensions.DividerThickness.standard,
                      color = MaterialTheme.colorScheme.onSurfaceVariant,
                  ),
                  shape = fieldShape,
              )
              .testTag(SessionEditTestTags.PARTICIPANT_SEARCH),
      placeholder = {
        Text(
            text = SessionEditStrings.LABEL_PARTICIPANT_SEARCH,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis,
        )
      },
      singleLine = true,
      leadingIcon = { Spacer(modifier = Modifier.width(Dimensions.Spacing.medium)) },
      trailingIcon = {
        if (query.isNotEmpty()) {
          IconButton(onClick = onClearQuery) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Clear search",
                tint = MaterialTheme.colorScheme.onSurfaceVariant,
            )
          }
        } else {
          Icon(
              imageVector = Icons.Default.Search,
              contentDescription = "Search participants",
              tint = MaterialTheme.colorScheme.onSurfaceVariant,
          )
        }
      },
      textStyle = MaterialTheme.typography.bodyMedium,
      shape = fieldShape,
      colors =
          TextFieldDefaults.colors(
              focusedContainerColor = Color.Transparent,
              unfocusedContainerColor = Color.Transparent,
              disabledContainerColor = Color.Transparent,
              focusedIndicatorColor = Color.Transparent,
              unfocusedIndicatorColor = Color.Transparent,
              disabledIndicatorColor = Color.Transparent,
              cursorColor = MaterialTheme.colorScheme.onSurfaceVariant,
              focusedTextColor = MaterialTheme.colorScheme.onSurfaceVariant,
              unfocusedTextColor = MaterialTheme.colorScheme.onSurfaceVariant,
          ),
      onFocusChanged = onFocusChanged,
  )
}

/**
 * Dropdown list of accounts found by global handle search, allowing adding them to the session.
 *
 * @param currentAccount The account of the current user.
 * @param results The list of accounts matching the search query.
 * @param existingParticipantIds The set of user IDs already in the session.
 * @param onAddToSession Callback invoked when a user is selected to be added to the session.
 * @param onClearFocus Callback invoked to clear input focus (hiding the dropdown).
 * @param modifier Modifier to be applied to the dropdown container.
 */
@Composable
private fun ParticipantSearchDropdown(
    currentAccount: Account,
    results: List<Account>,
    existingParticipantIds: Set<String>,
    onAddToSession: (Account) -> Unit,
    onClearFocus: () -> Unit,
    modifier: Modifier = Modifier,
) {
  val visibleResults =
      remember(results, existingParticipantIds, currentAccount.uid) {
        results.filter { candidate ->
          candidate.uid != currentAccount.uid && candidate.uid !in existingParticipantIds
        }
      }

  if (visibleResults.isEmpty()) return

  Surface(
      modifier =
          modifier
              .fillMaxWidth(fraction = SessionEditNumbers.SEARCH_ALPHA)
              .testTag(SessionEditTestTags.PARTICIPANT_SEARCH_DROPDOWN)
              .clickable { onClearFocus() },
      tonalElevation = Elevation.raised,
      shadowElevation = Elevation.raised,
      shape = MaterialTheme.shapes.medium,
      color = MaterialTheme.colorScheme.outline,
  ) {
    Column(
        modifier = Modifier.fillMaxWidth().padding(vertical = Dimensions.Padding.small),
    ) {
      visibleResults.forEach { user ->
        Row(
            modifier =
                Modifier.fillMaxWidth()
                    .clickable {
                      onAddToSession(user)
                      onClearFocus()
                    }
                    .padding(
                        horizontal = Dimensions.Padding.medium,
                        vertical = Dimensions.Padding.small),
            verticalAlignment = Alignment.CenterVertically,
        ) {
          SessionParticipantAvatar(
              account = user,
              modifier = Modifier.size(Dimensions.AvatarSize.small),
          )

          Spacer(Modifier.width(Dimensions.Spacing.medium))

          Column(Modifier.weight(1f)) {
            Text(
                text = user.name,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface,
            )
            Text(
                text = "@${user.handle}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
            )
          }
        }
      }
    }
  }
}

/**
 * Button that deletes the session and returns to the previous screen
 *
 * @param modifier Modifier to be applied to the dropdown container.
 * @param onDelete Callback invoked when the button is clicked.
 */
@Composable
private fun DeleteSessionButton(
    modifier: Modifier = Modifier,
    onDelete: () -> Unit,
) {
  OutlinedButton(
      onClick = onDelete,
      modifier = modifier.testTag(SessionEditTestTags.DELETE_BUTTON),
      shape = CircleShape,
      border = BorderStroke(Dimensions.DividerThickness.medium, MaterialTheme.colorScheme.error),
      colors =
          ButtonDefaults.outlinedButtonColors(contentColor = MaterialTheme.colorScheme.error)) {
        Icon(
            imageVector = Icons.Default.Delete,
            contentDescription = null,
            modifier = Modifier.testTag(SessionEditTestTags.DELETE_ICON))
        Spacer(Modifier.height(Dimensions.Spacing.none))
        Spacer(Modifier.padding(horizontal = Dimensions.Spacing.medium))
        Text(SessionEditStrings.LABEL_DELETE, style = MaterialTheme.typography.bodyMedium)
      }
}

/**
 * Button that saves the session changes and returns to the previous screen
 *
 * @param formToSubmit The session form data to submit on save.
 * @param onSave Callback invoked with the session form when the button is clicked.
 * @param modifier Modifier to be applied to the dropdown container.
 * @param enabled Whether the button is enabled or disabled.
 */
@Composable
private fun SaveSessionButton(
    formToSubmit: SessionForm,
    onSave: (SessionForm) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
) {
  Button(
      onClick = { onSave(formToSubmit) },
      enabled = enabled,
      modifier = modifier.testTag(SessionEditTestTags.SAVE_BUTTON),
      shape = CircleShape,
      elevation = ButtonDefaults.buttonElevation(defaultElevation = Elevation.raised),
      colors =
          ButtonDefaults.buttonColors(
              containerColor = MaterialTheme.colorScheme.secondary,
              contentColor = MaterialTheme.colorScheme.onBackground)) {
        Icon(
            imageVector = Icons.Default.Check,
            contentDescription = null,
            modifier = Modifier.testTag(SessionEditTestTags.SAVE_ICON))
        Spacer(Modifier.padding(horizontal = Dimensions.Spacing.medium))
        Text(
            SessionEditStrings.LABEL_SAVE,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium)
      }
}
