// Class done almost all manually except some parts inspired from DiscussionScreen.kt
// and others were generated or modified using chatGPT-5 Thinking Extended
// Comments were generated by integrated copilot in Android Studio
package com.github.meeplemeet.ui

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.IntrinsicSize
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.TabRowDefaults.Divider
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Discussion
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.ui.navigation.BottomNavigationMenu
import com.github.meeplemeet.ui.navigation.MeepleMeetScreen
import com.github.meeplemeet.ui.navigation.NavigationActions
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.theme.AppColors
import com.google.firebase.Timestamp
import java.time.Duration
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/* ================================================================
 * Variables
 * ================================================================ */
const val MY_MSG_USERNAME = "You"
const val DEFAULT_DISCUSSION_NAME = "Discussion"
const val NO_MESSAGES_DEFAULT_TEXT = "(No messages yet)"
const val NO_DISCUSSIONS_DEFAULT_TEXT = "No discussions yet"

object DiscussionOverviewTestTags {
  const val ADD_DISCUSSION_BUTTON = "Add Discussion"
}

/* ================================================================
 * Screen: Discussions Overview
 * ================================================================ */

/**
 * Screen that shows an overview of all discussions the user is part of
 *
 * @param viewModel [FirestoreViewModel] instance to interact with Firestore
 * @param account The currently logged-in user ([Account])
 * @param navigation [NavigationActions] instance to navigate to other screens
 * @param onSelectDiscussion Callback function when a discussion is clicked
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscussionsOverviewScreen(
    account: Account,
    navigation: NavigationActions,
    viewModel: FirestoreViewModel = viewModel(),
    onClickAddDiscussion: () -> Unit = {},
    onSelectDiscussion: (Discussion) -> Unit = {},
) {
  val discussionPreviewsSorted =
      remember(account.previews) {
        account.previews.values.sortedByDescending { it.lastMessageAt.toDate() }
      }

  Scaffold(
      floatingActionButton = {
        FloatingActionButton(
            onClick = onClickAddDiscussion,
            contentColor = AppColors.textIcons,
            containerColor = AppColors.neutral,
            modifier = Modifier.testTag(DiscussionOverviewTestTags.ADD_DISCUSSION_BUTTON)) {
              Icon(Icons.Default.Add, contentDescription = "Create")
            }
      },
      topBar = {
        CenterAlignedTopAppBar(
            title = {
              Text(
                  text = MeepleMeetScreen.DiscussionsOverview.title,
                  style = MaterialTheme.typography.bodyMedium,
                  color = MaterialTheme.colorScheme.onPrimary,
                  modifier = Modifier.testTag(NavigationTestTags.SCREEN_TITLE))
            })
      },
      bottomBar = {
        BottomNavigationMenu(
            currentScreen = MeepleMeetScreen.DiscussionsOverview,
            onTabSelected = { screen -> navigation.navigateTo(screen) })
      }) { innerPadding ->
        if (discussionPreviewsSorted.isEmpty()) {
          Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {
            EmptyDiscussionsListText()
          }
        } else {
          LazyColumn(
              modifier =
                  Modifier.fillMaxSize()
                      .background(MaterialTheme.colorScheme.background)
                      .padding(innerPadding),
              verticalArrangement = Arrangement.spacedBy(10.dp),
              contentPadding = PaddingValues(vertical = 12.dp)) {
                items(discussionPreviewsSorted, key = { it.uid }) { preview ->
                  val discussion by viewModel.discussionFlow(preview.uid).collectAsState()
                  val discussionName = discussion?.name ?: DEFAULT_DISCUSSION_NAME

                  val senderId = preview.lastMessageSender
                  val isMe = (senderId == account.uid)
                  val senderName by
                      produceState(
                          key1 = senderId, initialValue = if (isMe) MY_MSG_USERNAME else null) {
                            if (senderId.isNotBlank() && !isMe) {
                              viewModel.getOtherAccount(senderId) { acc -> value = acc.name }
                            }
                          }

                  val msgText = buildString {
                    if (preview.lastMessage.isBlank()) {
                      append(NO_MESSAGES_DEFAULT_TEXT)
                    } else {
                      if (isMe) append("$MY_MSG_USERNAME: ")
                      else if (!senderName.isNullOrBlank()) append("$senderName: ")
                      append(preview.lastMessage)
                    }
                  }

                  DiscussionCard(
                      discussionName = discussionName,
                      lastMsg = msgText,
                      lastMsgDate = preview.lastMessageAt,
                      unreadMsgCount = preview.unreadCount,
                      modifier =
                          Modifier.fillMaxWidth()
                              .testTag(DiscussionTestTags.discussionInfo(discussionName)),
                      onClick = { discussion?.let { onSelectDiscussion(it) } })
                }
              }
        }
      }
}

/* ================================================================
 * Composables
 * ================================================================ */

/** Composable that displays a message when there are no discussions */
@Composable
private fun EmptyDiscussionsListText() {
  Box(
      modifier =
          Modifier.fillMaxSize().padding(24.dp).background(MaterialTheme.colorScheme.background),
      contentAlignment = Alignment.Center) {
        Text(
            text = NO_DISCUSSIONS_DEFAULT_TEXT,
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onPrimary,
        )
      }
}

/**
 * Composable that displays a discussion card
 *
 * @param discussionName Discussion name
 * @param lastMsg Last message text
 * @param unreadMsgCount Number of unseen messages in this discussion
 * @param modifier Optional [Modifier] for this composable
 * @param onClick Function to operate when clicked
 */
@Composable
@Preview(showBackground = true)
private fun DiscussionCard(
    discussionName: String = "Hello",
    lastMsg: String = "Hello world",
    lastMsgDate: Timestamp = Timestamp.now(),
    unreadMsgCount: Int = 1,
    modifier: Modifier = Modifier,
    onClick: () -> Unit = {}
) {
  val rightPaneWidth = 90.dp

  val pfpSize = 48.dp
  val horizontalPadding = 16.dp
  val spacingBetween = 12.dp
  val dividerStart = horizontalPadding + pfpSize + spacingBetween

  Column() {
    Card(
        onClick = onClick,
        modifier = modifier,
        colors = CardDefaults.cardColors(containerColor = Color.Transparent),
        shape = RectangleShape) {
          Box(modifier = Modifier.fillMaxWidth().height(IntrinsicSize.Min)) {
            // LEFT + MIDDLE:
            Row(
                modifier =
                    Modifier.fillMaxWidth()
                        .padding(horizontal = horizontalPadding, vertical = spacingBetween)
                        .padding(end = rightPaneWidth),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(spacingBetween)) {
                  Box(modifier = Modifier.size(pfpSize)) {
                    // Profile picture
                    Box(Modifier.matchParentSize().background(AppColors.neutral, CircleShape))

                    // Unread badge
                    if (unreadMsgCount > 0) {
                      Box(
                          modifier =
                              Modifier.align(Alignment.TopEnd) // âœ… Correct position
                                  .offset(x = (2).dp, y = (-2).dp) // optional fine-tuning
                                  .size(18.dp)
                                  .background(AppColors.focus, CircleShape),
                          contentAlignment = Alignment.Center) {
                            Text(
                                unreadMsgCount.toString(),
                                style = MaterialTheme.typography.labelSmall,
                                color = MaterialTheme.colorScheme.onPrimary)
                          }
                    }
                  }

                  DiscussionCardTextSection(discussionName, lastMsg, Modifier.weight(1f))
                }

            // Discussion time
            RelativeTimestampText(
                lastMsgDate,
                modifier =
                    Modifier.align(Alignment.TopEnd).padding(horizontal = 8.dp, vertical = 4.dp))
          }
        }
    Spacer(modifier = Modifier.height(2.dp))
    Divider(
        modifier = Modifier.padding(start = dividerStart).fillMaxWidth().alpha(0.6f),
        thickness = 1.dp,
        color = AppColors.divider)
  }
}

/**
 * Text section of a discussion card
 *
 * Displays the discussion title text and the last message text
 *
 * @param discussionName Discussion name
 * @param lastMsg Last message text
 * @param modifier Optional [Modifier] for this composable
 */
@Composable
private fun DiscussionCardTextSection(
    discussionName: String,
    lastMsg: String,
    modifier: Modifier = Modifier
) {
  Column(modifier = modifier, verticalArrangement = Arrangement.Center) {
    Text(
        text = discussionName,
        style = MaterialTheme.typography.bodyLarge,
        color = MaterialTheme.colorScheme.onSurface,
        maxLines = 1)
    Spacer(modifier = Modifier.height(4.dp))
    Text(
        text = lastMsg,
        style = MaterialTheme.typography.bodySmall,
        color = MaterialTheme.colorScheme.onSurface,
        maxLines = 1)
  }
}

fun Timestamp.toLocalDateTime(): LocalDateTime =
    LocalDateTime.ofInstant(this.toDate().toInstant(), ZoneId.systemDefault())

fun LocalDateTime.toRelativeTimeString(): String {
  val now = LocalDateTime.now()
  val duration = Duration.between(this, now)

  return when {
    duration.toMinutes() < 1 -> "now"
    duration.toMinutes() < 60 -> "${duration.toMinutes()} min ago"
    duration.toHours() < 24 -> "${duration.toHours()} h ago"
    duration.toDays() < 2 -> "yesterday"
    duration.toDays() < 7 -> this.format(DateTimeFormatter.ofPattern("EEE"))
    else -> this.format(DateTimeFormatter.ofPattern("MMM d"))
  }
}

@Composable
fun RelativeTimestampText(timestamp: Timestamp, modifier: Modifier) {
  val relativeText by
      produceState(initialValue = timestamp.toLocalDateTime().toRelativeTimeString()) {
        while (true) {
          value = timestamp.toLocalDateTime().toRelativeTimeString()
          kotlinx.coroutines.delay(30_000L) // refresh every 30 sec
        }
      }

  Text(
      text = relativeText,
      color = AppColors.textIconsFade,
      style = MaterialTheme.typography.bodySmall,
      modifier = modifier)
}
