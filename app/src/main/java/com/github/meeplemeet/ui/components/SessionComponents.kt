// All components were done by hand primarily (or taken in the internet and adapted).
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Timer
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDefaults
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DisplayMode
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RangeSlider
import androidx.compose.material3.SliderColors
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Popup
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Game
import com.github.meeplemeet.model.structures.Location
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppColors
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale

/** Extra test tags for components (kept separate to avoid breaking other tests). */
object ComponentsTestTags {
  const val UNDERLINED_LABEL = "comp_underlined_label"
  const val LABELED_LABEL = "comp_labeled_label"
  const val COUNT_BUBBLE_TEXT = "comp_count_bubble_text"

  const val PILL_RANGE_SLIDER = "comp_pill_range_slider"

  const val PARTICIPANT_NAME = "comp_participant_name"
  const val PARTICIPANT_ACTION = "comp_participant_action"

  const val DATE_PICKER = "comp_date_picker"
  const val TIME_PICKER = "comp_time_picker"

  const val SEARCH_POPUP_SURFACE = "comp_search_popup_surface"
  const val SEARCH_LOADING = "comp_search_loading"
  const val SEARCH_EMPTY = "comp_search_empty"
  const val SEARCH_LIST = "comp_search_list"
  const val SEARCH_ITEM_PREFIX = "comp_search_item_"
}

/** Action for participant chip: add or remove. */
enum class ParticipantAction {
  Add,
  Remove
}

/* =======================================================================
 * Components
 * ======================================================================= */

/**
 * A card-like section container with padding.
 *
 * @param modifier Modifier to be applied to the Column.
 * @param contentPadding Padding values to be applied inside the Column.
 * @param content Composable content to be placed inside the Column.
 */
@Composable
fun SectionCard(
    modifier: Modifier = Modifier,
    contentPadding: PaddingValues = PaddingValues(16.dp),
    content: @Composable ColumnScope.() -> Unit
) {
  Column(modifier = modifier.padding(contentPadding), content = content)
}

/**
 * A text label with an underline decoration.
 *
 * @param text The text to be displayed in the label.
 * @param textStyle The style to be applied to the text.
 * @param textColor The color of the text.
 */
@Composable
fun UnderlinedLabel(
    text: String,
    textStyle: TextStyle = MaterialTheme.typography.bodyMedium,
    textColor: Color = MaterialTheme.colorScheme.onBackground,
) {
  Text(
      text = text,
      modifier = Modifier.testTag(ComponentsTestTags.UNDERLINED_LABEL),
      style = textStyle,
      color = textColor,
      textDecoration = TextDecoration.Underline,
  )
}

/**
 * A labeled text field with a label above it.
 *
 * @param label The label text to be displayed above the text field.
 * @param value The current value of the text field.
 * @param onValueChange Callback function to be invoked when the text field value changes.
 * @param placeholder Placeholder text to be displayed when the text field is empty.
 * @param singleLine Whether the text field should be single line or multi-line.
 * @param labelTextStyle The style to be applied to the label text.
 * @param labelTextColor The color of the label text.
 * @param modifier Modifier to be applied to the OutlinedTextField.
 * @param outlinedTextStyle The style to be applied to the text inside the OutlinedTextField.
 */
@Composable
fun LabeledTextField(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String = "",
    singleLine: Boolean = false,
    labelTextStyle: TextStyle = MaterialTheme.typography.bodySmall,
    labelTextColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    modifier: Modifier = Modifier,
    outlinedTextStyle: TextStyle = MaterialTheme.typography.bodySmall
) {
  Column {
    Text(
        label,
        style = labelTextStyle,
        color = labelTextColor,
        modifier = Modifier.testTag(ComponentsTestTags.LABELED_LABEL))
    Spacer(Modifier.height(6.dp))
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        singleLine = singleLine,
        placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
        textStyle = outlinedTextStyle,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done))
  }
}

/**
 * A text field with optional leading and trailing icons.
 *
 * @param value The current value of the text field.
 * @param onValueChange Callback function to be invoked when the text field value changes.
 * @param placeholder Placeholder text to be displayed when the text field is empty.
 * @param editable Whether the text field is editable or read-only.
 * @param leadingIcon Optional composable for the leading icon.
 * @param trailingIcon Optional composable for the trailing icon.
 * @param textStyle The style to be applied to the text inside the text field.
 * @param modifier Modifier to be applied to the OutlinedTextField.
 */
@Composable
fun IconTextField(
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String,
    editable: Boolean = true,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    textStyle: TextStyle = MaterialTheme.typography.bodySmall,
    modifier: Modifier
) {
  OutlinedTextField(
      value = value,
      onValueChange = onValueChange,
      modifier = modifier,
      readOnly = !editable,
      leadingIcon = leadingIcon,
      trailingIcon = trailingIcon,
      placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
      textStyle = textStyle)
}

/**
 * A bubble displaying a count number.
 *
 * @param count The count number to be displayed.
 * @param modifier Modifier to be applied to the Box containing the count.
 * @param colorText The color of the count text.
 * @param styleText The style to be applied to the count text.
 */
@Composable
fun CountBubble(
    count: Int,
    modifier: Modifier = Modifier,
    colorText: Color = MaterialTheme.colorScheme.onBackground,
    styleText: TextStyle = MaterialTheme.typography.bodySmall
) {
  Box(modifier = modifier) {
    Text(
        "$count",
        modifier = Modifier.testTag(ComponentsTestTags.COUNT_BUBBLE_TEXT),
        style = styleText,
        color = colorText)
  }
}

/**
 * A discrete pill-shaped range slider.
 *
 * @param range The range of values for the slider.
 * @param values The current selected range values.
 * @param steps The number of discrete steps between the min and max values.
 * @param editable Whether the slider is editable or read-only.
 * @param onValuesChange Callback function to be invoked when the slider values change.
 * @param modifier Modifier to be applied to the surrounding Column.
 * @param sliderModifier Modifier to be applied to the RangeSlider.
 * @param sliderColors Colors to be applied to the RangeSlider.
 */
@Composable
fun DiscretePillSlider(
    range: ClosedFloatingPointRange<Float>,
    values: ClosedFloatingPointRange<Float>,
    steps: Int,
    modifier: Modifier = Modifier,
    editable: Boolean = false,
    onValuesChange: (Float, Float) -> Unit,
    sliderModifier: Modifier = Modifier,
    sliderColors: SliderColors =
        SliderDefaults.colors(
            activeTrackColor = MaterialTheme.colorScheme.tertiary,
            inactiveTrackColor = MaterialTheme.colorScheme.outline,
            thumbColor = MaterialTheme.colorScheme.tertiary)
) {
  Column(modifier = modifier) {
    Box(modifier = sliderModifier) {
      RangeSlider(
          value = values,
          enabled = editable,
          onValueChange = { if (editable) onValuesChange(it.start, it.endInclusive) },
          valueRange = range,
          steps = steps,
          colors = sliderColors,
          modifier = Modifier.testTag(ComponentsTestTags.PILL_RANGE_SLIDER))
    }
  }
}

/**
 * A chip representing a participant with an action button.
 *
 * @param account The account of the participant.
 * @param action The action to be performed (add or remove).
 * @param onClick Callback function to be invoked when the action button is clicked.
 * @param modifier Modifier to be applied to the Box containing the chip.
 * @param textModifier Modifier to be applied to the Text displaying the participant's name.
 * @param textColor The color of the participant's name text.
 */
@Composable
fun ParticipantChip(
    account: Account,
    action: ParticipantAction,
    onClick: (Account) -> Unit,
    modifier: Modifier = Modifier,
    textModifier: Modifier = Modifier,
    textColor: Color = MaterialTheme.colorScheme.onSurface,
) {
  Box(modifier = modifier) {
    Text(
        account.name,
        modifier =
            textModifier
                .align(Alignment.Center)
                .testTag("${ComponentsTestTags.PARTICIPANT_NAME}:${account.name}"),
        style = MaterialTheme.typography.labelSmall,
        color = textColor,
        textAlign = TextAlign.Center,
        maxLines = 1,
        overflow = TextOverflow.Ellipsis)

    Row(
        modifier = Modifier.matchParentSize(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween) {
          Row(verticalAlignment = Alignment.CenterVertically) {
            Box(Modifier.size(18.dp).background(MaterialTheme.colorScheme.tertiary, CircleShape))
            Spacer(Modifier.width(6.dp))
          }

          val (icon, tint) =
              when (action) {
                ParticipantAction.Add -> Icons.Default.Add to MaterialTheme.colorScheme.primary
                ParticipantAction.Remove -> Icons.Default.Close to MaterialTheme.colorScheme.error
              }
          IconButton(
              onClick = { onClick(account) },
              modifier =
                  Modifier.size(20.dp)
                      .testTag(
                          "${ComponentsTestTags.PARTICIPANT_ACTION}:${action.name}:${account.name}"),
              colors = IconButtonDefaults.iconButtonColors(contentColor = tint)) {
                Icon(icon, contentDescription = null)
              }
        }
  }
}

/**
 * A grid layout that arranges items in two columns per row.
 *
 * @param items The list of items to be displayed in the grid.
 * @param key A function to generate a unique key for each item.
 * @param modifier Modifier to be applied to the Column containing the grid.
 * @param rowsModifier Modifier to be applied to each Row in the grid.
 * @param content Composable content to be displayed for each item, with a modifier for layout.
 */
@Composable
fun <T> TwoPerRowGrid(
    items: List<T>,
    key: (T) -> Any,
    modifier: Modifier = Modifier,
    rowsModifier: Modifier = Modifier,
    content: @Composable (item: T, modifier: Modifier) -> Unit,
) {
  val rows = remember(items) { items.chunked(2) }
  Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(10.dp)) {
    rows.forEach { row ->
      Row(horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = rowsModifier) {
        row.forEach { item -> content(item, rowsModifier.weight(1f, fill = true)) }
        if (row.size == 1) Spacer(rowsModifier.weight(1f, fill = true))
      }
    }
  }
}

/**
 * A date picker field that shows a date picker dialog when the "Pick" button is clicked.
 *
 * @param value The currently selected date.
 * @param onValueChange Callback function to be invoked when a new date is selected.
 * @param label The label text for the date field.
 * @param editable Whether the date field is editable or read-only.
 * @param displayFormatter The formatter to display the selected date.
 * @param zoneId The time zone to be used for date selection.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DatePickerDockedField(
    value: LocalDate?,
    onValueChange: (LocalDate?) -> Unit,
    label: String = "Date",
    editable: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  var showDialogDate by remember { mutableStateOf(false) }
  val text = value?.format(displayFormatter) ?: ""

  IconTextField(
      value = text,
      onValueChange = {},
      placeholder = label,
      leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "Date") },
      trailingIcon = {
        if (editable) {
          TextButton(
              onClick = { showDialogDate = true },
              modifier = Modifier.testTag(SessionTestTags.DATE_PICK_BUTTON)) {
                Text("Pick")
              }
        }
      },
      modifier = Modifier.fillMaxWidth().testTag(SessionTestTags.DATE_FIELD))

  if (showDialogDate) {
    AppDatePickerDialog(
        zoneId = zoneId,
        onDismiss = { showDialogDate = false },
        onDateSelected = { selectedDate -> onValueChange(selectedDate) })
  }
}

/**
 * A date picker dialog that allows the user to select a date.
 *
 * @param onDismiss Callback function to be invoked when the dialog is dismissed.
 * @param onDateSelected Callback function to be invoked when a date is selected.
 * @param zoneId The time zone to be used for date selection.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppDatePickerDialog(
    onDismiss: () -> Unit,
    onDateSelected: (LocalDate) -> Unit,
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  val state = rememberDatePickerState(initialDisplayMode = DisplayMode.Picker)

  DatePickerDialog(
      onDismissRequest = onDismiss,
      confirmButton = {
        TextButton(
            modifier = Modifier.testTag(SessionTestTags.DATE_PICKER_OK_BUTTON),
            onClick = {
              state.selectedDateMillis?.let { ms ->
                onDateSelected(Instant.ofEpochMilli(ms).atZone(zoneId).toLocalDate())
              }
              onDismiss()
            }) {
              Text("OK")
            }
      },
      dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
  ) {
    DatePicker(
        state = state,
        modifier = Modifier.testTag(ComponentsTestTags.DATE_PICKER),
        colors =
            DatePickerDefaults.colors(
                containerColor = AppColors.primary,
                titleContentColor = AppColors.textIconsFade,
                headlineContentColor = AppColors.textIcons,
                selectedDayContentColor = AppColors.primary,
                selectedDayContainerColor = AppColors.neutral))
  }
}

/**
 * A time picker field that shows a time picker dialog when the "Pick" button is clicked.
 *
 * @param value The currently selected time.
 * @param onValueChange Callback function to be invoked when a new time is selected.
 * @param label The label text for the time field.
 * @param is24Hour Whether to use 24-hour format or 12-hour format.
 * @param displayFormatter The formatter to display the selected time.
 */
@Composable
fun TimePickerField(
    value: LocalTime?,
    onValueChange: (LocalTime?) -> Unit,
    label: String = "Time",
    is24Hour: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm")
) {
  var open by remember { mutableStateOf(false) }
  val state =
      rememberTimePickerState(
          is24Hour = is24Hour, initialHour = value?.hour ?: 19, initialMinute = value?.minute ?: 0)
  val text = value?.format(displayFormatter) ?: ""

  OutlinedTextField(
      value = text,
      onValueChange = { /* read-only; picker controls it */},
      label = { Text(label) },
      readOnly = true,
      leadingIcon = { Icon(Icons.Default.Timer, contentDescription = "Select time") },
      trailingIcon = {
        TextButton(
            onClick = { open = true },
            modifier = Modifier.testTag(SessionTestTags.TIME_PICK_BUTTON)) {
              Text("Pick")
            }
      },
      modifier = Modifier.fillMaxWidth().height(64.dp).testTag(SessionTestTags.TIME_FIELD))

  if (open) {
    AlertDialog(
        onDismissRequest = { open = false },
        confirmButton = {
          TextButton(
              modifier = Modifier.testTag(SessionTestTags.TIME_PICKER_OK_BUTTON),
              onClick = {
                onValueChange(LocalTime.of(state.hour, state.minute))
                open = false
              }) {
                Text("OK")
              }
        },
        dismissButton = { TextButton(onClick = { open = false }) { Text("Cancel") } },
        text = {
          TimePicker(state = state, modifier = Modifier.testTag(ComponentsTestTags.TIME_PICKER))
        })
  }
}

/**
 * A search dropdown field that shows suggestions based on the query input.
 *
 * @param label The label text for the search field.
 * @param query The current query string.
 * @param onQueryChange Callback function to be invoked when the query changes.
 * @param suggestions The list of suggestions to be displayed.
 * @param onSuggestionClick Callback function to be invoked when a suggestion is clicked.
 * @param getPrimaryText Function to extract the primary text from a suggestion item.
 * @param modifier Modifier to be applied to the Box containing the search field.
 * @param modifierTxtField Modifier to be applied to the OutlinedTextField.
 * @param placeholder Placeholder text to be displayed in the text field.
 * @param isLoading Whether the search is currently loading results.
 * @param showWhenEmptyQuery Whether to show suggestions when the query is empty.
 * @param itemContent Optional composable content for each suggestion item.
 * @param emptyText Text to display when there are no suggestions.
 */
@Composable
fun <T> SearchDropdownField(
    label: String,
    query: String,
    onQueryChange: (String) -> Unit,
    suggestions: List<T>,
    onSuggestionClick: (T) -> Unit,
    getPrimaryText: (T) -> String,
    modifier: Modifier = Modifier,
    modifierTxtField: Modifier = Modifier,
    placeholder: String = "",
    isLoading: Boolean = false,
    showWhenEmptyQuery: Boolean = false,
    itemContent: (@Composable (item: T) -> Unit)? = null,
    emptyText: String = "No results"
) {
  var expanded by remember { mutableStateOf(false) }
  var internalQuery by remember { mutableStateOf(query) }

  // Sync internalQuery with query parameter when it changes externally
  LaunchedEffect(query) { internalQuery = query }

  Box(modifier = modifier) {
    OutlinedTextField(
        value = internalQuery,
        onValueChange = {
          internalQuery = it
          onQueryChange(it)
          expanded = (showWhenEmptyQuery || it.isNotBlank())
        },
        label = { Text(label) },
        leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
        trailingIcon = {
          when {
            isLoading -> CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
            internalQuery.isNotEmpty() ->
                IconButton(
                    onClick = {
                      internalQuery = ""
                      onQueryChange("")
                      expanded = false
                    }) {
                      Icon(Icons.Default.Close, contentDescription = "Clear")
                    }
          }
        },
        placeholder = { if (placeholder.isNotEmpty()) Text(placeholder) },
        singleLine = true,
        modifier = Modifier.fillMaxWidth().height(64.dp).then(modifierTxtField))

    val shouldShow = expanded && (isLoading || suggestions.isNotEmpty())

    if (shouldShow) {
      Popup(onDismissRequest = { expanded = false }, alignment = Alignment.TopStart) {
        Column(Modifier.fillMaxWidth().offset(y = 64.dp)) {
          Surface(
              modifier = Modifier.fillMaxWidth().testTag(ComponentsTestTags.SEARCH_POPUP_SURFACE),
              shape = RoundedCornerShape(12.dp),
              tonalElevation = 4.dp,
              shadowElevation = 4.dp) {
                when {
                  isLoading -> {
                    Row(
                        Modifier.fillMaxWidth()
                            .padding(16.dp)
                            .testTag(ComponentsTestTags.SEARCH_LOADING),
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        verticalAlignment = Alignment.CenterVertically) {
                          CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
                          Text("Searching…", style = MaterialTheme.typography.bodyMedium)
                        }
                  }
                  suggestions.isEmpty() -> {
                    Text(
                        emptyText,
                        modifier =
                            Modifier.fillMaxWidth()
                                .padding(16.dp)
                                .testTag(ComponentsTestTags.SEARCH_EMPTY),
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant)
                  }
                  else -> {
                    LazyColumn(
                        modifier =
                            Modifier.fillMaxWidth()
                                .heightIn(max = 200.dp)
                                .testTag(ComponentsTestTags.SEARCH_LIST),
                        contentPadding = PaddingValues(vertical = 6.dp)) {
                          items(suggestions) { item ->
                            val raw = getPrimaryText(item)
                            val norm =
                                raw.lowercase(Locale.getDefault())
                                    .replace(Regex("[^a-z0-9]+"), "_")
                                    .trim('_')

                            Row(
                                modifier =
                                    Modifier.fillMaxWidth()
                                        .clickable {
                                          onSuggestionClick(item)
                                          expanded = false
                                        }
                                        .padding(horizontal = 12.dp, vertical = 10.dp)
                                        .testTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}$norm"),
                                verticalAlignment = Alignment.CenterVertically) {
                                  if (itemContent != null) {
                                    itemContent(item)
                                  } else {
                                    Text(
                                        text = raw,
                                        style = MaterialTheme.typography.bodyMedium,
                                        maxLines = 1,
                                        overflow = TextOverflow.Ellipsis)
                                  }
                                }
                          }
                        }
                  }
                }
              }
        }
      }
    }
  }
}

/**
 * A search field specifically for searching games.
 *
 * @param query The current query string.
 * @param onQueryChange Callback function to be invoked when the query changes.
 * @param results The list of game results to be displayed.
 * @param onPick Callback function to be invoked when a game is picked.
 * @param modifier Modifier to be applied to the Box containing the search field.
 * @param isLoading Whether the search is currently loading results.
 * @param placeholder Placeholder text to be displayed in the text field.
 */
@Composable
fun GameSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Game>,
    onPick: (Game) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search games…"
) {
  SearchDropdownField(
      label = "Game",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      modifierTxtField = Modifier.testTag(SessionTestTags.PROPOSED_GAME),
      getPrimaryText = { it.name },
      isLoading = isLoading,
      placeholder = placeholder,
      modifier = modifier)
}

/**
 * A search field specifically for searching locations.
 *
 * @param query The current query string.
 * @param onQueryChange Callback function to be invoked when the query changes.
 * @param results The list of location results to be displayed.
 * @param onPick Callback function to be invoked when a location is picked.
 * @param modifier Modifier to be applied to the Box containing the search field.
 * @param isLoading Whether the search is currently loading results.
 * @param placeholder Placeholder text to be displayed in the text field.
 */
@Composable
fun LocationSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Location>,
    onPick: (Location) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search locations…"
) {
  SearchDropdownField(
      label = "Location",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      getPrimaryText = { it.name },
      isLoading = isLoading,
      modifierTxtField = Modifier.testTag(SessionTestTags.LOCATION_FIELD),
      placeholder = placeholder,
      modifier = modifier,
      itemContent = { loc ->
        Column(Modifier.fillMaxWidth()) {
          Text(
              text = loc.name,
              style = MaterialTheme.typography.bodyMedium,
              maxLines = 1,
              overflow = TextOverflow.Ellipsis)
          Text(
              text = "${"%.5f".format(loc.latitude)}, ${"%.5f".format(loc.longitude)}",
              style = MaterialTheme.typography.labelSmall,
              color = MaterialTheme.colorScheme.onSurfaceVariant)
        }
      })
}
