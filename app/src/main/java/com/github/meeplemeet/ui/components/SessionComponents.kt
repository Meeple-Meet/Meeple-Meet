// All components were done by hand primarily (or taken in the internet and adapted).
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.wrapContentHeight
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Timer
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDefaults
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DisplayMode
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.MenuAnchorType
import androidx.compose.material3.RangeSlider
import androidx.compose.material3.SelectableDates
import androidx.compose.material3.SliderColors
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TimeInput
import androidx.compose.material3.TimePickerDefaults
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.onFocusChanged
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.window.Dialog
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.sessions.CreateSessionViewModel
import com.github.meeplemeet.model.shared.SearchViewModel
import com.github.meeplemeet.model.shared.game.Game
import com.github.meeplemeet.model.shared.location.Location
import com.github.meeplemeet.model.shops.Shop
import com.github.meeplemeet.model.shops.ShopSearchViewModel
import com.github.meeplemeet.model.space_renter.SpaceRenter
import com.github.meeplemeet.model.space_renter.SpaceRenterSearchViewModel
import com.github.meeplemeet.ui.FocusableInputField
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.sessions.SessionTestTags
import com.github.meeplemeet.ui.sessions.SessionTestTags.LOCATION_PICKER_BUTTON
import com.github.meeplemeet.ui.sessions.SessionTestTags.LOCATION_PICKER_DIALOG
import com.github.meeplemeet.ui.sessions.isDateTimeInPast
import com.github.meeplemeet.ui.theme.AppColors
import com.github.meeplemeet.ui.theme.Dimensions
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/** Extra test tags for components (kept separate to avoid breaking other tests). */
object ComponentsTestTags {
  const val UNDERLINED_LABEL = "comp_underlined_label"
  const val LABELED_LABEL = "comp_labeled_label"
  const val COUNT_BUBBLE_TEXT = "comp_count_bubble_text"

  const val TOP_APP_BAR = "comp_top_app_bar"

  const val PILL_RANGE_SLIDER = "comp_pill_range_slider"

  const val PARTICIPANT_NAME = "comp_participant_name"
  const val PARTICIPANT_ACTION = "comp_participant_action"

  const val DATE_PICKER = "comp_date_picker"
  const val TIME_PICKER = "comp_time_picker"

  const val SESSION_GAME_SEARCH_INPUT = "comp_session_game_search_input"
  const val SESSION_GAME_SEARCH_ITEM = "comp_session_game_search_item"
  const val SESSION_LOCATION_SEARCH_INPUT = "comp_session_location_search_input"
  const val SESSION_LOCATION_SEARCH_ITEM = "comp_session_location_search_item"

  fun participantName(name: String) = "$PARTICIPANT_NAME:$name"
}
/** Common labels, placeholders, and button texts used across components. */
private const val LABEL_DATE = "Date"
private const val LABEL_TIME = "Time"
private const val TEXT_SELECT_LOCATION = "Select a location"
private const val LABEL_LOCATION = "Location"
private const val PLACEHOLDER_LOCATION = "Enter an address"
private const val PLACEHOLDER_SEARCH_GAMES = "Search games"
private const val PLACEHOLDER_SEARCH = "Search"
private const val BUTTON_PICK = "Pick"
private const val BUTTON_OK = "OK"
private const val BUTTON_CANCEL = "Cancel"
private const val TITLE_SELECT_TIME = "Select Time"
private const val LABEL_GAME = "Game"
private const val OUTLINE_DEFAULT_ALPHA = 0.5f

/** Action for participant chip: add or remove. */
enum class ParticipantAction {
  Add,
  Remove
}

/* =======================================================================
 * Components
 * ======================================================================= */

/**
 * A card-like section container with padding.
 *
 * @param modifier Modifier to be applied to the Column.
 * @param contentPadding Padding values to be applied inside the Column.
 * @param content Composable content to be placed inside the Column.
 */
@Composable
fun SectionCard(
    modifier: Modifier = Modifier,
    contentPadding: PaddingValues = PaddingValues(Dimensions.Padding.extraLarge),
    content: @Composable ColumnScope.() -> Unit
) {
  Column(modifier = modifier.padding(contentPadding), content = content)
}

/**
 * A text label with an underline decoration.
 *
 * @param text The text to be displayed in the label.
 * @param textStyle The style to be applied to the text.
 * @param textColor The color of the text.
 */
@Composable
fun UnderlinedLabel(
    text: String,
    textStyle: TextStyle = MaterialTheme.typography.bodyMedium,
    textColor: Color = MaterialTheme.colorScheme.onBackground,
) {
  Text(
      text = text,
      modifier = Modifier.testTag(ComponentsTestTags.UNDERLINED_LABEL),
      style = textStyle,
      color = textColor,
      textDecoration = TextDecoration.Underline,
  )
}

/**
 * A labeled text field with a label above it.
 *
 * @param label The label text to be displayed above the text field.
 * @param value The current value of the text field.
 * @param onValueChange Callback function to be invoked when the text field value changes.
 * @param placeholder Placeholder text to be displayed when the text field is empty.
 * @param singleLine Whether the text field should be single line or multi-line.
 * @param labelTextStyle The style to be applied to the label text.
 * @param labelTextColor The color of the label text.
 * @param modifier Modifier to be applied to the OutlinedTextField.
 * @param outlinedTextStyle The style to be applied to the text inside the OutlinedTextField.
 */
@Composable
fun LabeledTextField(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String = "",
    singleLine: Boolean = false,
    labelTextStyle: TextStyle = MaterialTheme.typography.bodySmall,
    labelTextColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    modifier: Modifier = Modifier,
    outlinedTextStyle: TextStyle = MaterialTheme.typography.bodySmall
) {
  Column {
    Text(
        label,
        style = labelTextStyle,
        color = labelTextColor,
        modifier = Modifier.testTag(ComponentsTestTags.LABELED_LABEL))
    Spacer(Modifier.height(Dimensions.Padding.mediumSmall))
    FocusableInputField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        singleLine = singleLine,
        placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
        textStyle = outlinedTextStyle,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done))
  }
}

/**
 * A text field with optional leading and trailing icons.
 *
 * @param value The current value of the text field.
 * @param onValueChange Callback function to be invoked when the text field value changes.
 * @param placeholder Placeholder text to be displayed when the text field is empty.
 * @param editable Whether the text field is editable or read-only.
 * @param leadingIcon Optional composable for the leading icon.
 * @param trailingIcon Optional composable for the trailing icon.
 * @param textStyle The style to be applied to the text inside the text field.
 * @param modifier Modifier to be applied to the OutlinedTextField.
 */
@Composable
fun IconTextField(
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String,
    editable: Boolean = true,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    textStyle: TextStyle = MaterialTheme.typography.bodySmall,
    modifier: Modifier
) {
  FocusableInputField(
      value = value,
      onValueChange = { if (editable) onValueChange(it) },
      modifier = modifier,
      enabled = editable,
      readOnly = !editable,
      leadingIcon = leadingIcon,
      trailingIcon = trailingIcon,
      label = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
      textStyle = textStyle,
      colors =
          TextFieldDefaults.colors(
              // text
              focusedTextColor = MaterialTheme.colorScheme.onBackground,
              unfocusedTextColor = MaterialTheme.colorScheme.onBackground,
              disabledTextColor = MaterialTheme.colorScheme.onBackground,

              // icons
              focusedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              unfocusedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              disabledLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              focusedTrailingIconColor = MaterialTheme.colorScheme.onBackground,
              unfocusedTrailingIconColor = MaterialTheme.colorScheme.onBackground,
              disabledTrailingIconColor = MaterialTheme.colorScheme.onBackground,

              // indicator
              focusedIndicatorColor = MaterialTheme.colorScheme.onBackground,
              unfocusedIndicatorColor = MaterialTheme.colorScheme.onSurfaceVariant,
              disabledIndicatorColor =
                  MaterialTheme.colorScheme.onBackground.copy(alpha = OUTLINE_DEFAULT_ALPHA),

              // background
              focusedContainerColor = Color.Transparent,
              unfocusedContainerColor = Color.Transparent,
              disabledContainerColor = Color.Transparent,

              // cursor
              cursorColor = MaterialTheme.colorScheme.onBackground,
          ),
  )
}

/**
 * A text field with optional leading and trailing icons.
 *
 * @param value The current value of the text field.
 * @param onValueChange Callback function to be invoked when the text field value changes.
 * @param placeholder Placeholder text to be displayed when the text field is empty.
 * @param editable Whether the text field is editable or read-only.
 * @param leadingIcon Optional composable for the leading icon.
 * @param trailingIcon Optional composable for the trailing icon.
 * @param textStyle The style to be applied to the text inside the text field.
 * @param modifier Modifier to be applied to the OutlinedTextField.
 */
@Composable
fun IconTextFieldNew(
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String,
    editable: Boolean = true,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    modifier: Modifier
) {
  TextField(
      value = value,
      onValueChange = { if (editable) onValueChange(it) },
      modifier = modifier,
      enabled = false,
      readOnly = !editable,
      singleLine = true,
      textStyle = TextStyle(fontSize = Dimensions.TextSize.body),
      shape = RoundedCornerShape(Dimensions.CornerRadius.medium),
      leadingIcon = leadingIcon,
      trailingIcon = trailingIcon,
      placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
      colors =
          TextFieldDefaults.colors(
              // text
              focusedTextColor = MaterialTheme.colorScheme.onBackground,
              unfocusedTextColor = MaterialTheme.colorScheme.onBackground,
              disabledTextColor = MaterialTheme.colorScheme.onBackground,

              // icons
              focusedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              unfocusedLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              disabledLeadingIconColor = MaterialTheme.colorScheme.onBackground,
              focusedTrailingIconColor = MaterialTheme.colorScheme.onBackground,
              unfocusedTrailingIconColor = MaterialTheme.colorScheme.onBackground,
              disabledTrailingIconColor = MaterialTheme.colorScheme.onBackground,

              // indicator
              focusedIndicatorColor = Color.Transparent,
              unfocusedIndicatorColor = Color.Transparent,
              disabledIndicatorColor = Color.Transparent,

              // background
              focusedContainerColor = Color.Transparent,
              unfocusedContainerColor = Color.Transparent,
              disabledContainerColor = Color.Transparent,

              // cursor
              cursorColor = MaterialTheme.colorScheme.onBackground,
          ),
  )
}

/**
 * A bubble displaying a count number.
 *
 * @param count The count number to be displayed.
 * @param modifier Modifier to be applied to the Box containing the count.
 * @param colorText The color of the count text.
 * @param styleText The style to be applied to the count text.
 */
@Composable
fun CountBubble(
    count: Int,
    modifier: Modifier = Modifier,
    colorText: Color = MaterialTheme.colorScheme.onBackground,
    styleText: TextStyle = MaterialTheme.typography.bodySmall
) {
  Box(modifier = modifier) {
    Text(
        "$count",
        modifier = Modifier.testTag(ComponentsTestTags.COUNT_BUBBLE_TEXT),
        style = styleText,
        color = colorText)
  }
}

/**
 * A discrete pill-shaped range slider.
 *
 * @param range The range of values for the slider.
 * @param values The current selected range values.
 * @param steps The number of discrete steps between the min and max values.
 * @param modifier Modifier to be applied to the surrounding Column.
 * @param sliderModifier Modifier to be applied to the RangeSlider.
 * @param sliderColors Colors to be applied to the RangeSlider.
 */
@Composable
fun DiscretePillSlider(
    range: ClosedFloatingPointRange<Float>,
    values: ClosedFloatingPointRange<Float>,
    steps: Int,
    modifier: Modifier = Modifier,
    sliderModifier: Modifier = Modifier,
    sliderColors: SliderColors =
        SliderDefaults.colors(
            activeTrackColor = MaterialTheme.colorScheme.tertiary,
            inactiveTrackColor = MaterialTheme.colorScheme.outline,
            thumbColor = MaterialTheme.colorScheme.tertiary)
) {
  Column(modifier = modifier) {
    Box(modifier = sliderModifier) {
      RangeSlider(
          value = values,
          enabled = true,
          onValueChange = {},
          valueRange = range,
          steps = steps,
          colors = sliderColors,
          modifier = Modifier.testTag(ComponentsTestTags.PILL_RANGE_SLIDER))
    }
  }
}

/**
 * Displays a top app bar with a title and a back button.
 *
 * @param text The title text to display in the top bar.
 * @param onReturn Callback invoked when the back button is pressed.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun TopBarWithDivider(
    text: String,
    onReturn: () -> Unit = {},
    trailingIcons: @Composable () -> Unit = {}
) {
  /** --- Top App Bar --- */
  Column {
    CenterAlignedTopAppBar(
        modifier = Modifier.testTag(ComponentsTestTags.TOP_APP_BAR).background(AppColors.primary),
        navigationIcon = {
          IconButton(
              onClick = { onReturn() },
              modifier = Modifier.testTag(NavigationTestTags.GO_BACK_BUTTON)) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                    contentDescription = "Back",
                    tint = AppColors.textIcons)
              }
        },
        title = {
          Text(
              text = text,
              modifier = Modifier.testTag(NavigationTestTags.SCREEN_TITLE),
              style = MaterialTheme.typography.bodyMedium,
              color = AppColors.textIcons)
        },
        actions = { /* Add trailing icons here if needed */
          trailingIcons()
        },
        colors = TopAppBarDefaults.centerAlignedTopAppBarColors(containerColor = AppColors.primary))
    /** --- Divider --- */
    HorizontalDivider(
        modifier =
            Modifier.fillMaxWidth(Dimensions.Fractions.topBarDivider)
                .padding(horizontal = Dimensions.Spacing.none)
                .align(Alignment.CenterHorizontally),
        thickness = Dimensions.DividerThickness.standard,
        color = AppColors.textIconsFade)
  }
}

/**
 * A chip representing a participant with an action button.
 *
 * @param account The account of the participant.
 * @param action The action to be performed (add or remove).
 * @param onClick Callback function to be invoked when the action button is clicked.
 * @param modifier Modifier to be applied to the Box containing the chip.
 * @param textModifier Modifier to be applied to the Text displaying the participant's name.
 * @param textColor The color of the participant's name text.
 */
@Composable
fun ParticipantChip(
    account: Account,
    action: ParticipantAction,
    onClick: (Account) -> Unit,
    modifier: Modifier = Modifier,
    textModifier: Modifier = Modifier,
    textColor: Color = MaterialTheme.colorScheme.onSurface,
) {
  Box(modifier = modifier) {
    Text(
        account.name,
        modifier =
            textModifier
                .align(Alignment.Center)
                .testTag(ComponentsTestTags.participantName(account.name)),
        style = MaterialTheme.typography.labelSmall,
        color = textColor,
        textAlign = TextAlign.Center,
        maxLines = 1,
        overflow = TextOverflow.Ellipsis)

    Row(
        modifier = Modifier.matchParentSize(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween) {
          Row(verticalAlignment = Alignment.CenterVertically) {
            Box(
                Modifier.size(Dimensions.IconSize.medium)
                    .background(MaterialTheme.colorScheme.tertiary, CircleShape))
            Spacer(Modifier.width(Dimensions.Padding.mediumSmall))
          }

          val (icon, tint) =
              when (action) {
                ParticipantAction.Add -> Icons.Default.Add to MaterialTheme.colorScheme.primary
                ParticipantAction.Remove -> Icons.Default.Close to MaterialTheme.colorScheme.error
              }
          IconButton(
              onClick = { onClick(account) },
              modifier =
                  Modifier.size(Dimensions.IconSize.standard)
                      .testTag(
                          "${ComponentsTestTags.PARTICIPANT_ACTION}:${action.name}:${account.name}"),
              colors = IconButtonDefaults.iconButtonColors(contentColor = tint)) {
                Icon(icon, contentDescription = null)
              }
        }
  }
}

/**
 * A grid layout that arranges items in two columns per row.
 *
 * @param items The list of items to be displayed in the grid.
 * @param modifier Modifier to be applied to the Column containing the grid.
 * @param rowsModifier Modifier to be applied to each Row in the grid.
 * @param content Composable content to be displayed for each item, with a modifier for layout.
 */
@Composable
fun <T> TwoPerRowGrid(
    items: List<T>,
    modifier: Modifier = Modifier,
    rowsModifier: Modifier = Modifier,
    content: @Composable (item: T, modifier: Modifier) -> Unit,
) {
  val rows = remember(items) { items.chunked(2) }
  Column(
      modifier = modifier, verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.large)) {
        rows.forEach { row ->
          Row(
              horizontalArrangement = Arrangement.spacedBy(Dimensions.Spacing.large),
              modifier = rowsModifier) {
                row.forEach { item -> content(item, rowsModifier.weight(1f, fill = true)) }
                if (row.size == 1) Spacer(rowsModifier.weight(1f, fill = true))
              }
        }
      }
}

/**
 * A date picker field that shows a date picker dialog when the "Pick" button is clicked.
 *
 * @param value The currently selected date.
 * @param onValueChange Callback function to be invoked when a new date is selected.
 * @param label The label text for the date field.
 * @param editable Whether the date field is editable or read-only.
 * @param displayFormatter The formatter to display the selected date.
 * @param zoneId The time zone to be used for date selection.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DatePickerDockedField(
    value: LocalDate?,
    onValueChange: (LocalDate?) -> Unit,
    label: String = LABEL_DATE,
    editable: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    zoneId: ZoneId = ZoneId.systemDefault(),
    testTagPick: String = SessionTestTags.DATE_PICK_BUTTON,
    testTagDate: String = SessionTestTags.DATE_FIELD
) {
  var showDialogDate by remember { mutableStateOf(false) }
  val text = value?.format(displayFormatter) ?: LABEL_DATE

  Box(modifier = Modifier.testTag(testTagDate)) {
    IconTextFieldNew(
        value = text,
        onValueChange = {},
        placeholder = label,
        editable = editable,
        leadingIcon = {
          Icon(
              Icons.Default.CalendarToday,
              contentDescription = LABEL_DATE,
              tint = AppColors.neutral)
        },
        trailingIcon = {
          Icon(
              Icons.Default.ChevronRight, contentDescription = null, tint = AppColors.textIconsFade)
        },
        modifier = Modifier.fillMaxWidth().clickable { showDialogDate = true }.testTag(testTagPick))
  }

  if (showDialogDate) {
    AppDatePickerDialog(
        zoneId = zoneId,
        onDismiss = { showDialogDate = false },
        onDateSelected = { selectedDate -> onValueChange(selectedDate) })
  }
}

/**
 * A date picker dialog that allows the user to select a date.
 *
 * @param onDismiss Callback function to be invoked when the dialog is dismissed.
 * @param onDateSelected Callback function to be invoked when a date is selected.
 * @param zoneId The time zone to be used for date selection.
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppDatePickerDialog(
    onDismiss: () -> Unit,
    onDateSelected: (LocalDate) -> Unit,
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  // Create a SelectableDates object that only allows dates from today onwards
  val selectableDates = remember {
    object : SelectableDates {
      override fun isSelectableDate(utcTimeMillis: Long): Boolean {
        val selectedDate =
            Instant.ofEpochMilli(utcTimeMillis).atZone(ZoneId.of("UTC")).toLocalDate()
        val today = LocalDate.now(zoneId)
        return !selectedDate.isBefore(today)
      }
    }
  }

  val state =
      rememberDatePickerState(
          initialDisplayMode = DisplayMode.Picker, selectableDates = selectableDates)

  DatePickerDialog(
      onDismissRequest = onDismiss,
      colors =
          DatePickerDefaults.colors(
              todayContentColor = AppColors.textIcons,
              todayDateBorderColor = AppColors.neutral,
              containerColor = AppColors.primary,
              titleContentColor = AppColors.textIconsFade,
              headlineContentColor = AppColors.textIcons,
              selectedDayContentColor = AppColors.primary,
              selectedDayContainerColor = AppColors.neutral),
      confirmButton = {
        TextButton(
            modifier = Modifier.testTag(SessionTestTags.DATE_PICKER_OK_BUTTON),
            onClick = {
              state.selectedDateMillis?.let { ms ->
                onDateSelected(Instant.ofEpochMilli(ms).atZone(zoneId).toLocalDate())
              }
              onDismiss()
            }) {
              Text(BUTTON_OK)
            }
      },
      dismissButton = {
        TextButton(onClick = onDismiss, modifier = Modifier.testTag("date-picker-cancel")) {
          Text(BUTTON_CANCEL)
        }
      },
  ) {
    DatePicker(
        state = state,
        modifier = Modifier.testTag(ComponentsTestTags.DATE_PICKER),
        colors =
            DatePickerDefaults.colors(
                todayContentColor = AppColors.textIcons,
                todayDateBorderColor = AppColors.neutral,
                containerColor = AppColors.primary,
                titleContentColor = AppColors.textIconsFade,
                headlineContentColor = AppColors.textIcons,
                selectedDayContentColor = AppColors.primary,
                selectedDayContainerColor = AppColors.neutral))
  }
}

/**
 * A time picker field that shows a time picker dialog when the "Pick" button is clicked.
 *
 * @param value The currently selected time.
 * @param onValueChange Callback function to be invoked when a new time is selected.
 * @param label The label text for the time field.
 * @param is24Hour Whether to use 24-hour format or 12-hour format.
 * @param displayFormatter The formatter to display the selected time.
 */
@Composable
fun TimePickerField(
    value: LocalTime?,
    onValueChange: (LocalTime?) -> Unit,
    label: String = LABEL_TIME,
    is24Hour: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm")
) {
  var open by remember { mutableStateOf(false) }
  val state =
      rememberTimePickerState(
          is24Hour = is24Hour,
          initialHour = value?.hour ?: Dimensions.Numbers.defaultTimeHour,
          initialMinute = value?.minute ?: Dimensions.Numbers.defaultTimeMinute)
  val text = value?.format(displayFormatter) ?: LABEL_TIME

  Box(modifier = Modifier.testTag(SessionTestTags.TIME_FIELD)) {
    IconTextFieldNew(
        value = text,
        onValueChange = { /* read-only; picker controls it */},
        placeholder = label,
        editable = false,
        leadingIcon = {
          Icon(Icons.Default.Timer, contentDescription = LABEL_TIME, tint = AppColors.neutral)
        },
        trailingIcon = {
          Icon(
              Icons.Default.ChevronRight, contentDescription = null, tint = AppColors.textIconsFade)
        },
        modifier =
            Modifier.fillMaxWidth(1f)
                .clickable { open = true }
                .testTag(SessionTestTags.TIME_PICK_BUTTON))
  }

  if (open) {
    AlertDialog(
        onDismissRequest = { open = false },
        containerColor = AppColors.primary,
        shape = RoundedCornerShape(Dimensions.Spacing.xxxLarge),
        confirmButton = {
          Row(
              modifier =
                  Modifier.fillMaxWidth()
                      .padding(
                          horizontal = Dimensions.Spacing.xxLarge,
                          vertical = Dimensions.Padding.medium),
              horizontalArrangement = Arrangement.spacedBy(Dimensions.Padding.large)) {
                // Cancel button
                Surface(
                    shape = RoundedCornerShape(Dimensions.Spacing.large),
                    color = AppColors.secondary,
                    modifier = Modifier.weight(1f)) {
                      TextButton(
                          onClick = { open = false },
                          modifier = Modifier.fillMaxWidth(),
                          contentPadding = PaddingValues(vertical = Dimensions.Padding.medium)) {
                            Text(
                                BUTTON_CANCEL,
                                style = MaterialTheme.typography.titleMedium,
                                color = AppColors.textIconsFade)
                          }
                    }

                // OK button
                Surface(
                    shape = RoundedCornerShape(Dimensions.Spacing.extraLarge),
                    color = AppColors.neutral,
                    modifier = Modifier.weight(1f)) {
                      TextButton(
                          modifier =
                              Modifier.testTag(SessionTestTags.TIME_PICKER_OK_BUTTON)
                                  .fillMaxWidth(),
                          contentPadding = PaddingValues(vertical = Dimensions.Padding.medium),
                          onClick = {
                            onValueChange(LocalTime.of(state.hour, state.minute))
                            open = false
                          }) {
                            Text(
                                BUTTON_OK,
                                style = MaterialTheme.typography.titleMedium,
                                color = AppColors.primary)
                          }
                    }
              }
        },
        dismissButton = {},
        text = {
          Column(
              modifier = Modifier.fillMaxWidth().padding(vertical = Dimensions.Padding.medium),
              horizontalAlignment = Alignment.CenterHorizontally) {
                // Header with icon and label
                Row(
                    modifier = Modifier.fillMaxWidth().padding(bottom = Dimensions.Spacing.xxLarge),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.Center) {
                      Icon(
                          Icons.Default.Timer,
                          contentDescription = null,
                          tint = AppColors.neutral,
                          modifier = Modifier.size(Dimensions.IconSize.extraLarge))
                      Spacer(Modifier.width(Dimensions.Padding.large))
                      Text(
                          TITLE_SELECT_TIME,
                          style = MaterialTheme.typography.titleLarge,
                          color = AppColors.textIcons)
                    }

                // Time input without background
                TimeInput(
                    state = state,
                    modifier =
                        Modifier.testTag(ComponentsTestTags.TIME_PICKER)
                            .padding(
                                horizontal = Dimensions.Padding.extraLarge,
                                vertical = Dimensions.Padding.medium),
                    TimePickerDefaults.colors(
                        clockDialColor = AppColors.primary,
                        clockDialSelectedContentColor = AppColors.primary,
                        clockDialUnselectedContentColor = AppColors.textIconsFade,
                        selectorColor = AppColors.neutral,
                        periodSelectorBorderColor = AppColors.neutral,
                        periodSelectorSelectedContainerColor = AppColors.neutral,
                        periodSelectorSelectedContentColor = AppColors.primary,
                        periodSelectorUnselectedContainerColor = AppColors.secondary,
                        periodSelectorUnselectedContentColor = AppColors.textIconsFade,
                        timeSelectorSelectedContainerColor = AppColors.neutral,
                        timeSelectorUnselectedContainerColor = AppColors.secondary,
                        timeSelectorSelectedContentColor = AppColors.primary,
                        timeSelectorUnselectedContentColor = AppColors.textIcons,
                    ))
              }
        })
  }
}

/**
 * A combined date and time picker component.
 *
 * @param date The currently selected date.
 * @param time The currently selected time.
 * @param onDateChange Callback function to be invoked when a new date is selected.
 * @param onFocusChanged Callback function to be invoked when the focus state changes.
 * @param onTimeChange Callback function to be invoked when a new time is selected.
 */
@Composable
fun DateAndTimePicker(
    date: LocalDate?,
    time: LocalTime?,
    onDateChange: (LocalDate?) -> Unit,
    onFocusChanged: (Boolean) -> Unit = {},
    onTimeChange: (LocalTime?) -> Unit
) {
  Row(
      modifier =
          Modifier.fillMaxWidth()
              .background(
                  color = AppColors.secondary,
                  shape = RoundedCornerShape(Dimensions.CornerRadius.medium))) {
        Box(Modifier.fillMaxWidth(0.55f).onFocusChanged { onFocusChanged(it.isFocused) }) {
          DatePickerDockedField(
              value = date, onValueChange = onDateChange, label = LABEL_DATE, editable = true)
        }

        Column {
          Box(Modifier.onFocusChanged { onFocusChanged(it.isFocused) }) {
            TimePickerField(value = time, onValueChange = onTimeChange, label = LABEL_TIME)
          }

          // Show error if date/time is in the past
          if (isDateTimeInPast(date, time)) {
            Spacer(Modifier.height(Dimensions.Spacing.extraSmall))
            Text(
                text = "Cannot create a session in the past",
                color = MaterialTheme.colorScheme.error,
                style = MaterialTheme.typography.bodySmall,
                modifier = Modifier.padding(start = Dimensions.Padding.medium))
          }
        }
      }
}

/**
 * A button that opens a dialog to search and select a session location.
 *
 * @param account The user's account.
 * @param discussion The discussion associated with the session.
 * @param viewModel The CreateSessionViewModel for managing session state.
 * @param buttonTestTag Test tag for the location picker button.
 * @param dialogTestTag Test tag for the location picker dialog.
 */
@Composable
fun SessionLocationSearchButton(
    account: Account,
    discussion: Discussion,
    viewModel: CreateSessionViewModel,
    buttonTestTag: String = LOCATION_PICKER_BUTTON,
    dialogTestTag: String = LOCATION_PICKER_DIALOG
) {
  var showDialog by rememberSaveable { mutableStateOf(false) }
  var selectedLocationLabel by rememberSaveable {
    mutableStateOf(
        discussion.session?.location?.name?.takeIf { it.isNotBlank() } ?: TEXT_SELECT_LOCATION)
  }

  Button(
      onClick = { showDialog = true },
      modifier =
          Modifier.fillMaxWidth()
              .heightIn(min = Dimensions.ContainerSize.timeFieldHeight)
              .testTag(buttonTestTag),
      colors = ButtonDefaults.buttonColors(containerColor = AppColors.secondary),
      shape = RoundedCornerShape(Dimensions.CornerRadius.medium),
      contentPadding = PaddingValues(Dimensions.Padding.extraMedium)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.Start) {
              Icon(
                  imageVector = Icons.Default.LocationOn,
                  contentDescription = "Location Pin",
                  tint = AppColors.neutral)
              Spacer(Modifier.width(Dimensions.Spacing.medium))
              Text(
                  text = selectedLocationLabel,
                  style = MaterialTheme.typography.bodySmall,
                  color = AppColors.textIcons)
              Spacer(Modifier.weight(1f))
              Icon(imageVector = Icons.Default.ChevronRight, contentDescription = null)
            }
      }

  if (showDialog) {
    Dialog(onDismissRequest = { showDialog = false }) {
      Surface(
          shape = RoundedCornerShape(Dimensions.CornerRadius.medium),
          color = AppColors.primary,
          modifier = Modifier.fillMaxWidth(1f).wrapContentHeight()) {
            Column(modifier = Modifier.padding(Dimensions.Padding.extraMedium)) {
              Text(
                  LABEL_LOCATION,
                  color = AppColors.textIcons,
                  style = MaterialTheme.typography.titleMedium)

              Spacer(Modifier.height(Dimensions.Spacing.medium))

              Box(modifier = Modifier.testTag(dialogTestTag)) {
                SessionLocationSearchBar(
                    account = account,
                    discussion = discussion,
                    viewModel = viewModel,
                    onLocationSelected = { location ->
                      selectedLocationLabel = location.name.ifBlank { TEXT_SELECT_LOCATION }
                    })
              }

              Spacer(Modifier.height(Dimensions.Spacing.medium))

              Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                TextButton(onClick = { showDialog = false }) { Text(BUTTON_CANCEL) }
                TextButton(onClick = { showDialog = false }) { Text(BUTTON_OK) }
              }
            }
          }
    }
  }
}

/**
 * A search bar for selecting a session location.
 *
 * @param account The user's account.
 * @param discussion The discussion associated with the session.
 * @param viewModel The CreateSessionViewModel for managing session state.
 * @param onLocationSelected Callback function invoked when a location is selected.
 * @param inputFieldTestTag Test tag for the input field.
 * @param dropdownItemTestTag Test tag for the dropdown items.
 */
@Composable
fun SessionLocationSearchBar(
    account: Account,
    discussion: Discussion,
    viewModel: CreateSessionViewModel,
    onLocationSelected: (Location) -> Unit = {},
    inputFieldTestTag: String = ComponentsTestTags.SESSION_LOCATION_SEARCH_INPUT,
    dropdownItemTestTag: String = ComponentsTestTags.SESSION_LOCATION_SEARCH_ITEM
) {
  LocationSearchBar(
      setLocation = { location ->
        viewModel.setLocation(account, discussion, location)
        onLocationSelected(location)
      },
      setLocationQuery = { viewModel.setLocationQuery(account, discussion, it) },
      initial = discussion.session?.location ?: Location(),
      viewModel = viewModel,
      enabled = true,
      inputFieldTestTag = inputFieldTestTag,
      dropdownItemTestTag = dropdownItemTestTag)
}

@Composable
fun ShopLocationSearchBar(
    account: Account,
    shop: Shop?,
    viewModel: ShopSearchViewModel,
    enabled: Boolean = true,
    inputFieldTestTag: String = "",
    dropdownItemTestTag: String = ""
) {
  LocationSearchBar(
      setLocation = {
        val location = it
        shop?.let { viewModel.setLocation(shop, account, location) }
            ?: viewModel.setLocation(location)
      },
      setLocationQuery = {
        val query = it
        shop?.let { viewModel.setLocationQuery(shop, account, query) }
            ?: viewModel.setLocationQuery(query)
      },
      initial = shop?.address ?: Location(),
      viewModel = viewModel,
      enabled = enabled,
      inputFieldTestTag = inputFieldTestTag,
      dropdownItemTestTag = dropdownItemTestTag)
}

@Composable
fun SpaceRenterLocationSearchBar(
    account: Account,
    spaceRenter: SpaceRenter?,
    viewModel: SpaceRenterSearchViewModel,
    enabled: Boolean = true,
    inputFieldTestTag: String = "",
    dropdownItemTestTag: String = ""
) {
  LocationSearchBar(
      setLocation = { loc ->
        spaceRenter?.let { viewModel.setLocation(spaceRenter, account, loc) }
            ?: viewModel.setLocation(loc)
      },
      setLocationQuery = { q ->
        spaceRenter?.let { viewModel.setLocationQuery(spaceRenter, account, q) }
            ?: viewModel.setLocationQuery(q)
      },
      initial = spaceRenter?.address ?: Location(),
      viewModel = viewModel,
      enabled = enabled,
      inputFieldTestTag = inputFieldTestTag,
      dropdownItemTestTag = dropdownItemTestTag)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun LocationSearchBar(
    setLocation: (Location) -> Unit,
    setLocationQuery: (String) -> Unit,
    initial: Location,
    viewModel: SearchViewModel,
    enabled: Boolean = true,
    inputFieldTestTag: String = "",
    dropdownItemTestTag: String = ""
) {
  val results by viewModel.locationUIState.collectAsStateWithLifecycle()

  var menuOpen by rememberSaveable { mutableStateOf(false) }
  var text by rememberSaveable { mutableStateOf(initial.name) }
  val hasSuggestions = results.locationSuggestions.isNotEmpty()

  LaunchedEffect(Unit) { if (initial.name.isNotBlank()) setLocation(initial) }

  ExposedDropdownMenuBox(
      expanded = menuOpen && hasSuggestions, onExpandedChange = { menuOpen = it }) {
        FocusableInputField(
            value = text,
            enabled = enabled,
            onValueChange = {
              menuOpen = true
              text = it
              setLocationQuery(it)
            },
            label = { Text(LABEL_LOCATION) },
            placeholder = { Text(PLACEHOLDER_LOCATION) },
            modifier =
                Modifier.menuAnchor(type = MenuAnchorType.PrimaryEditable, enabled = true)
                    .fillMaxWidth()
                    .testTag(inputFieldTestTag),
            leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
        )

        ExposedDropdownMenu(
            expanded = menuOpen && hasSuggestions,
            onDismissRequest = { menuOpen = false },
            containerColor = MaterialTheme.colorScheme.background,
        ) {
          results.locationSuggestions.take(Dimensions.Numbers.searchResultLimit).forEachIndexed {
              i,
              loc ->
            DropdownMenuItem(
                text = { Text(loc.name) },
                onClick = {
                  menuOpen = false
                  text = loc.name
                  setLocation(loc)
                },
                modifier = Modifier.testTag("$dropdownItemTestTag:$i"))
          }
        }
      }
}

@Composable
fun SessionGameSearchBar(
    account: Account,
    discussion: Discussion,
    viewModel: CreateSessionViewModel,
    initial: Game? = null,
    inputFieldTestTag: String = ComponentsTestTags.SESSION_GAME_SEARCH_INPUT,
    dropdownItemTestTag: String = ComponentsTestTags.SESSION_GAME_SEARCH_ITEM
) {
  GameSearchBar(
      setGame = { viewModel.setGame(account, discussion, it) },
      setGameQuery = { viewModel.setGameQuery(account, discussion, it) },
      viewModel,
      initial,
      emptySet(),
      inputFieldTestTag,
      dropdownItemTestTag)
}

@Composable
fun ShopGameSearchBar(
    account: Account,
    shop: Shop?,
    viewModel: ShopSearchViewModel,
    initial: Game? = null,
    existing: Set<String> = emptySet(),
    inputFieldTestTag: String = "",
    dropdownItemTestTag: String = ""
) {
  GameSearchBar(
      setGame = {
        val game = it
        shop?.let { viewModel.setGame(shop, account, game) } ?: viewModel.setGame(game)
      },
      setGameQuery = {
        val query = it
        shop?.let { viewModel.setGameQuery(shop, account, query) } ?: viewModel.setGameQuery(query)
      },
      viewModel,
      initial,
      existing,
      inputFieldTestTag,
      dropdownItemTestTag)
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun GameSearchBar(
    setGame: (Game) -> Unit,
    setGameQuery: (String) -> Unit,
    viewModel: SearchViewModel,
    initial: Game? = null,
    existing: Set<String> = emptySet(),
    inputFieldTestTag: String = "",
    dropdownItemTestTag: String = ""
) {
  val results by viewModel.gameUIState.collectAsStateWithLifecycle()

  var menuOpen by rememberSaveable { mutableStateOf(false) }
  var text by rememberSaveable { mutableStateOf(initial?.name.orEmpty()) }
  val hasSuggestions = results.gameSuggestions.isNotEmpty()

  LaunchedEffect(initial) { if (initial?.name?.isNotBlank() == true) setGame(initial) }

  // Sync text field with ViewModel's gameQuery when it changes (e.g., when game is fetched)
  LaunchedEffect(results.gameQuery) {
    if (results.gameQuery.isNotBlank() && text != results.gameQuery) {
      text = results.gameQuery
    }
  }

  Column {
    ExposedDropdownMenuBox(
        expanded = menuOpen && hasSuggestions, onExpandedChange = { menuOpen = it }) {
          FocusableInputField(
              value = text,
              onValueChange = {
                menuOpen = true
                text = it
                setGameQuery(it)
              },
              label = { Text(LABEL_GAME) },
              placeholder = { Text(PLACEHOLDER_SEARCH_GAMES) },
              modifier =
                  Modifier.menuAnchor(type = MenuAnchorType.PrimaryEditable, enabled = true)
                      .fillMaxWidth()
                      .testTag(inputFieldTestTag),
              leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
              isError = results.gameSearchError != null)

          ExposedDropdownMenu(
              expanded = menuOpen && hasSuggestions,
              onDismissRequest = { menuOpen = false },
              modifier = Modifier.background(AppColors.primary)) {
                results.gameSuggestions
                    .filterNot { existing.contains(it.uid) }
                    .take(Dimensions.Numbers.searchResultLimit)
                    .forEachIndexed { i, game ->
                      DropdownMenuItem(
                          text = { Text(game.name) },
                          onClick = {
                            menuOpen = false
                            text = game.name
                            setGame(game)
                          },
                          modifier =
                              Modifier.testTag("$dropdownItemTestTag:$i")
                                  .background(AppColors.primary))
                    }
              }
        }

    // Display error message if present
    results.gameSearchError?.let { errorMsg ->
      Text(
          text = errorMsg,
          color = MaterialTheme.colorScheme.error,
          style = MaterialTheme.typography.bodySmall,
          modifier =
              Modifier.fillMaxWidth()
                  .padding(start = Dimensions.Padding.extraLarge, top = Dimensions.Padding.small)
                  .testTag(
                      com.github.meeplemeet.ui.sessions.SessionCreationTestTags.GAME_SEARCH_ERROR))
    }
  }
}
