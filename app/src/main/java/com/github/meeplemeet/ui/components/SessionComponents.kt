// All components were done by hand primarily (or taken in the internet and adapted).
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Timer
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDefaults
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DisplayMode
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RangeSlider
import androidx.compose.material3.SliderColors
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Popup
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Game
import com.github.meeplemeet.model.structures.Location
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppColors
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale

/** Extra test tags for components (kept separate to avoid breaking other tests). */
object ComponentsTestTags {
  const val UNDERLINED_LABEL = "comp_underlined_label"
  const val LABELED_LABEL = "comp_labeled_label"

  const val COUNT_BUBBLE_TEXT = "comp_count_bubble_text"

  const val PILL_RANGE_SLIDER = "comp_pill_range_slider"

  const val PARTICIPANT_NAME = "comp_participant_name"
  const val PARTICIPANT_ACTION = "comp_participant_action"

  const val DATE_PICKER = "comp_date_picker"
  const val TIME_PICKER = "comp_time_picker"

  const val SEARCH_POPUP_SURFACE = "comp_search_popup_surface"
  const val SEARCH_LOADING = "comp_search_loading"
  const val SEARCH_EMPTY = "comp_search_empty"
  const val SEARCH_LIST = "comp_search_list"
  const val SEARCH_ITEM_PREFIX = "comp_search_item_"
}

/** Action for participant chip: add or remove. */
enum class ParticipantAction {
  Add,
  Remove
}

/* =======================================================================
 * Components
 * ======================================================================= */

@Composable
fun SectionCard(
    modifier: Modifier = Modifier,
    contentPadding: PaddingValues = PaddingValues(16.dp),
    content: @Composable ColumnScope.() -> Unit
) {
  Column(modifier = modifier.padding(contentPadding), content = content)
}

@Composable
fun UnderlinedLabel(
    text: String,
    textStyle: TextStyle = MaterialTheme.typography.bodyMedium,
    textColor: Color = MaterialTheme.colorScheme.onBackground,
) {
  Text(
      text = text,
      modifier = Modifier.testTag(ComponentsTestTags.UNDERLINED_LABEL),
      style = textStyle,
      color = textColor,
      textDecoration = TextDecoration.Underline,
  )
}

@Composable
fun LabeledTextField(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String = "",
    singleLine: Boolean = false,
    labelTextStyle: TextStyle = MaterialTheme.typography.bodySmall,
    labelTextColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    modifier: Modifier = Modifier,
    outlinedTextStyle: TextStyle = MaterialTheme.typography.bodySmall
) {
  Column {
    Text(
        label,
        style = labelTextStyle,
        color = labelTextColor,
        modifier = Modifier.testTag(ComponentsTestTags.LABELED_LABEL))
    Spacer(Modifier.height(6.dp))
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        singleLine = singleLine,
        placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
        textStyle = outlinedTextStyle,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done))
  }
}

@Composable
fun IconTextField(
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String,
    editable: Boolean = true,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    textStyle: TextStyle = MaterialTheme.typography.bodySmall,
    modifier: Modifier
) {
  OutlinedTextField(
      value = value,
      onValueChange = onValueChange,
      modifier = modifier,
      readOnly = !editable,
      leadingIcon = leadingIcon,
      trailingIcon = trailingIcon,
      placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
      textStyle = textStyle)
}

@Composable
fun CountBubble(
    count: Int,
    modifier: Modifier = Modifier,
    colorText: Color = MaterialTheme.colorScheme.onBackground,
    styleText: TextStyle = MaterialTheme.typography.bodySmall
) {
  Box(modifier = modifier) {
    Text(
        "$count",
        modifier = Modifier.testTag(ComponentsTestTags.COUNT_BUBBLE_TEXT),
        style = styleText,
        color = colorText)
  }
}

@Composable
fun DiscretePillSlider(
    range: ClosedFloatingPointRange<Float>,
    values: ClosedFloatingPointRange<Float>,
    steps: Int,
    editable: Boolean = false,
    onValuesChange: (Float, Float) -> Unit,
    surroundModifier: Modifier = Modifier,
    sliderModifier: Modifier = Modifier,
    sliderColors: SliderColors =
        SliderDefaults.colors(
            activeTrackColor = MaterialTheme.colorScheme.tertiary,
            inactiveTrackColor = MaterialTheme.colorScheme.outline,
            thumbColor = MaterialTheme.colorScheme.tertiary)
) {
  Column(modifier = surroundModifier) {
    Box(modifier = sliderModifier) {
      RangeSlider(
          value = values,
          enabled = editable,
          onValueChange = { if (editable) onValuesChange(it.start, it.endInclusive) },
          valueRange = range,
          steps = steps,
          colors = sliderColors,
          modifier = Modifier.testTag(ComponentsTestTags.PILL_RANGE_SLIDER))
    }
  }
}

@Composable
fun ParticipantChip(
    account: Account,
    action: ParticipantAction,
    onClick: (Account) -> Unit,
    modifier: Modifier = Modifier,
    textModifier: Modifier = Modifier,
    textColor: Color = MaterialTheme.colorScheme.onSurface,
) {
  Box(modifier = modifier) {
    Text(
        account.name,
        modifier =
            textModifier
                .align(Alignment.Center)
                .testTag("${ComponentsTestTags.PARTICIPANT_NAME}:${account.name}"),
        style = MaterialTheme.typography.labelSmall,
        color = textColor,
        textAlign = TextAlign.Center,
        maxLines = 1,
        overflow = TextOverflow.Ellipsis)

    Row(
        modifier = Modifier.matchParentSize(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween) {
          Row(verticalAlignment = Alignment.CenterVertically) {
            Box(Modifier.size(18.dp).background(MaterialTheme.colorScheme.tertiary, CircleShape))
            Spacer(Modifier.width(6.dp))
          }

          val (icon, tint) =
              when (action) {
                ParticipantAction.Add -> Icons.Default.Add to MaterialTheme.colorScheme.primary
                ParticipantAction.Remove -> Icons.Default.Close to MaterialTheme.colorScheme.error
              }
          IconButton(
              onClick = { onClick(account) },
              modifier =
                  Modifier.size(20.dp)
                      .testTag(
                          "${ComponentsTestTags.PARTICIPANT_ACTION}:${action.name}:${account.name}"),
              colors = IconButtonDefaults.iconButtonColors(contentColor = tint)) {
                Icon(icon, contentDescription = null)
              }
        }
  }
}

@Composable
fun <T> TwoPerRowGrid(
    items: List<T>,
    key: (T) -> Any,
    modifier: Modifier = Modifier,
    rowsModifier: Modifier = Modifier,
    content: @Composable (item: T, modifier: Modifier) -> Unit,
) {
  val rows = remember(items) { items.chunked(2) }
  Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(10.dp)) {
    rows.forEach { row ->
      Row(horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = rowsModifier) {
        row.forEach { item -> content(item, rowsModifier.weight(1f, fill = true)) }
        if (row.size == 1) Spacer(rowsModifier.weight(1f, fill = true))
      }
    }
  }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DatePickerDockedField(
    value: LocalDate?,
    onValueChange: (LocalDate?) -> Unit,
    label: String = "Date",
    editable: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  var showDialogDate by remember { mutableStateOf(false) }
  val text = value?.format(displayFormatter) ?: ""

  IconTextField(
      value = text,
      onValueChange = {},
      placeholder = label,
      leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "Date") },
      trailingIcon = {
        if (editable) {
          TextButton(
              onClick = { showDialogDate = true },
              modifier = Modifier.testTag(SessionTestTags.DATE_PICK_BUTTON)) {
                Text("Pick")
              }
        }
      },
      modifier = Modifier.fillMaxWidth().testTag(SessionTestTags.DATE_FIELD))

  if (showDialogDate) {
    AppDatePickerDialog(
        zoneId = zoneId,
        onDismiss = { showDialogDate = false },
        onDateSelected = { selectedDate -> onValueChange(selectedDate) })
  }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AppDatePickerDialog(
    onDismiss: () -> Unit,
    onDateSelected: (LocalDate) -> Unit,
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  val state = rememberDatePickerState(initialDisplayMode = DisplayMode.Picker)

  DatePickerDialog(
      onDismissRequest = onDismiss,
      confirmButton = {
        TextButton(
            modifier = Modifier.testTag(SessionTestTags.DATE_PICKER_OK_BUTTON),
            onClick = {
              state.selectedDateMillis?.let { ms ->
                onDateSelected(Instant.ofEpochMilli(ms).atZone(zoneId).toLocalDate())
              }
              onDismiss()
            }) {
              Text("OK")
            }
      },
      dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
  ) {
    DatePicker(
        state = state,
        modifier = Modifier.testTag(ComponentsTestTags.DATE_PICKER),
        colors =
            DatePickerDefaults.colors(
                containerColor = AppColors.primary,
                titleContentColor = AppColors.textIconsFade,
                headlineContentColor = AppColors.textIcons,
                selectedDayContentColor = AppColors.primary,
                selectedDayContainerColor = AppColors.neutral))
  }
}

@Composable
fun TimePickerField(
    value: LocalTime?,
    onValueChange: (LocalTime?) -> Unit,
    label: String = "Time",
    is24Hour: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm")
) {
  var open by remember { mutableStateOf(false) }
  val state =
      rememberTimePickerState(
          is24Hour = is24Hour, initialHour = value?.hour ?: 19, initialMinute = value?.minute ?: 0)
  val text = value?.format(displayFormatter) ?: ""

  OutlinedTextField(
      value = text,
      onValueChange = { /* read-only; picker controls it */},
      label = { Text(label) },
      readOnly = true,
      leadingIcon = { Icon(Icons.Default.Timer, contentDescription = "Select time") },
      trailingIcon = {
        TextButton(
            onClick = { open = true },
            modifier = Modifier.testTag(SessionTestTags.TIME_PICK_BUTTON)) {
              Text("Pick")
            }
      },
      modifier = Modifier.fillMaxWidth().height(64.dp).testTag(SessionTestTags.TIME_FIELD))

  if (open) {
    AlertDialog(
        onDismissRequest = { open = false },
        confirmButton = {
          TextButton(
              modifier = Modifier.testTag(SessionTestTags.TIME_PICKER_OK_BUTTON),
              onClick = {
                onValueChange(LocalTime.of(state.hour, state.minute))
                open = false
              }) {
                Text("OK")
              }
        },
        dismissButton = { TextButton(onClick = { open = false }) { Text("Cancel") } },
        text = {
          TimePicker(state = state, modifier = Modifier.testTag(ComponentsTestTags.TIME_PICKER))
        })
  }
}

@Composable
fun <T> SearchDropdownField(
    label: String,
    query: String,
    onQueryChange: (String) -> Unit,
    suggestions: List<T>,
    onSuggestionClick: (T) -> Unit,
    getPrimaryText: (T) -> String,
    modifier: Modifier = Modifier,
    modifierTxtField: Modifier = Modifier,
    placeholder: String = "",
    isLoading: Boolean = false,
    showWhenEmptyQuery: Boolean = false,
    itemContent: (@Composable (item: T) -> Unit)? = null,
    emptyText: String = "No results"
) {
  var expanded by remember { mutableStateOf(false) }

  Box(modifier = modifier) {
    OutlinedTextField(
        value = query,
        onValueChange = {
          onQueryChange(it)
          expanded = (showWhenEmptyQuery || it.isNotBlank())
        },
        label = { Text(label) },
        leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
        trailingIcon = {
          when {
            isLoading -> CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
            query.isNotEmpty() ->
                IconButton(
                    onClick = {
                      onQueryChange("")
                      expanded = false
                    },
                    modifier = Modifier.testTag(ComponentsTestTags.SEARCH_LOADING).then(Modifier)) {
                      Icon(
                          Icons.Default.Close,
                          contentDescription = "Clear",
                          modifier =
                              Modifier.testTag(
                                  ComponentsTestTags.SEARCH_EMPTY))
                    }
          }
        },
        placeholder = { if (placeholder.isNotEmpty()) Text(placeholder) },
        singleLine = true,
        modifier = Modifier.fillMaxWidth().height(64.dp).then(modifierTxtField))

    val shouldShow =
        expanded && (isLoading || suggestions.isNotEmpty() || (query.isNotBlank() && !isLoading))

    if (shouldShow) {
      Popup(onDismissRequest = { expanded = false }, alignment = Alignment.TopStart) {
        Column(Modifier.fillMaxWidth().offset(y = 64.dp)) {
          Surface(
              modifier =
                  Modifier.fillMaxWidth()
                      .clip(RoundedCornerShape(12.dp))
                      .testTag(ComponentsTestTags.SEARCH_POPUP_SURFACE),
              tonalElevation = 4.dp,
              shadowElevation = 4.dp) {
                when {
                  isLoading -> {
                    Row(
                        Modifier.fillMaxWidth()
                            .padding(16.dp)
                            .testTag(ComponentsTestTags.SEARCH_LOADING),
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        verticalAlignment = Alignment.CenterVertically) {
                          CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
                          Text("Searching…", style = MaterialTheme.typography.bodyMedium)
                        }
                  }
                  suggestions.isEmpty() -> {
                    Text(
                        emptyText,
                        modifier =
                            Modifier.fillMaxWidth()
                                .padding(16.dp)
                                .testTag(ComponentsTestTags.SEARCH_EMPTY),
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant)
                  }
                  else -> {
                    LazyColumn(
                        modifier =
                            Modifier.fillMaxWidth()
                                .heightIn(max = 200.dp)
                                .background(MaterialTheme.colorScheme.surface)
                                .testTag(ComponentsTestTags.SEARCH_LIST),
                        contentPadding = PaddingValues(vertical = 6.dp)) {
                          items(suggestions) { item ->
                            val raw = getPrimaryText(item)
                            val norm =
                                raw.lowercase(Locale.getDefault())
                                    .replace(Regex("[^a-z0-9]+"), "_")
                                    .trim('_')

                            Row(
                                modifier =
                                    Modifier.fillMaxWidth()
                                        .clickable {
                                          onSuggestionClick(item)
                                          expanded = false
                                        }
                                        .padding(horizontal = 12.dp, vertical = 10.dp)
                                        .testTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}$norm"),
                                verticalAlignment = Alignment.CenterVertically) {
                                  if (itemContent != null) {
                                    itemContent(item)
                                  } else {
                                    Text(
                                        text = raw,
                                        style = MaterialTheme.typography.bodyMedium,
                                        maxLines = 1,
                                        overflow = TextOverflow.Ellipsis)
                                  }
                                }
                          }
                        }
                  }
                }
              }
        }
      }
    }
  }
}

@Composable
fun GameSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Game>,
    onPick: (Game) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search games…"
) {
  SearchDropdownField(
      label = "Game",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      modifierTxtField = Modifier.testTag(SessionTestTags.PROPOSED_GAME),
      getPrimaryText = { it.name },
      isLoading = isLoading,
      placeholder = placeholder,
      modifier = modifier)
}

@Composable
fun LocationSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Location>,
    onPick: (Location) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search locations…"
) {
  SearchDropdownField(
      label = "Location",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      getPrimaryText = { it.name },
      isLoading = isLoading,
      modifierTxtField = Modifier.testTag(SessionTestTags.LOCATION_FIELD),
      placeholder = placeholder,
      modifier = modifier,
      itemContent = { loc ->
        Column(Modifier.fillMaxWidth()) {
          Text(
              text = loc.name,
              style = MaterialTheme.typography.bodyMedium,
              maxLines = 1,
              overflow = TextOverflow.Ellipsis)
          Text(
              text = "${"%.5f".format(loc.latitude)}, ${"%.5f".format(loc.longitude)}",
              style = MaterialTheme.typography.labelSmall,
              color = MaterialTheme.colorScheme.onSurfaceVariant)
        }
      })
}
