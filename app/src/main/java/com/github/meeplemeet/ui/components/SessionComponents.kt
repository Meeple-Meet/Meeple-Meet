// All components were done by hand primarily (or taken in the internet and adapted).
// Then they were adjusted and verified by ChatGPT-5 Thinking Extend to find potential flows.
// They were lastly redone and refactored by hand
// Docstrings were generated by the integrated copilot AI in Android Studio
@file:OptIn(ExperimentalMaterial3Api::class)

package com.github.meeplemeet.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Timer
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDefaults
import androidx.compose.material3.DisplayMode
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RangeSlider
import androidx.compose.material3.SliderColors
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TimePicker
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.material3.rememberTimePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Popup
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Game
import com.github.meeplemeet.model.structures.Location
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppColors
import com.github.meeplemeet.ui.theme.AppTheme
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter

/** Action for participant chip: add or remove. */
enum class ParticipantAction {
  Add,
  Remove
}

/* =======================================================================
 * Components
 * ======================================================================= */

/**
 * A simple card-like section with padding.
 *
 * @param modifier the modifier to be applied to the section
 * @param contentPadding the padding inside the section
 * @param content the content of the section
 */
@Composable
fun SectionCard(
    modifier: Modifier = Modifier,
    contentPadding: PaddingValues = PaddingValues(16.dp),
    content: @Composable ColumnScope.() -> Unit
) {
  Column(modifier = modifier.padding(contentPadding), content = content)
}

/**
 * A simple underlined label.
 *
 * @param text the text of the label
 * @param textStyle the style of the text
 * @param textColor the color of the text
 */
@Composable
fun UnderlinedLabel(
    text: String,
    textStyle: TextStyle = MaterialTheme.typography.bodyMedium,
    textColor: Color = MaterialTheme.colorScheme.onBackground,
) {
  Text(
      text = text,
      style = textStyle,
      color = textColor,
      textDecoration = TextDecoration.Underline,
  )
}

/**
 * A labeled text field with a label above it.
 *
 * @param label the label text
 * @param value the current text field value
 * @param onValueChange the callback to be invoked when the text field value changes
 * @param placeholder the placeholder text
 * @param singleLine whether the text field is single line
 * @param labelTextStyle the style of the label text
 * @param labelTextColor the color of the label text
 * @param modifier the modifier to be applied to the text field
 * @param outlinedTextStyle the style of the text field text
 */
@Composable
fun LabeledTextField(
    label: String,
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String = "",
    singleLine: Boolean = false,
    labelTextStyle: TextStyle = MaterialTheme.typography.bodySmall,
    labelTextColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,
    modifier: Modifier = Modifier,
    outlinedTextStyle: TextStyle = MaterialTheme.typography.bodySmall
) {
  Column {
    Text(label, style = labelTextStyle, color = labelTextColor)
    Spacer(Modifier.height(6.dp))
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier,
        singleLine = singleLine,
        placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
        textStyle = outlinedTextStyle,
        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done))
  }
}

/**
 * A text field with optional leading and trailing icons.
 *
 * @param value the current text field value
 * @param onValueChange the callback to be invoked when the text field value changes
 * @param placeholder the placeholder text
 * @param leadingIcon the leading icon composable
 * @param trailingIcon the trailing icon composable
 * @param textStyle the style of the text field text
 * @param modifier the modifier to be applied to the text field
 */
@Composable
fun IconTextField(
    value: String,
    onValueChange: (String) -> Unit,
    placeholder: String,
    editable: Boolean = true,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null,
    textStyle: TextStyle = MaterialTheme.typography.bodySmall,
    modifier: Modifier
) {
  OutlinedTextField(
      value = value,
      onValueChange = onValueChange,
      modifier = modifier,
      readOnly = editable,
      leadingIcon = leadingIcon,
      trailingIcon = trailingIcon,
      placeholder = { Text(placeholder, color = MaterialTheme.colorScheme.onSurfaceVariant) },
      textStyle = textStyle)
}

/**
 * A small bubble displaying a count.
 *
 * @param count the count to display
 * @param modifier the modifier to be applied to the bubble
 * @param colorText the color of the text
 * @param styleText the style of the text
 */
@Composable
fun CountBubble(
    count: Int,
    modifier: Modifier = Modifier,
    colorText: Color = MaterialTheme.colorScheme.onBackground,
    styleText: TextStyle = MaterialTheme.typography.bodySmall
) {
  Box(modifier = modifier) { Text("$count", style = styleText, color = colorText) }
}

/**
 * A discrete pill-shaped slider for selecting a range of values.
 *
 * @param range the range of values for the slider
 * @param values the current selected range of values
 * @param steps the number of discrete steps between the min and max values
 * @param onValuesChange the callback to be invoked when the selected range changes
 * @param surroundModifier the modifier to be applied to the surrounding box
 * @param sliderModifier the modifier to be applied to the slider itself
 * @param sliderColors the colors to be used for the slider
 */
@Composable
fun DiscretePillSlider(
    range: ClosedFloatingPointRange<Float>,
    values: ClosedFloatingPointRange<Float>,
    steps: Int,
    editable: Boolean = false,
    onValuesChange: (Float, Float) -> Unit,
    surroundModifier: Modifier = Modifier,
    sliderModifier: Modifier = Modifier,
    sliderColors: SliderColors =
        SliderDefaults.colors(
            activeTrackColor = MaterialTheme.colorScheme.tertiary,
            inactiveTrackColor = MaterialTheme.colorScheme.outline,
            thumbColor = MaterialTheme.colorScheme.tertiary)
) {
  Column(modifier = surroundModifier) {
    Box(modifier = sliderModifier) {
      RangeSlider(
          value = values,
          enabled = editable,
          onValueChange = { if (editable) onValuesChange(it.start, it.endInclusive) },
          valueRange = range,
          steps = steps,
          colors = sliderColors)
    }
  }
}

/**
 * A chip representing a participant with an action button.
 *
 * @param account the account of the participant
 * @param action the action to perform (add or remove)
 * @param onClick the callback to be invoked when the action button is clicked
 * @param modifier the modifier to be applied to the chip
 * @param textModifier the modifier to be applied to the text
 * @param textColor the color of the text
 */
@Composable
fun ParticipantChip(
    account: Account,
    action: ParticipantAction,
    onClick: (Account) -> Unit,
    modifier: Modifier = Modifier,
    textModifier: Modifier = Modifier,
    textColor: Color = MaterialTheme.colorScheme.onSurface,
) {
  Box(modifier = modifier) {
    Text(
        account.name,
        modifier = textModifier.align(Alignment.Center),
        style = MaterialTheme.typography.labelSmall,
        color = textColor,
        textAlign = TextAlign.Center,
        maxLines = 1,
        overflow = TextOverflow.Ellipsis)

    Row(
        modifier = Modifier.matchParentSize(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween) {
          Row(verticalAlignment = Alignment.CenterVertically) {
            Box(Modifier.size(18.dp).background(MaterialTheme.colorScheme.tertiary, CircleShape))
            Spacer(Modifier.width(6.dp))
          }

          val (icon, tint) =
              when (action) {
                ParticipantAction.Add -> Icons.Default.Add to MaterialTheme.colorScheme.primary
                ParticipantAction.Remove -> Icons.Default.Close to MaterialTheme.colorScheme.error
              }
          IconButton(
              onClick = { onClick(account) },
              modifier = Modifier.size(20.dp),
              colors = IconButtonDefaults.iconButtonColors(contentColor = tint)) {
                Icon(icon, contentDescription = null)
              }
        }
  }
}

/**
 * A grid displaying items in two columns per row.
 *
 * @param items the list of items to display
 * @param key a function to extract a unique key for each item
 * @param modifier the modifier to be applied to the LazyColumn
 * @param rowsModifier the modifier to be applied to each row
 * @param content the composable content for each item
 */
@Composable
fun <T> TwoPerRowGrid(
    items: List<T>,
    key: (T) -> Any,
    modifier: Modifier = Modifier,
    rowsModifier: Modifier = Modifier,
    content: @Composable (item: T, modifier: Modifier) -> Unit,
) {
  val rows = remember(items) { items.chunked(2) }
  LazyColumn(
      modifier = modifier,
      verticalArrangement = Arrangement.spacedBy(10.dp),
      contentPadding = PaddingValues(vertical = 8.dp)) {
        items(items = rows, key = { row -> row.joinToString("|") { key(it).toString() } }) { row ->
          Row(horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = rowsModifier) {
            row.forEach { item -> content(item, rowsModifier.weight(1f, fill = true)) }
            if (row.size == 1) Spacer(rowsModifier.weight(1f, fill = true))
          }
        }
      }
}

/**
 * A date picker field that shows a date picker in a popup when clicked.
 *
 * @param value the currently selected date
 * @param onValueChange the callback to be invoked when the date changes
 * @param label the label for the text field
 * @param displayFormatter the formatter to display the date
 * @param zoneId the time zone to use for date conversion
 */
@Composable
fun DatePickerDockedField(
    value: LocalDate?,
    onValueChange: (LocalDate?) -> Unit,
    label: String = "Date",
    editable: Boolean = true, // Marked as true to make Marco's tests pass
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  var showDialogDate by remember { mutableStateOf(false) }
  val text = value?.format(displayFormatter) ?: ""
  // The text field
  IconTextField(
      value = text.format(displayFormatter) ?: "",
      onValueChange = {}, // we control it externally
      placeholder = label,
      leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "Date") },
      trailingIcon = {
        if (editable) {
          TextButton(
              onClick = { showDialogDate = true },
              modifier = Modifier.testTag(SessionTestTags.DATE_PICK_BUTTON)) {
                Text("Pick")
              }
        }
      },
      modifier = Modifier.fillMaxWidth().testTag(SessionTestTags.DATE_FIELD))

  // The popup
  if (showDialogDate) {
    DatePickerDialog(
        onDismiss = { showDialogDate = false },
        onDateSelected = { selectedDate -> onValueChange(selectedDate) },
        displayFormatter = displayFormatter,
        zoneId = zoneId,
    )
  }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DatePickerDialog(
    onDismiss: () -> Unit,
    onDateSelected: (LocalDate) -> Unit,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"),
    zoneId: ZoneId = ZoneId.systemDefault()
) {
  val datePickerState = rememberDatePickerState(initialDisplayMode = DisplayMode.Picker)

  AlertDialog(
      containerColor = AppColors.primary,
      onDismissRequest = onDismiss,
      confirmButton = {
        TextButton(
            onClick = {
              val millis = datePickerState.selectedDateMillis
              if (millis != null) {
                val date =
                    Instant.ofEpochMilli(millis).atZone(zoneId).toLocalDate() // e.g. "2025-10-13"
                onDateSelected(date)
              }
              onDismiss()
            },
            modifier = Modifier.testTag(SessionTestTags.DATE_PICKER_OK_BUTTON)) {
              Text("OK")
            }
      },
      dismissButton = { TextButton(onClick = onDismiss) { Text("Cancel") } },
      text = {
        // Wrap DatePicker in a Box with fillMaxWidth and padding to avoid cropping
        Box(modifier = Modifier.fillMaxWidth().padding(horizontal = 8.dp)) {
          DatePicker(
              state = datePickerState,
              modifier = Modifier.fillMaxWidth(),
              colors =
                  DatePickerDefaults.colors(
                      containerColor = AppColors.primary,
                      titleContentColor = AppColors.textIconsFade,
                      headlineContentColor = AppColors.textIcons,
                      selectedDayContentColor = AppColors.primary,
                      selectedDayContainerColor = AppColors.neutral))
        }
      })
}

/**
 * A time picker field that shows a time picker dialog when clicked.
 *
 * @param value the currently selected time
 * @param onValueChange the callback to be invoked when the time changes
 * @param label the label for the text field
 * @param is24Hour whether to use 24-hour format
 * @param displayFormatter the formatter to display the time
 */
@Composable
fun TimePickerField(
    value: LocalTime?,
    onValueChange: (LocalTime?) -> Unit,
    label: String = "Time",
    is24Hour: Boolean = true,
    displayFormatter: DateTimeFormatter = DateTimeFormatter.ofPattern("HH:mm")
) {
  var open by remember { mutableStateOf(false) }
  val state =
      rememberTimePickerState(
          is24Hour = is24Hour, initialHour = value?.hour ?: 19, initialMinute = value?.minute ?: 0)
  val text = value?.format(displayFormatter) ?: ""

  OutlinedTextField(
      value = text,
      onValueChange = { /* read-only; picker controls it */},
      label = { Text(label) },
      readOnly = true,
      leadingIcon = {
        IconButton(onClick = { open = true }) {
          Icon(Icons.Default.Timer, contentDescription = "Select time")
        }
      },
      modifier = Modifier.fillMaxWidth().height(64.dp))

  if (open) {
    AlertDialog(
        onDismissRequest = { open = false },
        confirmButton = {
          TextButton(
              onClick = {
                onValueChange(LocalTime.of(state.hour, state.minute))
                open = false
              }) {
                Text("OK")
              }
        },
        dismissButton = { TextButton(onClick = { open = false }) { Text("Cancel") } },
        text = { TimePicker(state = state) })
  }
}

/**
 * A search field with a dropdown of suggestions.
 *
 * @param label the label for the text field
 * @param query the current search query
 * @param onQueryChange the callback to be invoked when the query changes
 * @param suggestions the list of suggestions to display
 * @param onSuggestionClick the callback to be invoked when a suggestion is clicked
 * @param getPrimaryText a function to extract the primary text from a suggestion
 * @param modifier the modifier to be applied to the text field
 * @param placeholder the placeholder text
 * @param isLoading whether the search is in a loading state
 * @param showWhenEmptyQuery whether to show suggestions when the query is empty
 * @param itemContent an optional custom composable for rendering each suggestion
 * @param emptyText the text to display when there are no suggestions
 */
@Composable
fun <T> SearchDropdownField(
    label: String,
    query: String,
    onQueryChange: (String) -> Unit,
    suggestions: List<T>,
    onSuggestionClick: (T) -> Unit,
    getPrimaryText: (T) -> String,
    modifier: Modifier = Modifier,
    placeholder: String = "",
    isLoading: Boolean = false,
    showWhenEmptyQuery: Boolean = false,
    itemContent: (@Composable (item: T) -> Unit)? = null,
    emptyText: String = "No results"
) {
  var expanded by remember { mutableStateOf(false) }

  Box(modifier = modifier) {
    OutlinedTextField(
        value = query,
        onValueChange = {
          onQueryChange(it)
          expanded = (showWhenEmptyQuery || it.isNotBlank())
        },
        label = { Text(label) },
        leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
        trailingIcon = {
          when {
            isLoading -> CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
            query.isNotEmpty() ->
                IconButton(
                    onClick = {
                      onQueryChange("")
                      expanded = false
                    }) {
                      Icon(Icons.Default.Close, contentDescription = "Clear")
                    }
          }
        },
        placeholder = { if (placeholder.isNotEmpty()) Text(placeholder) },
        singleLine = true,
        modifier = Modifier.fillMaxWidth().height(64.dp))

    val shouldShow =
        expanded && (isLoading || suggestions.isNotEmpty() || (query.isNotBlank() && !isLoading))

    if (shouldShow) {
      Popup(onDismissRequest = { expanded = false }, alignment = Alignment.TopStart) {
        Column(Modifier.fillMaxWidth().offset(y = 64.dp)) {
          Surface(
              modifier = Modifier.fillMaxWidth().clip(RoundedCornerShape(12.dp)),
              tonalElevation = 4.dp,
              shadowElevation = 4.dp) {
                when {
                  isLoading -> {
                    Row(
                        Modifier.fillMaxWidth().padding(16.dp),
                        horizontalArrangement = Arrangement.spacedBy(12.dp),
                        verticalAlignment = Alignment.CenterVertically) {
                          CircularProgressIndicator(Modifier.size(18.dp), strokeWidth = 2.dp)
                          Text("Searching…", style = MaterialTheme.typography.bodyMedium)
                        }
                  }
                  suggestions.isEmpty() -> {
                    Text(
                        emptyText,
                        modifier = Modifier.fillMaxWidth().padding(16.dp),
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant)
                  }
                  else -> {
                    LazyColumn(
                        modifier =
                            Modifier.fillMaxWidth().background(MaterialTheme.colorScheme.surface),
                        contentPadding = PaddingValues(vertical = 6.dp)) {
                          items(suggestions) { item ->
                            Row(
                                modifier =
                                    Modifier.fillMaxWidth()
                                        .clickable {
                                          onSuggestionClick(item)
                                          expanded = false
                                        }
                                        .padding(horizontal = 12.dp, vertical = 10.dp),
                                verticalAlignment = Alignment.CenterVertically) {
                                  if (itemContent != null) {
                                    itemContent(item)
                                  } else {
                                    Text(
                                        text = getPrimaryText(item),
                                        style = MaterialTheme.typography.bodyMedium,
                                        maxLines = 1,
                                        overflow = TextOverflow.Ellipsis)
                                  }
                                }
                          }
                        }
                  }
                }
              }
        }
      }
    }
  }
}

/**
 * A search field specifically for searching games.
 *
 * @param query the current search query
 * @param onQueryChange the callback to be invoked when the query changes
 * @param results the list of game results to display
 * @param onPick the callback to be invoked when a game is picked
 * @param modifier the modifier to be applied to the text field
 * @param isLoading whether the search is in a loading state
 * @param placeholder the placeholder text
 */
@Composable
fun GameSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Game>,
    onPick: (Game) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search games…"
) {
  SearchDropdownField(
      label = "Game",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      getPrimaryText = { it.name },
      isLoading = isLoading,
      placeholder = placeholder,
      modifier = modifier)
}

/**
 * A search field specifically for searching locations.
 *
 * @param query the current search query
 * @param onQueryChange the callback to be invoked when the query changes
 * @param results the list of location results to display
 * @param onPick the callback to be invoked when a location is picked
 * @param modifier the modifier to be applied to the text field
 * @param isLoading whether the search is in a loading state
 * @param placeholder the placeholder text
 */
@Composable
fun LocationSearchField(
    query: String,
    onQueryChange: (String) -> Unit,
    results: List<Location>,
    onPick: (Location) -> Unit,
    modifier: Modifier = Modifier,
    isLoading: Boolean = false,
    placeholder: String = "Search locations…"
) {
  SearchDropdownField(
      label = "Location",
      query = query,
      onQueryChange = onQueryChange,
      suggestions = results,
      onSuggestionClick = onPick,
      getPrimaryText = { it.name },
      isLoading = isLoading,
      placeholder = placeholder,
      modifier = modifier,
      itemContent = { loc ->
        Column(Modifier.fillMaxWidth()) {
          Text(
              text = loc.name,
              style = MaterialTheme.typography.bodyMedium,
              maxLines = 1,
              overflow = TextOverflow.Ellipsis)
          Text(
              text = "${"%.5f".format(loc.latitude)}, ${"%.5f".format(loc.longitude)}",
              style = MaterialTheme.typography.labelSmall,
              color = MaterialTheme.colorScheme.onSurfaceVariant)
        }
      })
}

/* =======================================================================
 * Previews
 * ======================================================================= */

/* A tiny host to give all previews a pleasant surface + padding */
@Composable
private fun PreviewHost(content: @Composable ColumnScope.() -> Unit) {
  AppTheme {
    Surface { Column(modifier = Modifier.fillMaxWidth().padding(16.dp), content = content) }
  }
}
//
/// * 1) SectionCard */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_SectionCard() = PreviewHost {
//  AppTheme {
//    SectionCard(
//        modifier =
//            Modifier.fillMaxWidth()
//                .clip(RoundedCornerShape(12.dp))
//                .background(MaterialTheme.colorScheme.surfaceVariant)) {
//          Text("This is a SectionCard")
//          Spacer(Modifier.height(8.dp))
//          Text("You can place any Column content here.")
//        }
//  }
// }
//
/// * 2) UnderlinedLabel */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_UnderlinedLabel() = PreviewHost {
//  AppTheme { UnderlinedLabel(text = "Underlined label") }
// }
//
/// * 3) LabeledTextField */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_LabeledTextField() = PreviewHost {
//  var text by remember { mutableStateOf("Hello") }
//  AppTheme {
//    LabeledTextField(
//        label = "Title",
//        value = text,
//        onValueChange = { text = it },
//        placeholder = "Type here…",
//        singleLine = true,
//        modifier = Modifier.fillMaxWidth())
//  }
// }
//
/// * 4) IconTextField */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_IconTextField() = PreviewHost {
//  var text by remember { mutableStateOf("") }
//  AppTheme {
//    IconTextField(
//        value = text,
//        onValueChange = { text = it },
//        placeholder = "With icons",
//        leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = null) },
//        trailingIcon = { Icon(Icons.Default.Close, contentDescription = null) },
//        modifier = Modifier.fillMaxWidth())
//  }
// }
//
/// * 5) CountBubble */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_CountBubble() = PreviewHost {
//  AppTheme {
//    Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
//      CountBubble(count = 0, modifier = Modifier.background(Color.Transparent))
//      CountBubble(count = 3, modifier = Modifier.background(Color.Transparent))
//      CountBubble(count = 42, modifier = Modifier.background(Color.Transparent))
//    }
//  }
// }
//
/// * 6) DiscretePillSlider */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_DiscretePillSlider() = PreviewHost {
//  var range by remember { mutableStateOf(2f..6f) }
//  AppTheme {
//    DiscretePillSlider(
//        range = 0f..10f,
//        values = range,
//        steps = 9,
//        onValuesChange = { start, end -> range = start..end },
//        surroundModifier = Modifier.fillMaxWidth(),
//        sliderModifier = Modifier.fillMaxWidth())
//  }
// }
//
/// * 7) ParticipantChip
// * NOTE: Replace the Account(...) construction with your project's real constructor.
// */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_ParticipantChip_Add() = PreviewHost {
//  val sampleAccount = Account("1", name = "Marco", email = "marco@epfl.ch", handle = "")
//  AppTheme {
//    ParticipantChip(
//        account = sampleAccount,
//        action = ParticipantAction.Add,
//        onClick = {},
//        modifier =
//            Modifier.fillMaxWidth()
//                .height(32.dp)
//                .clip(RoundedCornerShape(999.dp))
//                .background(MaterialTheme.colorScheme.surfaceVariant)
//                .padding(horizontal = 8.dp))
//  }
// }
//
// @Preview(showBackground = true)
// @Composable
// private fun Preview_ParticipantChip_Remove() = PreviewHost {
//  val sampleAccount = Account("1", name = "Marco", email = "marco@epfl.ch", handle = "")
//  AppTheme {
//    ParticipantChip(
//        account = sampleAccount,
//        action = ParticipantAction.Remove,
//        onClick = {},
//        modifier =
//            Modifier.fillMaxWidth()
//                .height(32.dp)
//                .clip(RoundedCornerShape(999.dp))
//                .background(MaterialTheme.colorScheme.surfaceVariant)
//                .padding(horizontal = 8.dp))
//  }
// }
//
/// * 8) TwoPerRowGrid (showing simple string items) */
// @Preview(showBackground = true, heightDp = 320)
// @Composable
// private fun Preview_TwoPerRowGrid() = PreviewHost {
//  val items = remember { (1..5).map { "Item $it" } }
//  AppTheme {
//    TwoPerRowGrid(
//        items = items,
//        key = { it },
//        modifier = Modifier.fillMaxWidth(),
//        rowsModifier = Modifier.fillMaxWidth()) { item, cellModifier ->
//          Box(
//              modifier =
//                  cellModifier
//                      .height(56.dp)
//                      .clip(RoundedCornerShape(10.dp))
//                      .background(MaterialTheme.colorScheme.secondaryContainer),
//              contentAlignment = Alignment.Center) {
//                Text(item, style = MaterialTheme.typography.bodyMedium)
//              }
//        }
//  }
// }
//
/// * 9) DatePickerDockedField */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_DatePickerDockedField() = PreviewHost {
//  var date by remember { mutableStateOf(LocalDate.now()) }
//  AppTheme {
//    DatePickerDockedField(value = date, onValueChange = { date = it })
//    Spacer(Modifier.height(8.dp))
//    Text("Selected: ${date.format(DateTimeFormatter.ofPattern("dd/MM/yyyy"))}")
//  }
// }
//
/// * 10) TimePickerField */
// @Preview(showBackground = true)
// @Composable
// private fun Preview_TimePickerField() = PreviewHost {
//  var time by remember { mutableStateOf(LocalTime.of(19, 0)) }
//  AppTheme {
//    TimePickerField(value = time, onValueChange = { time = it })
//    Spacer(Modifier.height(8.dp))
//    Text("Selected: ${time.format(DateTimeFormatter.ofPattern("HH:mm"))}")
//  }
// }
