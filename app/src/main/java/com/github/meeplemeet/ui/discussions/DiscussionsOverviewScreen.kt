// Class done almost all manually except some parts inspired from DiscussionScreen.kt
// and others were generated or modified using chatGPT-5 Thinking Extended
// Comments were generated by integrated copilot in Android Studio
package com.github.meeplemeet.ui.discussions

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ChatBubbleOutline
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.focus.FocusManager
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.RelationshipStatus
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.discussions.DiscussionViewModel
import com.github.meeplemeet.model.discussions.DiscussionsOverviewViewModel
import com.github.meeplemeet.model.offline.OfflineModeManager
import com.github.meeplemeet.ui.navigation.BottomBarWithVerification
import com.github.meeplemeet.ui.navigation.MeepleMeetScreen
import com.github.meeplemeet.ui.navigation.NavigationActions
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.theme.AppColors
import com.github.meeplemeet.ui.theme.Dimensions
import com.github.meeplemeet.ui.theme.MessagingColors
import com.google.firebase.Timestamp
import java.time.Duration
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlinx.coroutines.delay

/* ================================================================
 * Variables
 * ================================================================ */
const val DEFAULT_DISCUSSION_NAME = "Discussion"
const val NO_DISCUSSIONS_DEFAULT_TEXT = "No discussions yet"

private const val MAX_LINE = 1

object DiscussionOverviewTestTags {
  const val ADD_DISCUSSION_BUTTON = "Add Discussion"
  const val SEARCH_TEXT_FIELD = "DiscussionSearchTextField"
  const val SEARCH_CLEAR = "DiscussionSearchClear"
}

/* ================================================================
 * Screen: Discussions Overview
 * ================================================================ */

/**
 * Screen that shows an overview of all discussions the user is part of
 *
 * @param viewModel [DiscussionViewModel] instance to interact with Firestore
 * @param account The currently logged-in user ([Account])
 * @param navigation [NavigationActions] instance to navigate to other screens
 * @param onSelectDiscussion Callback function when a discussion is clicked
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscussionsOverviewScreen(
    account: Account,
    verified: Boolean,
    navigation: NavigationActions,
    viewModel: DiscussionsOverviewViewModel = viewModel(),
    unreadCount: Int,
    onClickAddDiscussion: () -> Unit = {},
    onSelectDiscussion: (Discussion) -> Unit = {},
) {
  val context = LocalContext.current
  val online by OfflineModeManager.hasInternetConnection.collectAsStateWithLifecycle()
  val offline by OfflineModeManager.offlineModeFlow.collectAsStateWithLifecycle()

  var searchQuery by rememberSaveable { mutableStateOf("") }

  val discussionPreviewsSorted =
      remember(account.previews, online, offline.discussions, searchQuery) {
        val previews =
            if (online) account.previews
            else account.previews.filter { offline.discussions.contains(it.value.uid) }
        val sorted = previews.values.sortedByDescending { it.lastMessageAt.toDate() }

        // Filter by search query
        if (searchQuery.isBlank()) {
          sorted
        } else {
          val query = searchQuery.trim().lowercase()
          sorted.filter { preview ->
            val discussion = offline.discussions[preview.uid]?.first
            val discussionName = discussion?.name ?: DEFAULT_DISCUSSION_NAME
            discussionName.lowercase().contains(query)
          }
        }
      }

  LaunchedEffect(account.previews) { viewModel.validatePreviews(account) }

  LaunchedEffect(account.previews) {
    account.previews.values
        .sortedBy { it.lastMessageAt }
        .forEach { OfflineModeManager.loadDiscussion(it.uid, context) {} }
  }

  val focusManager = androidx.compose.ui.platform.LocalFocusManager.current

  Scaffold(
      topBar = {
        DiscussionsTopBar(
            title = MeepleMeetScreen.DiscussionsOverview.title,
            showAddButton = verified,
            onAddDiscussionClick = onClickAddDiscussion,
            query = searchQuery,
            onQueryChange = { searchQuery = it },
            onClearQuery = { searchQuery = "" },
            focusManager = focusManager)
      },
      bottomBar = {
        BottomBarWithVerification(
            currentScreen = MeepleMeetScreen.DiscussionsOverview,
            verified = verified,
            unreadCount = unreadCount,
            onTabSelected = { screen -> navigation.navigateTo(screen) },
            onVerifyClick = { navigation.navigateTo(MeepleMeetScreen.Profile) })
      }) { innerPadding ->
        if (discussionPreviewsSorted.isEmpty()) {
          Box(
              modifier =
                  Modifier.fillMaxSize().padding(innerPadding).pointerInput(Unit) {
                    detectTapGestures(onTap = { focusManager.clearFocus() })
                  }) {
                EmptyDiscussionsListText()
              }
        } else {
          LazyColumn(
              modifier =
                  Modifier.fillMaxSize()
                      .background(MaterialTheme.colorScheme.background)
                      .padding(innerPadding)
                      .pointerInput(Unit) {
                        detectTapGestures(onTap = { focusManager.clearFocus() })
                      }) {
                items(discussionPreviewsSorted, key = { it.uid }) { preview ->
                  val discussion = offline.discussions[preview.uid]?.first
                  val discussionName = discussion?.name ?: DEFAULT_DISCUSSION_NAME

                  val senderId = preview.lastMessageSender
                  val isMe = (senderId == account.uid)
                  val senderBlocked = account.relationships[senderId] == RelationshipStatus.BLOCKED
                  val senderName by
                      produceState(
                          key1 = senderId,
                          initialValue = if (isMe) DiscussionCommons.YOU_SENDER_NAME else null) {
                            if (senderId.isNotBlank() && !isMe) {
                              viewModel.getAccount(senderId, context) { acc ->
                                value = acc?.name ?: "Unknown"
                              }
                            }
                          }

                  val msgText = buildString {
                    if (senderBlocked) append("Hidden: blocked sender")
                    else if (preview.lastMessage.isBlank()) {
                      append(DiscussionCommons.NO_MESSAGES_DEFAULT_TEXT)
                    } else {
                      if (isMe) append("${DiscussionCommons.YOU_SENDER_NAME}: ")
                      else if (!senderName.isNullOrBlank()) append("$senderName: ")
                      append(preview.lastMessage)
                    }
                  }

                  DiscussionCard(
                      discussionName = discussionName,
                      lastMsg = msgText,
                      lastMsgDate = preview.lastMessageAt,
                      unreadMsgCount = preview.unreadCount,
                      profilePictureUrl = discussion?.profilePictureUrl,
                      modifier =
                          Modifier.fillMaxWidth()
                              .testTag(DiscussionTestTags.discussionInfo(discussionName)),
                      onClick = { discussion?.let { onSelectDiscussion(it) } })
                }
              }
        }
      }
}

/* ================================================================
 * Composables
 * ================================================================ */

/** Composable that displays a message when there are no discussions */
@Composable
private fun EmptyDiscussionsListText() {
  Box(
      modifier =
          Modifier.fillMaxSize()
              .padding(Dimensions.Spacing.xxxLarge)
              .background(MaterialTheme.colorScheme.background),
      contentAlignment = Alignment.Center) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.medium)) {
              Icon(
                  imageVector = Icons.Default.ChatBubbleOutline,
                  contentDescription = null,
                  modifier = Modifier.size(Dimensions.IconSize.giant),
                  tint = MessagingColors.secondaryText.copy(alpha = 0.7f))
              Spacer(modifier = Modifier.height(Dimensions.Spacing.medium))
              Text(
                  text = NO_DISCUSSIONS_DEFAULT_TEXT,
                  style = MaterialTheme.typography.bodyLarge,
                  fontSize = Dimensions.TextSize.title,
                  color = MessagingColors.secondaryText,
                  fontWeight = FontWeight.Normal)
            }
      }
}

/**
 * Composable that displays a discussion card
 *
 * @param discussionName Discussion name
 * @param lastMsg Last message text
 * @param unreadMsgCount Number of unseen messages in this discussion
 * @param profilePictureUrl Optional URL to the discussion's profile picture
 * @param modifier Optional [Modifier] for this composable
 * @param onClick Function to operate when clicked
 */
@Composable
@Preview(showBackground = true)
fun DiscussionCard(
    modifier: Modifier = Modifier,
    discussionName: String = "Hello",
    lastMsg: String = "Hello world",
    lastMsgDate: Timestamp = Timestamp.now(),
    unreadMsgCount: Int = 1,
    profilePictureUrl: String? = null,
    onClick: () -> Unit = {}
) {
  Column(modifier = modifier) {
    Row(
        modifier =
            Modifier.fillMaxWidth()
                .clickable(onClick = onClick)
                .background(MaterialTheme.colorScheme.background)
                .padding(
                    horizontal = Dimensions.Padding.extraLarge,
                    vertical = Dimensions.Spacing.large),
        verticalAlignment = Alignment.CenterVertically) {
          // Profile picture
          ProfilePicture(
              profilePictureUrl = profilePictureUrl,
              size = Dimensions.AvatarSize.extraLarge,
              backgroundColor = AppColors.neutral)

          Spacer(modifier = Modifier.width(Dimensions.Spacing.large))

          // Text content
          Column(
              modifier = Modifier.weight(1f),
              verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.extraSmall)) {
                Text(
                    text = discussionName,
                    style = MaterialTheme.typography.bodyLarge,
                    fontSize = Dimensions.TextSize.title,
                    color = MaterialTheme.colorScheme.onSurface,
                    fontWeight = if (unreadMsgCount > 0) FontWeight.SemiBold else FontWeight.Normal,
                    maxLines = MAX_LINE,
                    overflow = TextOverflow.Ellipsis)

                Text(
                    text = lastMsg,
                    style = MaterialTheme.typography.bodyMedium,
                    fontSize = Dimensions.TextSize.body,
                    color = MessagingColors.secondaryText,
                    maxLines = MAX_LINE,
                    overflow = TextOverflow.Ellipsis)
              }

          Spacer(modifier = Modifier.width(Dimensions.Spacing.medium))

          // Time and unread badge column
          Column(
              horizontalAlignment = Alignment.End,
              verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.small)) {
                RelativeTimestampText(lastMsgDate, modifier = Modifier)

                if (unreadMsgCount > 0) {
                  Box(
                      modifier =
                          Modifier.size(Dimensions.CornerRadius.extraLarge)
                              .clip(CircleShape)
                              .background(MessagingColors.whatsappGreen),
                      contentAlignment = Alignment.Center) {
                        Text(
                            text = if (unreadMsgCount > 9) "9+" else unreadMsgCount.toString(),
                            style = MaterialTheme.typography.labelSmall,
                            fontSize = Dimensions.TextSize.tiny,
                            color = MessagingColors.messagingSurface,
                            fontWeight = FontWeight.Bold)
                      }
                }
              }
        }

    // Divider
    HorizontalDivider(
        modifier =
            Modifier.padding(
                start = Dimensions.AvatarSize.large.plus(Dimensions.Spacing.extraLarge)),
        color = MessagingColors.divider,
        thickness = Dimensions.DividerThickness.standard)
  }
}

fun Timestamp.toLocalDateTime(): LocalDateTime =
    LocalDateTime.ofInstant(this.toDate().toInstant(), ZoneId.systemDefault())

fun LocalDateTime.toRelativeTimeString(): String {
  val now = LocalDateTime.now()
  val duration = Duration.between(this, now)

  return when {
    duration.toMinutes() < 1 -> "now"
    duration.toMinutes() < 60 -> "${duration.toMinutes()} min ago"
    duration.toHours() < 24 -> "${duration.toHours()} h ago"
    duration.toDays() < 2 -> "yesterday"
    duration.toDays() < 7 -> this.format(DateTimeFormatter.ofPattern("EEE"))
    else -> this.format(DateTimeFormatter.ofPattern("MMM d"))
  }
}

@Composable
fun RelativeTimestampText(timestamp: Timestamp, modifier: Modifier) {
  val relativeText by
      produceState(initialValue = timestamp.toLocalDateTime().toRelativeTimeString()) {
        while (true) {
          value = timestamp.toLocalDateTime().toRelativeTimeString()
          delay(30_000L) // refresh every 30 sec
        }
      }

  Text(
      text = relativeText,
      color = MessagingColors.secondaryText,
      style = MaterialTheme.typography.labelSmall,
      fontSize = Dimensions.TextSize.medium,
      modifier = modifier)
}

/**
 * Top bar for the discussions overview screen, styled to match ChatsTopBar.
 *
 * @param title The title text shown in the top bar.
 * @param showAddButton Whether to show the add discussion button.
 * @param onAddDiscussionClick Callback when the add discussion button is clicked.
 * @param query The current search query.
 * @param onQueryChange Callback when the search query changes.
 * @param onClearQuery Callback to clear the search query.
 * @param focusManager FocusManager to handle clearing focus.
 */
@Composable
fun DiscussionsTopBar(
    title: String,
    showAddButton: Boolean,
    onAddDiscussionClick: () -> Unit,
    query: String,
    onQueryChange: (String) -> Unit,
    onClearQuery: () -> Unit,
    focusManager: FocusManager
) {
  Column(
      modifier =
          Modifier.fillMaxWidth()
              .background(AppColors.primary)
              .pointerInput(Unit) { detectTapGestures(onTap = { focusManager.clearFocus() }) }
              .padding(
                  horizontal = Dimensions.Padding.extraLarge,
                  vertical = Dimensions.Spacing.large)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically) {
              Text(
                  text = title,
                  color = AppColors.textIcons,
                  fontSize = Dimensions.TextSize.extraLarge,
                  fontWeight = FontWeight.Bold,
                  modifier = Modifier.testTag(NavigationTestTags.SCREEN_TITLE))

              if (showAddButton)
                  IconButton(
                      onClick = onAddDiscussionClick,
                      modifier =
                          Modifier.background(MessagingColors.whatsappGreen, CircleShape)
                              .size(Dimensions.AvatarSize.small)
                              .testTag(DiscussionOverviewTestTags.ADD_DISCUSSION_BUTTON)) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = "New discussion",
                            tint = AppColors.textIcons)
                      }
            }

        Spacer(modifier = Modifier.height(Dimensions.Spacing.large))

        BasicTextField(
            value = query,
            onValueChange = onQueryChange,
            modifier =
                Modifier.fillMaxWidth()
                    .height(Dimensions.ContainerSize.searchFieldHeight)
                    .background(
                        AppColors.secondary,
                        androidx.compose.foundation.shape.RoundedCornerShape(
                            Dimensions.CornerRadius.round))
                    .testTag(DiscussionOverviewTestTags.SEARCH_TEXT_FIELD),
            singleLine = true,
            textStyle =
                androidx.compose.ui.text.TextStyle(
                    color = AppColors.textIcons, fontSize = Dimensions.TextSize.subtitle),
            cursorBrush = androidx.compose.ui.graphics.SolidColor(AppColors.textIcons),
            decorationBox = { innerTextField ->
              Row(
                  modifier = Modifier.fillMaxSize().padding(horizontal = Dimensions.Padding.medium),
                  verticalAlignment = Alignment.CenterVertically) {
                    Icon(
                        imageVector = Icons.Default.Search,
                        contentDescription = "Search",
                        tint = AppColors.textIconsFade,
                        modifier = Modifier.size(Dimensions.IconSize.standard))
                    Spacer(modifier = Modifier.width(Dimensions.Spacing.small))
                    Box(modifier = Modifier.weight(1f)) {
                      if (query.isEmpty()) {
                        Text(
                            text = "Search",
                            color = AppColors.textIconsFade,
                            fontSize = Dimensions.TextSize.subtitle)
                      }
                      innerTextField()
                    }
                    if (query.isNotEmpty()) {
                      IconButton(
                          onClick = onClearQuery,
                          modifier =
                              Modifier.size(Dimensions.IconSize.large)
                                  .testTag(DiscussionOverviewTestTags.SEARCH_CLEAR)) {
                            Icon(
                                imageVector = Icons.Default.Close,
                                contentDescription = "Clear search",
                                tint = AppColors.textIconsFade,
                                modifier = Modifier.size(Dimensions.IconSize.standard))
                          }
                    }
                  }
            })
      }
}
