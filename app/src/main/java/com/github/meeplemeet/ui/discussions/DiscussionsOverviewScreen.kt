// Class done almost all manually except some parts inspired from DiscussionScreen.kt
// and others were generated or modified using chatGPT-5 Thinking Extended
// Comments were generated by integrated copilot in Android Studio
package com.github.meeplemeet.ui.discussions

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ChatBubbleOutline
import androidx.compose.material3.CenterAlignedTopAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.produceState
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.tooling.preview.Preview
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.discussions.DiscussionViewModel
import com.github.meeplemeet.model.discussions.DiscussionsOverviewViewModel
import com.github.meeplemeet.model.offline.OfflineModeManager
import com.github.meeplemeet.ui.navigation.BottomNavigationMenu
import com.github.meeplemeet.ui.navigation.MeepleMeetScreen
import com.github.meeplemeet.ui.navigation.NavigationActions
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.theme.AppColors
import com.github.meeplemeet.ui.theme.Dimensions
import com.github.meeplemeet.ui.theme.MessagingColors
import com.google.firebase.Timestamp
import java.time.Duration
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import kotlinx.coroutines.delay

/* ================================================================
 * Variables
 * ================================================================ */
const val DEFAULT_DISCUSSION_NAME = "Discussion"
const val NO_DISCUSSIONS_DEFAULT_TEXT = "No discussions yet"

private const val MAX_LINE = 1

object DiscussionOverviewTestTags {
  const val ADD_DISCUSSION_BUTTON = "Add Discussion"
}

/* ================================================================
 * Screen: Discussions Overview
 * ================================================================ */

/**
 * Screen that shows an overview of all discussions the user is part of
 *
 * @param viewModel [DiscussionViewModel] instance to interact with Firestore
 * @param account The currently logged-in user ([Account])
 * @param navigation [NavigationActions] instance to navigate to other screens
 * @param onSelectDiscussion Callback function when a discussion is clicked
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DiscussionsOverviewScreen(
    account: Account,
    navigation: NavigationActions,
    viewModel: DiscussionsOverviewViewModel = viewModel(),
    onClickAddDiscussion: () -> Unit = {},
    onSelectDiscussion: (Discussion) -> Unit = {},
) {
  val context = LocalContext.current
  val online by OfflineModeManager.hasInternetConnection.collectAsStateWithLifecycle()
  val offline by OfflineModeManager.offlineModeFlow.collectAsStateWithLifecycle()
  val discussionPreviewsSorted =
      remember(account.previews, online, offline.discussions) {
        val previews =
            if (online) account.previews
            else account.previews.filter { offline.discussions.contains(it.value.uid) }
        previews.values.sortedByDescending { it.lastMessageAt.toDate() }
      }

  LaunchedEffect(account.previews) { viewModel.validatePreviews(account) }

  LaunchedEffect(account.previews) {
    account.previews.values
        .sortedBy { it.lastMessageAt }
        .forEach { OfflineModeManager.loadDiscussion(it.uid, context) {} }
  }

  Scaffold(
      floatingActionButton = {
        FloatingActionButton(
            onClick = onClickAddDiscussion,
            contentColor = MessagingColors.messagingSurface,
            containerColor = MessagingColors.whatsappGreen,
            modifier = Modifier.testTag(DiscussionOverviewTestTags.ADD_DISCUSSION_BUTTON),
            shape = CircleShape) {
              Icon(
                  Icons.Default.Add,
                  contentDescription = "Create",
                  modifier = Modifier.size(Dimensions.IconSize.large))
            }
      },
      topBar = {
        CenterAlignedTopAppBar(
            title = {
              Text(
                  text = MeepleMeetScreen.DiscussionsOverview.title,
                  style = MaterialTheme.typography.titleLarge,
                  fontSize = Dimensions.TextSize.heading,
                  fontWeight = FontWeight.SemiBold,
                  color = MaterialTheme.colorScheme.onPrimary,
                  modifier = Modifier.testTag(NavigationTestTags.SCREEN_TITLE))
            })
      },
      bottomBar = {
        BottomNavigationMenu(
            currentScreen = MeepleMeetScreen.DiscussionsOverview,
            onTabSelected = { screen -> navigation.navigateTo(screen) })
      }) { innerPadding ->
        if (discussionPreviewsSorted.isEmpty()) {
          Box(modifier = Modifier.fillMaxSize().padding(innerPadding)) {
            EmptyDiscussionsListText()
          }
        } else {
          LazyColumn(
              modifier =
                  Modifier.fillMaxSize()
                      .background(MaterialTheme.colorScheme.background)
                      .padding(innerPadding)) {
                items(discussionPreviewsSorted, key = { it.uid }) { preview ->
                  val discussion = offline.discussions[preview.uid]?.first
                  val discussionName = discussion?.name ?: DEFAULT_DISCUSSION_NAME

                  val senderId = preview.lastMessageSender
                  val isMe = (senderId == account.uid)
                  val senderName by
                      produceState(
                          key1 = senderId,
                          initialValue = if (isMe) DiscussionCommons.YOU_SENDER_NAME else null) {
                            if (senderId.isNotBlank() && !isMe) {
                              viewModel.getAccount(senderId, context) { acc ->
                                value = acc?.name ?: "Unknown"
                              }
                            }
                          }

                  val msgText = buildString {
                    if (preview.lastMessage.isBlank()) {
                      append(DiscussionCommons.NO_MESSAGES_DEFAULT_TEXT)
                    } else {
                      if (isMe) append("${DiscussionCommons.YOU_SENDER_NAME}: ")
                      else if (!senderName.isNullOrBlank()) append("$senderName: ")
                      append(preview.lastMessage)
                    }
                  }

                  DiscussionCard(
                      discussionName = discussionName,
                      lastMsg = msgText,
                      lastMsgDate = preview.lastMessageAt,
                      unreadMsgCount = preview.unreadCount,
                      profilePictureUrl = discussion?.profilePictureUrl,
                      modifier =
                          Modifier.fillMaxWidth()
                              .testTag(DiscussionTestTags.discussionInfo(discussionName)),
                      onClick = { discussion?.let { onSelectDiscussion(it) } })
                }
              }
        }
      }
}

/* ================================================================
 * Composables
 * ================================================================ */

/** Composable that displays a message when there are no discussions */
@Composable
private fun EmptyDiscussionsListText() {
  Box(
      modifier =
          Modifier.fillMaxSize()
              .padding(Dimensions.Spacing.xxxLarge)
              .background(MaterialTheme.colorScheme.background),
      contentAlignment = Alignment.Center) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.medium)) {
              Icon(
                  imageVector = Icons.Default.ChatBubbleOutline,
                  contentDescription = null,
                  modifier = Modifier.size(Dimensions.IconSize.giant),
                  tint = MessagingColors.secondaryText.copy(alpha = 0.7f))
              Spacer(modifier = Modifier.height(Dimensions.Spacing.medium))
              Text(
                  text = NO_DISCUSSIONS_DEFAULT_TEXT,
                  style = MaterialTheme.typography.bodyLarge,
                  fontSize = Dimensions.TextSize.title,
                  color = MessagingColors.secondaryText,
                  fontWeight = FontWeight.Normal)
            }
      }
}

/**
 * Composable that displays a discussion card
 *
 * @param discussionName Discussion name
 * @param lastMsg Last message text
 * @param unreadMsgCount Number of unseen messages in this discussion
 * @param profilePictureUrl Optional URL to the discussion's profile picture
 * @param modifier Optional [Modifier] for this composable
 * @param onClick Function to operate when clicked
 */
@Composable
@Preview(showBackground = true)
public fun DiscussionCard(
    modifier: Modifier = Modifier,
    discussionName: String = "Hello",
    lastMsg: String = "Hello world",
    lastMsgDate: Timestamp = Timestamp.now(),
    unreadMsgCount: Int = 1,
    profilePictureUrl: String? = null,
    onClick: () -> Unit = {}
) {
  Column(modifier = modifier) {
    Row(
        modifier =
            Modifier.fillMaxWidth()
                .clickable(onClick = onClick)
                .background(MaterialTheme.colorScheme.background)
                .padding(
                    horizontal = Dimensions.Padding.extraLarge,
                    vertical = Dimensions.Spacing.large),
        verticalAlignment = Alignment.CenterVertically) {
          // Profile picture
          ProfilePicture(
              profilePictureUrl = profilePictureUrl,
              size = Dimensions.AvatarSize.extraLarge,
              backgroundColor = AppColors.neutral)

          Spacer(modifier = Modifier.width(Dimensions.Spacing.large))

          // Text content
          Column(
              modifier = Modifier.weight(1f),
              verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.extraSmall)) {
                Text(
                    text = discussionName,
                    style = MaterialTheme.typography.bodyLarge,
                    fontSize = Dimensions.TextSize.title,
                    color = MaterialTheme.colorScheme.onSurface,
                    fontWeight = if (unreadMsgCount > 0) FontWeight.SemiBold else FontWeight.Normal,
                    maxLines = MAX_LINE,
                    overflow = TextOverflow.Ellipsis)

                Text(
                    text = lastMsg,
                    style = MaterialTheme.typography.bodyMedium,
                    fontSize = Dimensions.TextSize.body,
                    color = MessagingColors.secondaryText,
                    maxLines = MAX_LINE,
                    overflow = TextOverflow.Ellipsis)
              }

          Spacer(modifier = Modifier.width(Dimensions.Spacing.medium))

          // Time and unread badge column
          Column(
              horizontalAlignment = Alignment.End,
              verticalArrangement = Arrangement.spacedBy(Dimensions.Spacing.small)) {
                RelativeTimestampText(lastMsgDate, modifier = Modifier)

                if (unreadMsgCount > 0) {
                  Box(
                      modifier =
                          Modifier.size(Dimensions.CornerRadius.extraLarge)
                              .clip(CircleShape)
                              .background(MessagingColors.whatsappGreen),
                      contentAlignment = Alignment.Center) {
                        Text(
                            text = if (unreadMsgCount > 9) "9+" else unreadMsgCount.toString(),
                            style = MaterialTheme.typography.labelSmall,
                            fontSize = Dimensions.TextSize.tiny,
                            color = MessagingColors.messagingSurface,
                            fontWeight = FontWeight.Bold)
                      }
                }
              }
        }

    // Divider
    HorizontalDivider(
        modifier =
            Modifier.padding(
                start = Dimensions.AvatarSize.large.plus(Dimensions.Spacing.extraLarge)),
        color = MessagingColors.divider,
        thickness = Dimensions.DividerThickness.standard)
  }
}

fun Timestamp.toLocalDateTime(): LocalDateTime =
    LocalDateTime.ofInstant(this.toDate().toInstant(), ZoneId.systemDefault())

fun LocalDateTime.toRelativeTimeString(): String {
  val now = LocalDateTime.now()
  val duration = Duration.between(this, now)

  return when {
    duration.toMinutes() < 1 -> "now"
    duration.toMinutes() < 60 -> "${duration.toMinutes()} min ago"
    duration.toHours() < 24 -> "${duration.toHours()} h ago"
    duration.toDays() < 2 -> "yesterday"
    duration.toDays() < 7 -> this.format(DateTimeFormatter.ofPattern("EEE"))
    else -> this.format(DateTimeFormatter.ofPattern("MMM d"))
  }
}

@Composable
fun RelativeTimestampText(timestamp: Timestamp, modifier: Modifier) {
  val relativeText by
      produceState(initialValue = timestamp.toLocalDateTime().toRelativeTimeString()) {
        while (true) {
          value = timestamp.toLocalDateTime().toRelativeTimeString()
          delay(30_000L) // refresh every 30 sec
        }
      }

  Text(
      text = relativeText,
      color = MessagingColors.secondaryText,
      style = MaterialTheme.typography.labelSmall,
      fontSize = Dimensions.TextSize.medium,
      modifier = modifier)
}
