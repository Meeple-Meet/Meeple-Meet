// This file was generated by ChatGPT-5 Thinking Extend
// The ideas to what to test were given to the LLM and it generated the test code
// Refinements to handle errors were made manually
package com.github.meeplemeet.ui

import androidx.compose.runtime.*
import androidx.compose.ui.semantics.SemanticsActions
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import com.github.meeplemeet.model.repositories.FirestoreRepository
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Discussion
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.ui.theme.AppTheme
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.mockk
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import org.junit.Before
import org.junit.Rule
import org.junit.Test

class CreateSessionScreenTest {

  @get:Rule val compose = createComposeRule()

  private lateinit var repository: FirestoreRepository
  private lateinit var viewModel: FirestoreViewModel

  private val me = Account(uid = "user1", handle = "marco", name = "Marco", email = "m@x")
  private val bob = Account(uid = "u2", handle = "alexandre", name = "Alexandre", email = "a@x")
  private val zoe = Account(uid = "u3", handle = "dany", name = "Dany", email = "d@x")

  private val discussionId = "disc1"

  private lateinit var injectedDiscussionFlow: MutableStateFlow<Discussion?>
  private lateinit var baseDiscussion: Discussion

  @Before
  fun setUp() {
    repository = mockk(relaxed = true)
    coEvery { repository.getAccount("u2") } returns bob
    coEvery { repository.getAccount("u3") } returns zoe
    coEvery { repository.getAccount("user1") } returns me

    viewModel = FirestoreViewModel(repository)

    baseDiscussion =
        Discussion(
            uid = discussionId,
            name = "Board Night",
            description = "",
            messages = emptyList(),
            participants = listOf(me.uid, bob.uid, zoe.uid),
            admins = listOf(me.uid),
            creatorId = me.uid)

    val discussionFlowsField = viewModel::class.java.getDeclaredField("discussionFlows")
    discussionFlowsField.isAccessible = true
    @Suppress("UNCHECKED_CAST")
    val map = discussionFlowsField.get(viewModel) as MutableMap<String, StateFlow<Discussion?>>
    injectedDiscussionFlow = MutableStateFlow(baseDiscussion)
    map[discussionId] = injectedDiscussionFlow
  }

  private fun allInputs() = compose.onAllNodes(hasSetTextAction())

  private fun titleInput() = allInputs()[0]

  private fun gameInput() = allInputs()[1]

  private fun locationInput() = allInputs()[2]

  /* ---- Helpers ---- */
  private fun buttonWithLabel(text: String) =
      compose.onNode(
          hasClickAction().and(hasAnyDescendant(hasText(text, substring = false))),
          useUnmergedTree = true)

  private fun createBtn() = buttonWithLabel("Create Session")

  private fun discardBtn() = buttonWithLabel("Discard")

  private fun backBtn() = compose.onNodeWithContentDescription("Back")

  private fun searchIcon() = compose.onNodeWithContentDescription("Search")

  private fun pickBtn() = compose.onNodeWithText("Pick")

  private fun setContent(onCreate: (SessionForm) -> Unit = {}, onBack: () -> Unit = {}) {
    compose.setContent {
      AppTheme {
        CreateSessionScreen(
            viewModel = viewModel,
            currentUser = me,
            discussionId = discussionId,
            onCreate = onCreate,
            onBack = onBack)
      }
    }
  }

  /* ---- Tests ---- */
  @Test
  fun participants_exclude_current_user_from_candidates() {
    setContent()
    compose.waitForIdle()
    compose.onAllNodesWithText("Marco", substring = false).assertCountEquals(1)
  }

  @Test
  fun flow_with_only_me_has_no_candidates() {
    injectedDiscussionFlow.value = baseDiscussion.copy(participants = listOf(me.uid))
    setContent()
    compose.waitForIdle()
    compose.onAllNodesWithText("Alexandre").assertCountEquals(0)
    compose.onAllNodesWithText("Dany").assertCountEquals(0)
  }

  @Test
  fun flow_update_triggers_fetch_for_new_participant_uid() {
    val fetchedU4 = AtomicBoolean(false)
    coEvery { repository.getAccount("u4") } coAnswers
        {
          fetchedU4.set(true)
          Account(uid = "u4", handle = "newb", name = "Newbie", email = "n@x")
        }

    setContent()

    injectedDiscussionFlow.value =
        baseDiscussion.copy(participants = listOf(me.uid, bob.uid, zoe.uid, "u4"))

    compose.waitUntil(3_000) { fetchedU4.get() }
    coVerify(exactly = 1) { repository.getAccount("u4") }
  }

  @Test
  fun duplicates_in_participants_do_not_duplicate_candidates() {
    injectedDiscussionFlow.value =
        baseDiscussion.copy(participants = listOf(me.uid, bob.uid, bob.uid, zoe.uid, bob.uid))
    setContent()
    compose.waitForIdle()
    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)
  }

  @Test
  fun create_button_calls_onCreate_with_defaults_when_form_blank() {
    injectedDiscussionFlow.value = baseDiscussion.copy(participants = listOf(me.uid))
    var captured: SessionForm? = null
    setContent(onCreate = { captured = it })

    createBtn().performClick()
    compose.waitForIdle()

    val f = checkNotNull(captured)
    assert(f.title.isBlank())
    assert(f.proposedGame.isBlank())
    assert(f.locationText.isBlank())
    assert(f.minPlayers == 1 && f.maxPlayers == 1)
    assert(f.participants.map { it.uid } == listOf(me.uid))
  }

  @Test
  fun game_section_label_and_search_button_present() {
    setContent()
    compose.waitForIdle()
    compose.onAllNodesWithText("$GAME_SECTION_NAME:").onFirst().assertExists()
    gameInput().performTextInput("Cascadia")
    searchIcon().assertIsDisplayed().performClick()
  }

  @Test
  fun discard_calls_onBack_without_asserting_field_values() {
    val backCalled = AtomicBoolean(false)
    setContent(onBack = { backCalled.set(true) })

    discardBtn().performSemanticsAction(SemanticsActions.OnClick)
    compose.waitUntil(2_000) { backCalled.get() }
  }

  @Test
  fun back_button_triggers_callback() {
    val back = AtomicBoolean(false)
    setContent(onBack = { back.set(true) })
    backBtn().performClick()
    assert(back.get())
  }

  @Test
  fun organisation_section_pick_button_click_is_safe() {
    setContent()
    compose.waitForIdle()
    pickBtn().assertIsDisplayed().performClick()
  }

  @Test
  fun typing_title_game_location_then_create_captures_values() {
    injectedDiscussionFlow.value = baseDiscussion.copy(participants = listOf(me.uid))
    var captured: SessionForm? = null
    setContent(onCreate = { captured = it })

    titleInput().performTextInput("Friday Night Board Game Jam")
    gameInput().performTextInput("Root")
    locationInput().performTextInput("Table A1")

    createBtn().performClick()
    compose.waitForIdle()

    val f = checkNotNull(captured)
    assert(f.title == "Friday Night Board Game Jam")
    assert(f.proposedGame == "Root")
    assert(f.locationText == "Table A1")
  }

  @Test
  fun clicking_self_chip_does_not_remove_me_and_fetches_others_once() {
    setContent()
    compose.waitForIdle()

    coVerify(atLeast = 1) { repository.getAccount("u2") }
    coVerify(atLeast = 1) { repository.getAccount("u3") }

    compose.onNodeWithText("Marco").assertIsDisplayed().performClick()
    compose.onNodeWithText("Marco").assertIsDisplayed()

    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)
  }

  @Test
  fun add_then_remove_participant_keeps_single_visible_copy() {
    setContent()
    compose.waitUntil(5_000) {
      compose.onAllNodesWithText("Alexandre").fetchSemanticsNodes().isNotEmpty()
    }

    compose.onAllNodesWithText("Alexandre").onLast().performClick()
    compose.runOnIdle {}

    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)

    compose.onAllNodesWithText("Alexandre").onFirst().performClick()
    compose.runOnIdle {}

    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)
  }

  @Test
  fun null_discussion_shows_no_candidates_and_does_not_fetch() {
    injectedDiscussionFlow.value = null

    setContent()
    compose.waitForIdle()

    coVerify(exactly = 0) { repository.getAccount("u2") }
    coVerify(exactly = 0) { repository.getAccount("u3") }

    compose.onAllNodesWithText("Alexandre").assertCountEquals(0)
    compose.onAllNodesWithText("Dany").assertCountEquals(0)

    titleInput().performTextInput("Solo Setup")
    locationInput().performTextInput("Open Table")
    compose.onAllNodesWithText("Solo Setup").onFirst().assertExists()
    compose.onAllNodesWithText("Open Table").onFirst().assertExists()
  }

  @Test
  fun game_section_calls_onSearchClick_and_updates_query() {
    val clicked = AtomicBoolean(false)
    val lastQuery = AtomicReference<String>("")

    compose.setContent {
      AppTheme {
        var q by remember { mutableStateOf("Root") }
        GameSection(
            query = q,
            onQueryChange = {
              q = it
              lastQuery.set(it)
            },
            onSearchClick = { clicked.set(true) },
            title = GAME_SECTION_NAME,
            placeholder = GAME_SEARCH_PLACEHOLDER)
      }
    }

    compose.onAllNodesWithText("$GAME_SECTION_NAME:").onFirst().assertExists()
    compose.onAllNodes(hasSetTextAction()).onFirst().performTextInput(" (Expansion)")
    compose.onNodeWithContentDescription("Search").performClick()

    assert(clicked.get())
    assert(lastQuery.get().contains("Expansion"))
  }

  @Test
  fun organisation_section_onPickLocation_hidden_when_null() {
    compose.setContent {
      AppTheme {
        OrganisationSection(
            date = null,
            time = null,
            locationText = "",
            onDateChange = {},
            onTimeChange = {},
            onLocationChange = {},
            onPickLocation = null,
            title = ORGANISATION_SECTION_NAME)
      }
    }
    compose.onAllNodesWithText("Pick").assertCountEquals(0)
  }

  @Test
  fun organisation_section_location_change_callback_receives_text_and_pick_invokes() {
    val picked = AtomicBoolean(false)
    val lastLocation = AtomicReference<String>("")

    compose.setContent {
      AppTheme {
        var loc by remember { mutableStateOf("") }
        OrganisationSection(
            date = null,
            time = null,
            locationText = loc,
            onDateChange = {},
            onTimeChange = {},
            onLocationChange = {
              loc = it
              lastLocation.set(it)
            },
            onPickLocation = { picked.set(true) },
            title = ORGANISATION_SECTION_NAME)
      }
    }

    compose.onAllNodes(hasSetTextAction()).onFirst().performTextInput("Cafe Meeple")
    compose.onAllNodesWithText("Cafe Meeple").onFirst().assertExists()

    compose.onNodeWithText("Pick").assertIsDisplayed().performClick()
    assert(picked.get())
    assert(lastLocation.get() == "Cafe Meeple")
  }

  @Test
  fun participants_section_add_remove_and_self_protection_in_component() {
    val meAcc = me
    val all = listOf(meAcc, bob, zoe)

    compose.setContent {
      AppTheme {
        var min by remember { mutableStateOf(1) }
        var max by remember { mutableStateOf(2) }
        var selected by remember { mutableStateOf(listOf(meAcc)) }

        ParticipantsSection(
            currentUserId = meAcc.uid,
            selected = selected,
            allCandidates = all,
            minPlayers = min,
            maxPlayers = max,
            onMinMaxChange = { a, b ->
              min = a
              max = b
            },
            onAdd = { a -> selected = (selected + a).distinctBy { it.uid } },
            onRemove = { a -> selected = selected.filterNot { it.uid == a.uid } },
            minSliderNumber = MIN_SLIDER_NUMBER,
            maxSliderNumber = MAX_SLIDER_NUMBER,
            sliderSteps = SLIDER_STEPS,
            mainSectionTitle = PARTICIPANT_SECTION_NAME,
            sliderDescription = SLIDER_DESCRIPTION)
      }
    }

    compose.onAllNodesWithText("Marco").assertCountEquals(1)
    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)
    compose.onAllNodesWithText("Dany").assertCountEquals(1)

    compose.onAllNodesWithText("Alexandre").onLast().performClick()
    compose.runOnIdle {}
    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)

    compose.onNodeWithText("Marco").performClick()
    compose.onAllNodesWithText("Marco").assertCountEquals(1)

    compose.onAllNodesWithText("Alexandre").onFirst().performClick()
    compose.onAllNodesWithText("Alexandre").assertCountEquals(1)
  }
}
