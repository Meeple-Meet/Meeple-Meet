// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
// It was then optimized using LLM and manual iterations to cover more paths in less tests
package com.github.meeplemeet.ui

import androidx.compose.ui.test.ExperimentalTestApi
import androidx.compose.ui.test.assertCountEquals
import androidx.compose.ui.test.assertHasClickAction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsEnabled
import androidx.compose.ui.test.assertIsNotEnabled
import androidx.compose.ui.test.assertTextEquals
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onAllNodesWithTag
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextClearance
import androidx.compose.ui.test.performTextInput
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.sessions.SessionEditViewModel
import com.github.meeplemeet.model.shared.location.Location
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.sessions.SessionCreationTestTags
import com.github.meeplemeet.ui.sessions.SessionEditNumbers.MAX_EDIT_TITLE_LENGTH
import com.github.meeplemeet.ui.sessions.SessionEditScreen
import com.github.meeplemeet.ui.sessions.SessionEditTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import com.google.firebase.Timestamp
import java.util.Date
import kotlinx.coroutines.runBlocking
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test

@OptIn(ExperimentalTestApi::class)
class SessionEditScreenTest : FirestoreTests() {

  @get:Rule val composeTestRule = createComposeRule()
  @get:Rule val ck = Checkpoint.Rule()

  private fun checkpoint(name: String, block: () -> Unit) = ck.ck(name, block)

  private lateinit var admin: Account
  private lateinit var member: Account
  private lateinit var extra: Account

  private lateinit var baseDiscussionWithSession: Discussion
  private lateinit var sessionVM: SessionEditViewModel

  @Before
  fun setUp() = runBlocking {
    val suffix = System.currentTimeMillis()

    // Core accounts
    admin =
        accountRepository.createAccount(
            userHandle = "edit_admin_$suffix",
            name = "Edit Admin",
            email = "edit_admin_$suffix@meeple.test",
            photoUrl = null)

    member =
        accountRepository.createAccount(
            userHandle = "edit_member_$suffix",
            name = "Edit Member",
            email = "edit_member_$suffix@meeple.test",
            photoUrl = null)

    extra =
        accountRepository.createAccount(
            userHandle = "edit_extra_$suffix",
            name = "Edit Extra",
            email = "edit_extra_$suffix@meeple.test",
            photoUrl = null)

    val participantIds = listOf(admin.uid, member.uid, extra.uid)

    // Discussion with participants
    val discussion =
        discussionRepository.createDiscussion(
            name = "Edit Session Discussion",
            description = "Discussion for SessionEditScreen tests",
            creatorId = admin.uid,
            participants = participantIds)

    // Ensure admin rights
    discussionRepository.addAdminToDiscussion(discussion, admin.uid)

    // Session in the future with only admin + member as participants
    val futureMillis = System.currentTimeMillis() + 7L * 24 * 60 * 60 * 1000
    val futureTimestamp = Timestamp(Date(futureMillis))

    sessionRepository.createSession(
        discussionId = discussion.uid,
        name = "Editable Session",
        gameId = "",
        gameName = "",
        date = futureTimestamp,
        location = Location(name = "Meeple Café"),
        rentalId = null,
        admin.uid,
        member.uid)

    baseDiscussionWithSession = discussionRepository.getDiscussion(discussion.uid)

    sessionVM = SessionEditViewModel()
  }

  // -------------------------------------------------------------------------
  // Helper
  // -------------------------------------------------------------------------

  private fun setContent(
      account: Account = admin,
      discussion: Discussion = baseDiscussionWithSession,
      viewModel: SessionEditViewModel = sessionVM,
      onBack: () -> Unit = {},
  ) {
    composeTestRule.setContent {
      AppTheme {
        SessionEditScreen(
            account = account,
            discussion = discussion,
            viewModel = viewModel,
            onBack = onBack,
        )
      }
    }
  }

  // -------------------------------------------------------------------------
  // TEST 1 – Fallback when discussion has no session
  // -------------------------------------------------------------------------

  @Test
  fun sessionEdit_withoutSession_showsFallbackMessageAndBackWorks() = runBlocking {
    val discussionWithoutSession =
        discussionRepository.createDiscussion(
            name = "No Session Discussion",
            description = "Used for SessionEditScreen fallback test",
            creatorId = admin.uid,
            participants = listOf(admin.uid))

    discussionRepository.addAdminToDiscussion(discussionWithoutSession, admin.uid)

    var backCalled = false

    setContent(
        account = admin,
        discussion = discussionWithoutSession,
        viewModel = SessionEditViewModel(),
        onBack = { backCalled = true })

    // No need to wait on a TOP_BAR tag (it doesn't exist); composition is synchronous here.

    checkpoint("Shows 'No session to edit' message") {
      composeTestRule.onNodeWithText("No session to edit").assertIsDisplayed()
    }

    checkpoint("Top bar shows Edit Session title") {
      composeTestRule.onNodeWithText("Edit Session").assertIsDisplayed()
    }

    checkpoint("Back button is wired") {
      composeTestRule.onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON).performClick()
      assertTrue(backCalled)
    }
  }

  // -------------------------------------------------------------------------
  // TEST 2 – Admin smoke test: core sections & buttons
  // -------------------------------------------------------------------------

  @Test
  fun sessionEdit_adminSmoke_showsCoreSectionsAndButtons() {
    var backCalled = false

    setContent(onBack = { backCalled = true })

    // Wait until main content is on screen
    composeTestRule.waitUntilAtLeastOneExists(
        hasTestTag(SessionEditTestTags.CONTENT_COLUMN), timeoutMillis = 10_000)

    checkpoint("Scaffold and snackbar host are present") {
      composeTestRule.onNodeWithTag(SessionEditTestTags.SCAFFOLD).assertExists()

      composeTestRule.onNodeWithTag(SessionEditTestTags.SNACKBAR_HOST).assertExists()
    }

    checkpoint("Organisation section and title field are visible") {
      composeTestRule
          .onNodeWithTag(SessionEditTestTags.ORG_SECTION, useUnmergedTree = true)
          .assertIsDisplayed()
      composeTestRule
          .onNodeWithTag(SessionCreationTestTags.FORM_TITLE_FIELD, useUnmergedTree = true)
          .assertIsDisplayed()
          .assertHasClickAction()
    }

    checkpoint("Participants section and search bar are visible") {
      composeTestRule
          .onNodeWithTag(SessionEditTestTags.PARTICIPANTS_SECTION, useUnmergedTree = true)
          .assertIsDisplayed()
      composeTestRule
          .onNodeWithTag(SessionEditTestTags.PARTICIPANT_SEARCH, useUnmergedTree = true)
          .assertIsDisplayed()
    }

    checkpoint("Bottom button row shows Delete and Save buttons") {
      composeTestRule
          .onNodeWithTag(SessionEditTestTags.BUTTON_ROW, useUnmergedTree = true)
          .assertIsDisplayed()

      composeTestRule
          .onNodeWithTag(SessionEditTestTags.DELETE_BUTTON, useUnmergedTree = true)
          .assertIsDisplayed()
          .assertHasClickAction()

      composeTestRule
          .onNodeWithTag(SessionEditTestTags.SAVE_BUTTON, useUnmergedTree = true)
          .assertIsDisplayed()
          .assertHasClickAction()
          .assertIsEnabled()
    }

    checkpoint("Back is triggered via top bar") {
      composeTestRule.onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON).performClick()
      assertTrue(backCalled)
    }
  }

  // -------------------------------------------------------------------------
  // TEST 3 – Title validation: max length + Save enabled/disabled
  // -------------------------------------------------------------------------

  @Test
  fun sessionEdit_titleValidation_clampsLength_andTogglesSaveEnabled() {
    setContent()

    // Wait for title field
    composeTestRule.waitUntilAtLeastOneExists(
        hasTestTag(SessionCreationTestTags.FORM_TITLE_FIELD), timeoutMillis = 10_000)

    val titleField =
        composeTestRule.onNodeWithTag(
            SessionCreationTestTags.FORM_TITLE_FIELD, useUnmergedTree = true)
    val saveButton =
        composeTestRule.onNodeWithTag(SessionEditTestTags.SAVE_BUTTON, useUnmergedTree = true)

    checkpoint("Clearing title disables Save button") {
      titleField.performTextClearance()
      saveButton.assertIsNotEnabled()
    }

    checkpoint("Typing new valid title enables Save button") {
      val newTitle = "New Title for Session"
      titleField.performTextInput(newTitle)
      titleField.assertTextEquals(newTitle)
      saveButton.assertIsEnabled()
    }

    checkpoint("Too-long input is rejected and previous value is kept") {
      // Clear so previous state is known (empty)
      titleField.performTextClearance()

      val longTitle = "X".repeat(MAX_EDIT_TITLE_LENGTH + 10)

      // Because the composable only accepts values with length <= MAX_EDIT_TITLE_LENGTH,
      // passing an overly-long value in a *single* update causes it to be ignored.
      titleField.performTextInput(longTitle)

      // Current implementation: value stays as the last accepted one (here: empty string)
      titleField.assertTextEquals("")
    }
  }

  // -------------------------------------------------------------------------
  // TEST 4 – Participant changes: added/removed only on Save, and self-removal
  // -------------------------------------------------------------------------

  @Test
  fun sessionEdit_save_appliesParticipantDiff_andPreventsSelfRemoval() {
    var backCalled = false

    setContent(onBack = { backCalled = true })

    // Wait for participants section to be rendered
    composeTestRule.waitUntilAtLeastOneExists(
        hasTestTag(SessionEditTestTags.PARTICIPANTS_SECTION), timeoutMillis = 10_000)

    checkpoint("Initial repository participants are admin + member") {
      runBlocking {
        val discussion = discussionRepository.getDiscussion(baseDiscussionWithSession.uid)
        val participants = discussion.session?.participants?.sorted() ?: emptyList()
        assertEquals(listOf(admin.uid, member.uid).sorted(), participants)
      }
    }

    checkpoint("Admin cannot be removed via UI control") {
      // There must be no 'remove' control for the admin
      composeTestRule
          .onAllNodesWithTag("remove:${admin.name}", useUnmergedTree = true)
          .assertCountEquals(0)
    }

    // Ensure the extra + member toggle nodes are present before interacting
    composeTestRule.waitUntilAtLeastOneExists(
        hasTestTag("remove:${extra.name}"), timeoutMillis = 15_000)
    composeTestRule.waitUntilAtLeastOneExists(
        hasTestTag("remove:${member.name}"), timeoutMillis = 15_000)

    // Simulate user editing participants in the UI (but not saving yet):
    // - add "extra"
    // - remove "member"
    composeTestRule.onNodeWithTag("remove:${extra.name}", useUnmergedTree = true).performClick()
    composeTestRule.onNodeWithTag("remove:${member.name}", useUnmergedTree = true).performClick()

    checkpoint("Repository participants unchanged before Save (still admin + member)") {
      runBlocking {
        val discussion = discussionRepository.getDiscussion(baseDiscussionWithSession.uid)
        val participants = discussion.session?.participants?.sorted() ?: emptyList()
        assertEquals(listOf(admin.uid, member.uid).sorted(), participants)
      }
    }

    // Now click Save
    composeTestRule
        .onNodeWithTag(SessionEditTestTags.SAVE_BUTTON, useUnmergedTree = true)
        .assertIsEnabled()
        .performClick()

    // Wait until Firestore reflects the new participants (admin + extra)
    composeTestRule.waitUntil(timeoutMillis = 15_000) {
      runBlocking {
        val discussion = discussionRepository.getDiscussion(baseDiscussionWithSession.uid)
        val participants = discussion.session?.participants?.sorted() ?: emptyList()
        participants == listOf(admin.uid, extra.uid).sorted()
      }
    }

    checkpoint("Repository participants updated after Save (admin + extra)") {
      runBlocking {
        val discussion = discussionRepository.getDiscussion(baseDiscussionWithSession.uid)
        val participants = discussion.session?.participants?.sorted() ?: emptyList()
        assertEquals(listOf(admin.uid, extra.uid).sorted(), participants)
      }
    }

    checkpoint("Back is called after saving") { assertTrue(backCalled) }
  }
}
