/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.repositories.FirestoreHandlesRepository
import com.github.meeplemeet.model.repositories.FirestoreRepository
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.viewmodels.FirestoreHandlesViewModel
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.ui.navigation.NavigationActions
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.utils.FirestoreTests
import io.mockk.coVerify
import io.mockk.mockk
import java.util.UUID
import kotlinx.coroutines.runBlocking
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class DiscussionAddScreenTest : FirestoreTests() {

  @get:Rule val compose = createComposeRule()
  private val nav: NavigationActions = mockk(relaxed = true)

  private lateinit var repo: FirestoreRepository
  private lateinit var handlesRepo: FirestoreHandlesRepository
  private lateinit var vm: FirestoreViewModel
  private lateinit var handlesVm: FirestoreHandlesViewModel
  private lateinit var me: Account

  private val createdAccounts = mutableListOf<Account>()
  private val createdHandles = mutableListOf<String>()
  private val report = linkedMapOf<String, Boolean>()

  private inline fun checkpoint(name: String, crossinline block: () -> Unit) {
    runCatching { block() }.onSuccess { report[name] = true }.onFailure { report[name] = false }
  }

  /* ---------------- semantic helpers ---------------- */
  private fun titleField() = compose.onNodeWithTag(AddDiscussionTestTags.ADD_TITLE)

  private fun descField() = compose.onNodeWithTag(AddDiscussionTestTags.ADD_DESCRIPTION)

  private fun searchField() = compose.onNodeWithTag(AddDiscussionTestTags.ADD_MEMBERS)

  private fun createBtn() = compose.onNodeWithTag(AddDiscussionTestTags.CREATE_DISCUSSION_BUTTON)

  private fun backBtn() =
      compose.onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON, useUnmergedTree = true)

  private fun discardBtn() = compose.onNodeWithTag(AddDiscussionTestTags.DISCARD_BUTTON)

  @Before
  fun setup() = runBlocking {
    repo = FirestoreRepository()
    handlesRepo = FirestoreHandlesRepository()
    vm = FirestoreViewModel(repo)
    handlesVm = FirestoreHandlesViewModel(handlesRepo)

    val alice = newAccount("Alice", "alice")
    val frank = newAccount("Frank", "frank")

    listOf(alice, frank).forEach { acc ->
      createdAccounts += acc
      val h = acc.handle
      createHandleOnce(acc.uid, h)
      createdHandles += h
    }
    me = frank

    compose.setContent {
      AddDiscussionScreen(
          onBack = { nav.goBack() },
          onCreate = { nav.goBack() },
          viewModel = vm,
          handleViewModel = handlesVm,
          account = me)
    }
  }

  /* ========================== ONE FAT TEST ========================================== */
  @OptIn(ExperimentalTestApi::class)
  @Test
  fun full_smoke_all_cases() = runBlocking {
    val hAlice = createdHandles[0]
    val hFrank = createdHandles[1]

    /* 1  empty fields → create disabled ---------------------------------------------- */
    checkpoint("Title empty") { titleField().assertTextContains("") }
    checkpoint("Desc empty") { descField().assertTextContains("") }
    checkpoint("Create disabled initially") { createBtn().assertIsNotEnabled() }

    /* 2  title typed → create enabled ------------------------------------------------ */
    titleField().performTextInput("Kotlin")
    checkpoint("Create enabled after title") { createBtn().assertIsEnabled() }

    /* 3  back & discard -------------------------------------------------------------- */
    backBtn().performClick()
    coVerify(exactly = 1) { nav.goBack() }
    discardBtn().performClick()
    coVerify(exactly = 2) { nav.goBack() }

    /* 4  clear icon ------------------------------------------------------------------ */
    searchField().performTextInput("xyz")
    compose.onNodeWithContentDescription("Clear").performClick()
    checkpoint("Search cleared") { searchField().assertTextContains("") }

    /* 5  select + remove by handle --------------------------------------------------- */
    searchField().performTextInput(hAlice)
    compose.waitUntilAtLeastOneExists(
        hasText(hAlice) and hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT), 5_000)
    compose
        .onNode(hasText(hAlice) and hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT))
        .performClick()
    compose.onNodeWithContentDescription("Remove").performClick()
    checkpoint("alice handle removed") {
      compose.onAllNodesWithText(hAlice).fetchSemanticsNodes().isEmpty()
    }

    /* 6  current-user handle filtered out ------------------------------------------- */
    searchField().performTextInput(hFrank)
    compose.waitForIdle()
    checkpoint("frank handle NOT in dropdown") {
      compose
          .onAllNodesWithText(hFrank)
          .filterToOne(hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT))
          .assertDoesNotExist()
    }

    /* 7  already-selected handle filtered out --------------------------------------- */
    searchField().performTextClearance()
    searchField().performTextInput(hAlice)
    compose.waitUntilAtLeastOneExists(
        hasText(hAlice) and hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT), 5_000)
    compose.waitUntilAtLeastOneExists(
        hasText(hAlice) and hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT),
        timeoutMillis = 5_000)
    compose
        .onNode(hasText(hAlice) and hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT))
        .performClick()
    searchField().performTextInput(hAlice)
    compose.waitForIdle()
    checkpoint("alice handle NOT in dropdown when already selected") {
      compose
          .onAllNodesWithText(hAlice)
          .filterToOne(hasTestTag(AddDiscussionTestTags.ADD_MEMBERS_ELEMENT))
          .assertDoesNotExist()
    }

    /* ---------- one-line report ----------------------------------------------------- */
    val failed = report.filterValues { !it }.keys
    println(
        "Smoke: ${report.size - failed.size}/${report.size} OK" +
            (if (failed.isNotEmpty()) " → $failed" else ""))
    Assert.assertTrue("Failures: $failed", failed.isEmpty())
  }

  @After
  fun tearDown() = runBlocking {
    createdHandles.forEach { runCatching { handlesRepo.deleteAccountHandle(it) } }
    createdAccounts.forEach { runCatching { repo.deleteAccount(it.uid) } }
  }

  /* --------------------- helper functions --------------------- */

  private fun randomUid() = "uid_" + UUID.randomUUID().toString().take(8)

  /**
   * Creates an Account AND stores its handle in Firestore. Returns the Account with the handle
   * field set locally so we can remember it.
   */
  private suspend fun newAccount(name: String, handleBase: String): Account {
    val uid = randomUid()
    val acc = repo.createAccount(uid, name, "$handleBase@test.com", null)
    createHandleOnce(uid, handleBase)
    return acc.copy(handle = handleBase)
  }

  private suspend fun createHandleOnce(uid: String, handle: String) {
    runCatching { handlesRepo.deleteAccountHandle(handle) }
    handlesRepo.createAccountHandle(uid, handle)
  }
}
