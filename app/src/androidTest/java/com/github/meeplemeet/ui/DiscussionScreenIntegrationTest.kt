/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.discussions.DiscussionRepository
import com.github.meeplemeet.model.discussions.DiscussionViewModel
import com.github.meeplemeet.ui.discussions.DiscussionScreen
import com.github.meeplemeet.ui.discussions.DiscussionTestTags
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.FirestoreTests
import junit.framework.TestCase.assertTrue
import kotlin.io.println
import kotlin.random.Random
import kotlin.time.Duration.Companion.seconds
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.runTest
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class DiscussionScreenIntegrationTest : FirestoreTests() {

  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var repository: DiscussionRepository
  private lateinit var viewModel: DiscussionViewModel
  private lateinit var currentUser: Account
  private lateinit var testScope: TestScope
  private lateinit var otherUser: Account
  private lateinit var testDiscussion: Discussion
  private var backPressed = false

  private val report = linkedMapOf<String, Boolean>()

  private inline fun checkpoint(name: String, crossinline block: () -> Unit) {
    runCatching { block() }.onSuccess { report[name] = true }.onFailure { report[name] = false }
  }

  @Before
  fun setup() = runBlocking {
    val dispatcher = StandardTestDispatcher()
    testScope = TestScope(dispatcher)
    repository = DiscussionRepository()
    viewModel = DiscussionViewModel(repository)
    backPressed = false

    // Create test users
    currentUser =
        repository.createAccount(
            userHandle = "testuser_${Random.nextInt(1000000)}",
            name = "Alice",
            email = "alice@test.com",
            photoUrl = null)

    otherUser =
        repository.createAccount(
            userHandle = "otheruser_${Random.nextInt(1000000)}",
            name = "Bob",
            email = "bob@test.com",
            photoUrl = null)

    // Create a test discussion with messages
    testDiscussion =
        repository.createDiscussion(
            name = "Test Discussion",
            description = "A test discussion",
            creatorId = currentUser.uid,
            participants = listOf(otherUser.uid))

    // Add some test messages
    repository.sendMessageToDiscussion(testDiscussion, currentUser, "Hi there!")
    repository.sendMessageToDiscussion(testDiscussion, otherUser, "Hey Alice!")

    // Fetch updated discussion with messages
    testDiscussion = repository.getDiscussion(testDiscussion.uid)

    currentUser = repository.getAccount(currentUser.uid)
    otherUser = repository.getAccount(otherUser.uid)
  }

  @After
  fun teardown() = runBlocking {
    // Clean up created data
    repository.deleteDiscussion(testDiscussion)
    repository.deleteAccount(currentUser.uid)
    repository.deleteAccount(otherUser.uid)
  }

  @Test
  fun full_smoke_all_cases() =
      testScope.runTest {
        composeTestRule.setContent {
          DiscussionScreen(
              viewModel = viewModel,
              discussion = testDiscussion,
              account = currentUser,
              onBack = { backPressed = true })
        }

        /* 1  title & messages shown ------------------------------------------------------ */
        checkpoint("Discussion title displayed") {
          composeTestRule.onNodeWithText(testDiscussion.name).assertExists()
        }
        testDiscussion.messages.forEach { msg ->
          checkpoint("Message '${msg.content}' displayed") {
            composeTestRule.onNodeWithText(msg.content).assertExists()
          }
        }

        /* 2  send message ---------------------------------------------------------------- */
        val sendField = composeTestRule.onNodeWithTag(DiscussionTestTags.INPUT_FIELD)
        val sendBtn = composeTestRule.onNodeWithTag(DiscussionTestTags.SEND_BUTTON)

        sendField.performTextInput("Hello!")
        sendBtn.performClick()

        checkpoint("Input field cleared after send") {
          sendField.assertTextContains("Type something...")
        }

        /* 3  back button ----------------------------------------------------------------- */
        composeTestRule
            .onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON, useUnmergedTree = true)
            .performClick()
        checkpoint("Back navigation called") { backPressed }

        /* ---------- one-line summary ---------------------------------------------------- */
        val failed = report.filterValues { !it }.keys
        println(
            "Smoke: ${report.size - failed.size}/${report.size} OK" +
                (if (failed.isNotEmpty()) " → $failed" else ""))
        assertTrue("Failures: $failed", failed.isEmpty())
      }
  /* ---------- ONE-SHOT FULL POLL SMOKE -------------------------------- */
  @Test
  fun poll_fullLifeCycle_smoke() =
      testScope.runTest(timeout = 30.seconds) {
        composeTestRule.setContent {
          val discussionFlow = viewModel.discussionFlow(testDiscussion.uid)
          val latestDiscussion by discussionFlow.collectAsState(initial = testDiscussion)
          AppTheme(themeMode = ThemeMode.LIGHT) {
            latestDiscussion?.let {
              if (latestDiscussion != null) {
                DiscussionScreen(
                    viewModel = viewModel,
                    discussion = latestDiscussion!!,
                    account = currentUser,
                    onBack = { backPressed = true })
              }
            }
          }
        }

        /* ------------------------------------------------------------------
         * 1. open “create poll” dialog
         * ------------------------------------------------------------------ */
        checkpoint("Open attachment menu") {
          composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_BUTTON).performClick()
        }
        checkpoint("Tap ‘Create poll’") {
          composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_POLL_OPTION).performClick()
        }
        checkpoint("Poll dialog visible") {
          composeTestRule.onNodeWithTag(DiscussionTestTags.DIALOG_ROOT).assertExists()
        }

        /* ------------------------------------------------------------------
         * 2. fill question
         * ------------------------------------------------------------------ */
        checkpoint("Type question") {
          composeTestRule
              .onNodeWithTag(DiscussionTestTags.QUESTION_FIELD)
              .performTextInput("Best board game?")
        }

        /* ------------------------------------------------------------------
         * 3. manipulate options (add / remove / rename)
         * ------------------------------------------------------------------ */
        fun optionFields() = composeTestRule.onAllNodesWithTag(DiscussionTestTags.OPTION_TEXT_FIELD)

        fun addOption() {
          composeTestRule.onNodeWithTag(DiscussionTestTags.ADD_OPTION_BUTTON).performClick()
        }
        fun removeOption(index: Int) {
          composeTestRule
              .onAllNodesWithTag(DiscussionTestTags.REMOVE_OPTION_BUTTON)[index]
              .performClick()
        }

        // start with two default fields
        optionFields()[0].performTextInput("Chess")
        optionFields()[1].performTextInput("Go")

        addOption() // third field appears
        optionFields()[2].performTextInput("X-Wing")

        removeOption(1) // delete “Go”
        optionFields().assertCountEquals(2) // only two left

        // rename remaining
        optionFields()[0].performTextClearance()
        optionFields()[0].performTextInput("Terraforming Mars")
        optionFields()[1].performTextClearance()
        optionFields()[1].performTextInput("Gloomhaven")

        /* ------------------------------------------------------------------
         * 4. submit poll (single choice)
         * ------------------------------------------------------------------ */
        checkpoint("Submit poll") {
          composeTestRule.onNodeWithTag(DiscussionTestTags.CREATE_POLL_CONFIRM).performClick()
        }
        checkpoint("Dialog closed") {
          composeTestRule.onNodeWithTag(DiscussionTestTags.DIALOG_ROOT).assertDoesNotExist()
        }

        /* ------------------------------------------------------------------
         * 5. poll card rendered
         * ------------------------------------------------------------------ */
        checkpoint("Poll question rendered") {
          composeTestRule.onNodeWithText("Best board game?").assertExists()
        }
        checkpoint("Option 1 rendered") {
          composeTestRule.onNodeWithText("Terraforming Mars").assertExists()
        }
        checkpoint("Option 2 rendered") {
          composeTestRule.onNodeWithText("Gloomhaven").assertExists()
        }
        checkpoint("Wait until poll message exists in repo") {
          runBlocking { testDiscussion = awaitPollMessage(testDiscussion, 1) }
        }

        /* ------------------------------------------------------------------
         * 6. vote (single choice) – first option
         *        msgIndex = last message = 2 (after 2 earlier messages + new poll)
         * ------------------------------------------------------------------ */
        val msgIndex = 2 // 0-based index inside LazyColumn

        checkpoint("Vote first option") {
          composeTestRule
              .onNodeWithTag(DiscussionTestTags.pollVoteButton(msgIndex, 0), useUnmergedTree = true)
              .performClick()
        }
        checkpoint("First option 100 %") { waitUntilPercentIs(msgIndex, 0, "100%") }

        /* ------------------------------------------------------------------
         * 7. change vote – second option becomes 100 %
         * ------------------------------------------------------------------ */
        checkpoint("Change vote to second option") {
          composeTestRule
              .onNodeWithTag(DiscussionTestTags.pollVoteButton(msgIndex, 1), useUnmergedTree = true)
              .performClick()
        }
        composeTestRule.waitForIdle()
        checkpoint("First option 0 %") { waitUntilPercentIs(msgIndex, 0, "0%") }
        checkpoint("Second option 100 %") { waitUntilPercentIs(msgIndex, 1, "100%") }

        /* ------------------------------------------------------------------
         * 8. create a second poll (multi-choice)
         * ------------------------------------------------------------------ */
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_BUTTON).performClick()
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_POLL_OPTION).performClick()

        composeTestRule
            .onNodeWithTag(DiscussionTestTags.QUESTION_FIELD)
            .performTextInput("Pick snacks")
        optionFields()[0].performTextInput("Popcorn")
        optionFields()[1].performTextInput("Nachos")
        addOption()
        optionFields()[2].performTextInput("Soda")

        composeTestRule.onNodeWithTag(DiscussionTestTags.ALLOW_MULTIPLE_CHECKBOX).performClick()

        composeTestRule.onNodeWithTag(DiscussionTestTags.CREATE_POLL_CONFIRM).performClick()
        checkpoint("Wait until poll message exists in repo") {
          runBlocking { testDiscussion = awaitPollMessage(testDiscussion, 1) }
        }

        /* ------------------------------------------------------------------
         * 9. multi-vote & percentages
         *        new poll is at msgIndex 3
         * ------------------------------------------------------------------ */
        val multiMsgIndex = 3

        // select two options
        composeTestRule
            .onNodeWithTag(
                DiscussionTestTags.pollVoteButton(multiMsgIndex, 0), useUnmergedTree = true)
            .performClick()
        composeTestRule
            .onNodeWithTag(
                DiscussionTestTags.pollVoteButton(multiMsgIndex, 2), useUnmergedTree = true)
            .performClick()

        checkpoint("Popcorn 50 %") { waitUntilPercentIs(multiMsgIndex, 0, "50%") }
        checkpoint("Soda 50 %") { waitUntilPercentIs(multiMsgIndex, 2, "50%") }

        // deselect first
        composeTestRule
            .onNodeWithTag(
                DiscussionTestTags.pollVoteButton(multiMsgIndex, 0), useUnmergedTree = true)
            .performClick()
        checkpoint("Popcorn 0 %") { waitUntilPercentIs(multiMsgIndex, 0, "0%") }
        checkpoint("Soda now 100 %") { waitUntilPercentIs(multiMsgIndex, 2, "100%") }

        /* ------------------------------------------------------------------
         * 10. summary
         * ------------------------------------------------------------------ */
        val failed = report.filterValues { !it }.keys
        println(
            "Poll smoke: ${report.size - failed.size}/${report.size} OK" +
                (if (failed.isNotEmpty()) " → $failed" else ""))
      }
  /* waits until the discussion contains a message with a poll */
  private suspend fun awaitPollMessage(discussion: Discussion, minCount: Int = 1): Discussion {
    var disc = discussion
    while (disc.messages.count { it.poll != null } < minCount) {
      kotlinx.coroutines.delay(200)
      disc = repository.getDiscussion(discussion.uid)
    }
    return disc
  }
  /**
   * Waits at most 5 s for the percentage node to appear and to contain the expected text ("0%",
   * "50%", "100%", …).
   */
  private fun waitUntilPercentIs(
      msgIndex: Int,
      optIndex: Int,
      expected: String,
      timeoutMillis: Long = 5_000
  ) {
    composeTestRule.waitUntil(timeoutMillis) {
      runCatching {
            composeTestRule
                .onNodeWithTag(
                    DiscussionTestTags.pollPercent(msgIndex, optIndex), useUnmergedTree = true)
                .assertTextContains(expected)
          }
          .isSuccess
    }
  }
}
