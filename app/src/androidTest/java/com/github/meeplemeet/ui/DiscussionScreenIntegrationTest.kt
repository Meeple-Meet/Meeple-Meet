/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.discussions.Discussion
import com.github.meeplemeet.model.discussions.DiscussionViewModel
import com.github.meeplemeet.ui.discussions.DiscussionScreen
import com.github.meeplemeet.ui.discussions.DiscussionTestTags
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import junit.framework.TestCase.assertTrue
import kotlin.io.println
import kotlin.random.Random
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class DiscussionScreenIntegrationTest : FirestoreTests() {

  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var viewModel: DiscussionViewModel
  private lateinit var currentUser: Account
  private lateinit var testScope: TestScope
  private lateinit var otherUser: Account
  private lateinit var testDiscussion: Discussion
  private var backPressed = false

  private val report = linkedMapOf<String, Boolean>()

  @get:Rule val ck = Checkpoint.Rule()

  private fun checkpoint(name: String, block: () -> Unit) = ck.ck(name, block)

  @Before
  fun setup() = runBlocking {
    val dispatcher = StandardTestDispatcher()
    testScope = TestScope(dispatcher)
    viewModel = DiscussionViewModel()
    backPressed = false

    // Create test users
    currentUser =
        accountRepository.createAccount(
            userHandle = "testuser_${Random.nextInt(1000000)}",
            name = "Alice",
            email = "alice@test.com",
            photoUrl = null)

    otherUser =
        accountRepository.createAccount(
            userHandle = "otheruser_${Random.nextInt(1000000)}",
            name = "Bob",
            email = "bob@test.com",
            photoUrl = null)

    // Create a test discussion with messages
    testDiscussion =
        discussionRepository.createDiscussion(
            name = "Test Discussion",
            description = "A test discussion",
            creatorId = currentUser.uid,
            participants = listOf(otherUser.uid))

    // Add some test messages
    discussionRepository.sendMessageToDiscussion(testDiscussion, currentUser, "Hi there!")
    discussionRepository.sendMessageToDiscussion(testDiscussion, otherUser, "Hey Alice!")

    // Fetch updated discussion with messages
    testDiscussion = discussionRepository.getDiscussion(testDiscussion.uid)

    currentUser = accountRepository.getAccount(currentUser.uid)
    otherUser = accountRepository.getAccount(otherUser.uid)
  }

  @After
  fun teardown() = runBlocking {
    val context = InstrumentationRegistry.getInstrumentation().targetContext
    // Clean up created data
    discussionRepository.deleteDiscussion(context, testDiscussion)
    accountRepository.deleteAccount(currentUser.uid)
    accountRepository.deleteAccount(otherUser.uid)
  }

  @Test
  fun all_tests() = runBlocking {
    // Create photo discussions upfront
    val photoDiscussion =
        discussionRepository.createDiscussion(
            name = "Photos",
            description = "",
            creatorId = currentUser.uid,
            participants = listOf(otherUser.uid))
    discussionRepository.sendPhotoMessageToDiscussion(
        photoDiscussion, currentUser, "Look at this!", "https://example.com/pic1.jpg")
    val refreshedPhotoDiscussion = discussionRepository.getDiscussion(photoDiscussion.uid)

    val galleryDiscussion =
        discussionRepository.createDiscussion(
            name = "Gallery",
            description = "",
            creatorId = currentUser.uid,
            participants = listOf(otherUser.uid))
    discussionRepository.sendPhotoMessageToDiscussion(
        galleryDiscussion, currentUser, "First photo", "https://example.com/picA.jpg")
    discussionRepository.sendPhotoMessageToDiscussion(
        galleryDiscussion, otherUser, "Second photo", "https://example.com/picB.jpg")
    val refreshedGalleryDiscussion = discussionRepository.getDiscussion(galleryDiscussion.uid)

    // Use mutable state to switch discussions
    val currentDiscussionState = mutableStateOf(testDiscussion)

    composeTestRule.setContent {
      val discussionFlow = viewModel.discussionFlow(testDiscussion.uid)
      val latestDiscussion by discussionFlow.collectAsState(initial = testDiscussion)
      AppTheme(themeMode = ThemeMode.LIGHT) {
        DiscussionScreen(
            viewModel = viewModel,
            discussion = currentDiscussionState.value,
            account = currentUser,
            onBack = { backPressed = true })
      }
    }

    checkpoint("full_smoke_all_cases") {

      /* 1  title & messages shown ------------------------------------------------------ */
      checkpoint("Discussion title displayed") {
        composeTestRule.onNodeWithText(testDiscussion.name).assertExists()
      }
      val messages = runBlocking { discussionRepository.getMessages(testDiscussion.uid) }
      messages.forEach { msg ->
        checkpoint("Message '${msg.content}' displayed") {
          composeTestRule.onNodeWithText(msg.content).assertExists()
        }
      }

      /* 2  send message ---------------------------------------------------------------- */
      val sendField = composeTestRule.onNodeWithTag(DiscussionTestTags.INPUT_FIELD)
      val sendBtn = composeTestRule.onNodeWithTag(DiscussionTestTags.SEND_BUTTON)

      sendField.performTextInput("Hello!")
      sendBtn.performClick()

      checkpoint("Input field cleared after send") { sendField.assertTextContains("Message") }

      /* Character counter tests -------------------------------------------------------- */
      checkpoint("character_counter_not_visible_initially") {
        composeTestRule.onNodeWithTag(DiscussionTestTags.CHAR_COUNTER).assertDoesNotExist()
      }

      checkpoint("character_counter_appears_when_approaching_limit") {
        // Type text to get close to limit (4096 - 100 = 3996 chars to trigger counter)
        val longText = "a".repeat(4000)
        sendField.performTextReplacement(longText)
        composeTestRule.waitForIdle()

        // Counter should now be visible
        composeTestRule.onNodeWithTag(DiscussionTestTags.CHAR_COUNTER).assertExists()
        // Should show remaining chars (4096 - 4000 = 96)
        composeTestRule.onNodeWithText("96").assertExists()
      }

      checkpoint("character_counter_shows_warning_when_low") {
        // Type text to leave less than 20 chars
        val longText = "a".repeat(4078)
        sendField.performTextReplacement(longText)
        composeTestRule.waitForIdle()

        // Counter should be visible showing 18 chars remaining
        composeTestRule.onNodeWithTag(DiscussionTestTags.CHAR_COUNTER).assertExists()
        composeTestRule.onNodeWithText("18").assertExists()
      }

      checkpoint("character_limit_enforced") {
        // Type exactly 4096 characters
        val maxText = "a".repeat(4096)
        sendField.performTextReplacement(maxText)
        composeTestRule.waitForIdle()

        // Counter should show 0 chars remaining
        composeTestRule.onNodeWithTag(DiscussionTestTags.CHAR_COUNTER).assertExists()
        composeTestRule.onNodeWithText("0").assertExists()

        // Verify we can't type more - input should be rejected
        sendField.performTextInput("b")
        composeTestRule.waitForIdle()

        // Counter should still show 0 (input was rejected)
        composeTestRule.onNodeWithText("0").assertExists()
      }

      // Clear the text field for subsequent tests
      sendField.performTextReplacement("")
      composeTestRule.waitForIdle()

      /* 3  back button ----------------------------------------------------------------- */
      composeTestRule
          .onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON, useUnmergedTree = true)
          .performClick()
      checkpoint("Back navigation called") { backPressed }

      /* ---------- one-line summary ---------------------------------------------------- */
      val failed = report.filterValues { !it }.keys
      println(
          "Smoke: ${report.size - failed.size}/${report.size} OK" +
              (if (failed.isNotEmpty()) " → $failed" else ""))
      assertTrue("Failures: $failed", failed.isEmpty())
    }

    checkpoint("poll_fullLifeCycle_smoke") {
      // Switch back to test discussion for poll tests
      currentDiscussionState.value = testDiscussion
      composeTestRule.waitForIdle()
      Thread.sleep(500) // Allow recomposition to complete

      /* ------------------------------------------------------------------
       * 1. open "create poll" dialog
       * ------------------------------------------------------------------ */
      checkpoint("Open attachment menu") {
        composeTestRule.waitForIdle()
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_BUTTON).assertExists()
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_BUTTON).performClick()
        composeTestRule.waitForIdle()
      }
      checkpoint("Tap 'Create poll'") {
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_POLL_OPTION).assertExists()
        composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_POLL_OPTION).performClick()
        composeTestRule.waitForIdle()
      }
      checkpoint("Poll dialog visible") {
        composeTestRule.waitUntil(3000) {
          composeTestRule
              .onAllNodesWithTag(DiscussionTestTags.DIALOG_ROOT)
              .fetchSemanticsNodes()
              .isNotEmpty()
        }
        composeTestRule.onNodeWithTag(DiscussionTestTags.DIALOG_ROOT).assertExists()
      }

      /* ------------------------------------------------------------------
       * 2. fill question
       * ------------------------------------------------------------------ */
      checkpoint("Type question") {
        composeTestRule
            .onNodeWithTag(DiscussionTestTags.QUESTION_FIELD)
            .performTextInput("Best board game?")
      }

      /* ------------------------------------------------------------------
       * 3. manipulate options (add / remove / rename)
       * ------------------------------------------------------------------ */
      fun optionFields() = composeTestRule.onAllNodesWithTag(DiscussionTestTags.OPTION_TEXT_FIELD)

      fun addOption() {
        composeTestRule.onNodeWithTag(DiscussionTestTags.ADD_OPTION_BUTTON).performClick()
      }
      fun removeOption(index: Int) {
        composeTestRule
            .onAllNodesWithTag(DiscussionTestTags.REMOVE_OPTION_BUTTON)[index]
            .performClick()
      }

      // start with two default fields
      optionFields()[0].performTextInput("Chess")
      optionFields()[1].performTextInput("Go")

      addOption() // third field appears
      optionFields()[2].performTextInput("X-Wing")

      removeOption(1) // delete “Go”
      optionFields().assertCountEquals(2) // only two left

      // rename remaining
      optionFields()[0].performTextClearance()
      optionFields()[0].performTextInput("Terraforming Mars")
      optionFields()[1].performTextClearance()
      optionFields()[1].performTextInput("Gloomhaven")

      /* ------------------------------------------------------------------
       * 4. submit poll (single choice)
       * ------------------------------------------------------------------ */
      checkpoint("Submit poll") {
        composeTestRule.waitForIdle()
        composeTestRule.onNodeWithTag(DiscussionTestTags.CREATE_POLL_CONFIRM).assertExists()
        composeTestRule.onNodeWithTag(DiscussionTestTags.CREATE_POLL_CONFIRM).performClick()
        composeTestRule.waitForIdle()
      }
      checkpoint("Dialog closed") {
        composeTestRule.waitUntil(3000) {
          composeTestRule
              .onAllNodesWithTag(DiscussionTestTags.DIALOG_ROOT)
              .fetchSemanticsNodes()
              .isEmpty()
        }
        composeTestRule.onNodeWithTag(DiscussionTestTags.DIALOG_ROOT).assertDoesNotExist()
      }

      /* ------------------------------------------------------------------
       * 5. poll card rendered
       * ------------------------------------------------------------------ */
      checkpoint("Poll question rendered") {
        composeTestRule.waitUntil(5000) {
          composeTestRule.onAllNodesWithText("Best board game?").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText("Best board game?").assertExists()
      }
      checkpoint("Option 1 rendered") {
        composeTestRule.waitUntil(5000) {
          composeTestRule.onAllNodesWithText("Terraforming Mars").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText("Terraforming Mars").assertExists()
      }
      checkpoint("Option 2 rendered") {
        composeTestRule.waitUntil(5000) {
          composeTestRule.onAllNodesWithText("Gloomhaven").fetchSemanticsNodes().isNotEmpty()
        }
        composeTestRule.onNodeWithText("Gloomhaven").assertExists()
      }
      checkpoint("Wait until poll message exists in repo") {
        runBlocking { testDiscussion = awaitPollMessage(testDiscussion, 1) }
      }

      /* ------------------------------------------------------------------
       * 6. vote (single choice) – first option
       *        msgIndex = last message = 2 (after 2 earlier messages + new poll)
       * ------------------------------------------------------------------ */
      val msgIndex = runBlocking {
        pollMessageIndex(testDiscussion.uid, "Best board game?").also {
          require(it >= 0) { "Poll message not found" }
        }
      }

      checkpoint("Vote first option") {
        composeTestRule
            .onNodeWithTag(DiscussionTestTags.pollVoteButton(msgIndex, 0), useUnmergedTree = true)
            .performClick()
      }
      checkpoint("First option 100 %") { waitUntilPercentIs(msgIndex, 0, "100%") }

      /* ------------------------------------------------------------------
       * 7. change vote – second option becomes 100 %
       * ------------------------------------------------------------------ */
      checkpoint("Change vote to second option") {
        composeTestRule
            .onNodeWithTag(DiscussionTestTags.pollVoteButton(msgIndex, 1), useUnmergedTree = true)
            .performClick()
      }
      composeTestRule.waitForIdle()
      checkpoint("First option 0 %") { waitUntilPercentIs(msgIndex, 0, "0%") }
      checkpoint("Second option 100 %") { waitUntilPercentIs(msgIndex, 1, "100%") }

      /* ------------------------------------------------------------------
       * 8. create a second poll (multi-choice)
       * ------------------------------------------------------------------ */
      composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_BUTTON).performClick()
      composeTestRule.onNodeWithTag(DiscussionTestTags.ATTACHMENT_POLL_OPTION).performClick()

      composeTestRule
          .onNodeWithTag(DiscussionTestTags.QUESTION_FIELD)
          .performTextInput("Pick snacks")
      optionFields()[0].performTextInput("Popcorn")
      optionFields()[1].performTextInput("Nachos")
      addOption()
      optionFields()[2].performTextInput("Soda")

      composeTestRule
          .onNodeWithTag(DiscussionTestTags.ALLOW_MULTIPLE_CHECKBOX, useUnmergedTree = true)
          .performClick()

      composeTestRule.onNodeWithTag(DiscussionTestTags.CREATE_POLL_CONFIRM).performClick()
      checkpoint("Wait until poll message exists in repo") {
        runBlocking { testDiscussion = awaitPollMessage(testDiscussion, 1) }
      }

      /* ------------------------------------------------------------------
       * 9. multi-vote & percentages
       *        new poll is at msgIndex 3
       * ------------------------------------------------------------------ */
      val multiMsgIndex = runBlocking {
        pollMessageIndex(testDiscussion.uid, "Pick snacks").also {
          require(it >= 0) { "Multi poll message not found" }
        }
      }

      // select two options
      composeTestRule
          .onNodeWithTag(
              DiscussionTestTags.pollVoteButton(multiMsgIndex, 0), useUnmergedTree = true)
          .performClick()
      composeTestRule
          .onNodeWithTag(
              DiscussionTestTags.pollVoteButton(multiMsgIndex, 2), useUnmergedTree = true)
          .performClick()

      runBlocking { delay(250) }

      checkpoint("Popcorn 50 %") { waitUntilPercentIs(multiMsgIndex, 0, "50%") }
      checkpoint("Soda 50 %") { waitUntilPercentIs(multiMsgIndex, 2, "50%") }

      // deselect first
      composeTestRule
          .onNodeWithTag(
              DiscussionTestTags.pollVoteButton(multiMsgIndex, 0), useUnmergedTree = true)
          .performClick()

      runBlocking { delay(250) }

      checkpoint("Popcorn 0 %") { waitUntilPercentIs(multiMsgIndex, 0, "0%") }
      checkpoint("Soda now 100 %") { waitUntilPercentIs(multiMsgIndex, 2, "100%") }

      /* ------------------------------------------------------------------
       * 10. summary
       * ------------------------------------------------------------------ */
      val failed = report.filterValues { !it }.keys
      println(
          "Poll smoke: ${report.size - failed.size}/${report.size} OK" +
              (if (failed.isNotEmpty()) " → $failed" else ""))
    }

    checkpoint("photoBubble_opensFullscreenDialog") {
      try {
        val caption = "Look at this!"

        // Switch to photo discussion
        currentDiscussionState.value = refreshedPhotoDiscussion
        composeTestRule.waitForIdle()

        composeTestRule.waitUntil(5_000) {
          composeTestRule
              .onAllNodesWithContentDescription("Photo message", useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isNotEmpty()
        }

        checkpoint("Photo bubble displayed") {
          composeTestRule
              .onAllNodesWithContentDescription("Photo message", useUnmergedTree = true)
              .assertCountEquals(1)
        }
        checkpoint("Photo caption displayed") {
          composeTestRule.onNodeWithText(caption, useUnmergedTree = true).assertExists()
        }

        composeTestRule
            .onAllNodesWithContentDescription("Photo message", useUnmergedTree = true)[0]
            .performClick()

        checkpoint("Fullscreen dialog shows thumbnail bar") {
          composeTestRule
              .onAllNodesWithContentDescription("Photo thumbnail", useUnmergedTree = true)
              .assertCountEquals(1)
        }
        checkpoint("Dialog can be dismissed") {
          val backs =
              composeTestRule.onAllNodesWithContentDescription("Back", useUnmergedTree = true)
          val lastBack = backs[backs.fetchSemanticsNodes().lastIndex]
          lastBack.performClick()
          composeTestRule.waitUntil(3_000) {
            composeTestRule
                .onAllNodesWithContentDescription("Photo thumbnail", useUnmergedTree = true)
                .fetchSemanticsNodes()
                .isEmpty()
          }
        }
      } finally {
        // Photo discussion cleanup handled at end of test
      }
    }

    checkpoint("fullscreenImageDialog_switchesBetweenPhotos") {
      try {
        // Switch to gallery discussion
        currentDiscussionState.value = refreshedGalleryDiscussion
        composeTestRule.waitForIdle()

        composeTestRule.waitUntil(5_000) {
          composeTestRule
              .onAllNodesWithContentDescription("Photo message", useUnmergedTree = true)
              .fetchSemanticsNodes()
              .size >= 2
        }

        composeTestRule
            .onAllNodesWithContentDescription("Photo message", useUnmergedTree = true)[0]
            .performClick()

        checkpoint("Thumbnail bar shows two photos") {
          composeTestRule
              .onAllNodesWithContentDescription("Photo thumbnail", useUnmergedTree = true)
              .assertCountEquals(2)
        }
        checkpoint("Initial dialog shows current user") {
          composeTestRule.onNodeWithText("You", useUnmergedTree = true).assertExists()
        }

        composeTestRule
            .onAllNodesWithContentDescription("Photo thumbnail", useUnmergedTree = true)[1]
            .performClick()

        checkpoint("Switching thumbnails updates sender name") {
          composeTestRule.waitUntil(3_000) {
            composeTestRule
                .onAllNodesWithText("You", useUnmergedTree = true)
                .fetchSemanticsNodes()
                .isEmpty()
          }
        }

        val backs = composeTestRule.onAllNodesWithContentDescription("Back", useUnmergedTree = true)
        val lastBack = backs[backs.fetchSemanticsNodes().lastIndex]
        lastBack.performClick()
      } finally {
        // Gallery discussion cleanup handled at end of test
      }
    }

    checkpoint("message_edit_and_delete_smoke") {
      // Make sure we're on the text discussion
      currentDiscussionState.value = testDiscussion
      composeTestRule.waitForIdle()

      val sendField = composeTestRule.onNodeWithTag(DiscussionTestTags.INPUT_FIELD)
      val sendBtn = composeTestRule.onNodeWithTag(DiscussionTestTags.SEND_BUTTON)

      /* ------------------------------------------------------------------
       * 1. create a new message to edit
       * ------------------------------------------------------------------ */
      val originalText = "Message to be edited"
      sendField.performTextReplacement(originalText)
      sendBtn.performClick()

      composeTestRule.waitUntil(10_000) {
        composeTestRule
            .onAllNodesWithText(originalText, useUnmergedTree = true)
            .fetchSemanticsNodes()
            .isNotEmpty()
      }

      /* ------------------------------------------------------------------
       * 2. open message options popup for that message
       * ------------------------------------------------------------------ */
      checkpoint("long_press_opens_message_options_for_own_message") {
        val msgNode = composeTestRule.onAllNodesWithText(originalText, useUnmergedTree = true)[0]

        msgNode.performTouchInput { longClick(center) }

        composeTestRule.waitUntil(5_000) {
          composeTestRule
              .onAllNodesWithTag(DiscussionTestTags.MESSAGE_OPTIONS_CARD, useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isNotEmpty()
        }

        composeTestRule
            .onNodeWithTag(DiscussionTestTags.MESSAGE_OPTIONS_ROOT, useUnmergedTree = true)
            .assertExists()

        // For a fresh text message, "Edit" must be available
        composeTestRule
            .onNodeWithTag(DiscussionTestTags.MESSAGE_EDIT_BUTTON, useUnmergedTree = true)
            .assertExists()
      }

      /* ------------------------------------------------------------------
       * 3. edit the message and verify content is updated
       * ------------------------------------------------------------------ */
      val editedText = "Message after edit"

      checkpoint("editing_message_updates_text") {
        composeTestRule
            .onNodeWithTag(DiscussionTestTags.MESSAGE_EDIT_BUTTON, useUnmergedTree = true)
            .performClick()

        // Text field should be pre-filled with original content
        sendField.assertTextContains(originalText)

        // Replace with new content and send
        sendField.performTextReplacement(editedText)
        sendBtn.performClick()

        // Wait for new text to appear in the UI
        composeTestRule.waitUntil(10_000) {
          composeTestRule
              .onAllNodesWithText(editedText, useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isNotEmpty()
        }

        // Old text should no longer be visible
        composeTestRule
            .onAllNodesWithText(originalText, useUnmergedTree = true)
            .assertCountEquals(0)
      }

      /* ------------------------------------------------------------------
       * 4. create a second message and delete it
       * ------------------------------------------------------------------ */
      val deleteText = "Message to be deleted"
      sendField.performTextReplacement(deleteText)
      sendBtn.performClick()

      composeTestRule.waitUntil(10_000) {
        composeTestRule
            .onAllNodesWithText(deleteText, useUnmergedTree = true)
            .fetchSemanticsNodes()
            .isNotEmpty()
      }

      checkpoint("deleting_message_removes_it_from_ui_and_repository") {
        val deleteNode = composeTestRule.onAllNodesWithText(deleteText, useUnmergedTree = true)[0]

        deleteNode.performTouchInput { longClick(center) }

        composeTestRule.waitUntil(5_000) {
          composeTestRule
              .onAllNodesWithTag(DiscussionTestTags.MESSAGE_OPTIONS_CARD, useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isNotEmpty()
        }

        composeTestRule
            .onNodeWithTag(DiscussionTestTags.MESSAGE_DELETE_BUTTON, useUnmergedTree = true)
            .assertExists()

        composeTestRule
            .onNodeWithTag(DiscussionTestTags.MESSAGE_DELETE_BUTTON, useUnmergedTree = true)
            .performClick()

        // Wait until the message disappears from the UI
        composeTestRule.waitUntil(10_000) {
          composeTestRule
              .onAllNodesWithText(deleteText, useUnmergedTree = true)
              .fetchSemanticsNodes()
              .isEmpty()
        }

        // And verify it no longer exists in the repository
        val repoMessages = runBlocking { discussionRepository.getMessages(testDiscussion.uid) }
        assertTrue(repoMessages.none { it.content == deleteText })
      }
    }

    // Cleanup photo discussions
    runBlocking {
      val context = InstrumentationRegistry.getInstrumentation().targetContext
      discussionRepository.deleteDiscussion(context, photoDiscussion)
      discussionRepository.deleteDiscussion(context, galleryDiscussion)
    }
  }

  /* waits until the discussion contains a message with a poll */
  private suspend fun awaitPollMessage(discussion: Discussion, minCount: Int = 1): Discussion {
    var disc = discussion
    var messages = discussionRepository.getMessages(discussion.uid)
    while (messages.count { it.poll != null } < minCount) {
      kotlinx.coroutines.delay(200)
      disc = discussionRepository.getDiscussion(discussion.uid)
      messages = discussionRepository.getMessages(discussion.uid)
    }
    return disc
  }

  private suspend fun pollMessageIndex(discussionId: String, question: String): Int {
    val messages = discussionRepository.getMessages(discussionId)
    return messages.indexOfLast { it.poll?.question == question }
  }
  /**
   * Waits at most 5 s for the percentage node to appear and to contain the expected text ("0%",
   * "50%", "100%", …).
   */
  private fun waitUntilPercentIs(
      msgIndex: Int,
      optIndex: Int,
      expected: String,
      timeoutMillis: Long = 5_000
  ) {
    composeTestRule.waitUntil(timeoutMillis) {
      runCatching {
            composeTestRule
                .onNodeWithTag(
                    DiscussionTestTags.pollPercent(msgIndex, optIndex), useUnmergedTree = true)
                .assertTextContains(expected)
          }
          .isSuccess
    }
  }
}
