/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.repositories.FirestoreRepository
import com.github.meeplemeet.model.structures.*
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.ui.navigation.NavigationTestTags
import com.github.meeplemeet.utils.FirestoreTests
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.runTest
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class DiscussionScreenIntegrationTest : FirestoreTests() {

  @get:Rule val composeTestRule = createComposeRule()

  private lateinit var repository: FirestoreRepository
  private lateinit var viewModel: FirestoreViewModel
  private lateinit var currentUser: Account
  private lateinit var testScope: TestScope
  private lateinit var otherUser: Account
  private lateinit var testDiscussion: Discussion
  private var backPressed = false

  private val report = linkedMapOf<String, Boolean>()

  private inline fun checkpoint(name: String, crossinline block: () -> Unit) {
    runCatching { block() }.onSuccess { report[name] = true }.onFailure { report[name] = false }
  }

  @Before
  fun setup() = runBlocking {
    val dispatcher = StandardTestDispatcher()
    testScope = TestScope(dispatcher)
    repository = FirestoreRepository()
    viewModel = FirestoreViewModel(repository)
    backPressed = false

    // Create test users
    currentUser =
        repository.createAccount(
            userHandle = "testuser_${System.currentTimeMillis()}",
            name = "Alice",
            email = "alice@test.com",
            photoUrl = null)

    otherUser =
        repository.createAccount(
            userHandle = "otheruser_${System.currentTimeMillis()}",
            name = "Bob",
            email = "bob@test.com",
            photoUrl = null)

    // Create a test discussion with messages
    testDiscussion =
        repository.createDiscussion(
            name = "Test Discussion",
            description = "A test discussion",
            creatorId = currentUser.uid,
            participants = listOf(otherUser.uid))

    // Add some test messages
    repository.sendMessageToDiscussion(testDiscussion, currentUser, "Hi there!")
    repository.sendMessageToDiscussion(testDiscussion, otherUser, "Hey Alice!")

    // Fetch updated discussion with messages
    testDiscussion = repository.getDiscussion(testDiscussion.uid)

    currentUser = repository.getAccount(currentUser.uid)
    otherUser = repository.getAccount(otherUser.uid)
  }

  @After
  fun teardown() = runBlocking {
    // Clean up created data
    repository.deleteDiscussion(testDiscussion)
    repository.deleteAccount(currentUser.uid)
    repository.deleteAccount(otherUser.uid)
  }

  @Test
  fun full_smoke_all_cases() =
      testScope.runTest {
        composeTestRule.setContent {
          DiscussionScreen(
              viewModel = viewModel,
              discussion = testDiscussion,
              account = currentUser,
              onBack = { backPressed = true })
        }

        /* 1  title & messages shown ------------------------------------------------------ */
        checkpoint("Discussion title displayed") {
          composeTestRule.onNodeWithText(testDiscussion.name).assertExists()
        }
        testDiscussion.messages.forEach { msg ->
          checkpoint("Message '${msg.content}' displayed") {
            composeTestRule.onNodeWithText(msg.content).assertExists()
          }
        }

        /* 2  send message ---------------------------------------------------------------- */
        val sendField = composeTestRule.onNodeWithTag(DiscussionTestTags.INPUT_FIELD)
        val sendBtn = composeTestRule.onNodeWithTag(DiscussionTestTags.SEND_BUTTON)

        sendField.performTextInput("Hello!")
        sendBtn.performClick()

        checkpoint("Input field cleared after send") {
          sendField.assertTextContains("Type something...")
        }

        /* 3  back button ----------------------------------------------------------------- */
        composeTestRule
            .onNodeWithTag(NavigationTestTags.GO_BACK_BUTTON, useUnmergedTree = true)
            .performClick()
        checkpoint("Back navigation called") { backPressed }

        /* ---------- one-line summary ---------------------------------------------------- */
        val failed = report.filterValues { !it }.keys
        println(
            "Smoke: ${report.size - failed.size}/${report.size} OK" +
                (if (failed.isNotEmpty()) " â†’ $failed" else ""))
        Assert.assertTrue("Failures: $failed", failed.isEmpty())
      }
}
