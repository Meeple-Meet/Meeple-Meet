/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.auth.HandlesRepository
import com.github.meeplemeet.model.auth.HandlesViewModel
import com.github.meeplemeet.model.discussions.DiscussionRepository
import com.github.meeplemeet.model.discussions.DiscussionViewModel
import com.github.meeplemeet.ui.auth.CreateAccountScreen
import com.github.meeplemeet.ui.auth.CreateAccountTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import java.util.UUID
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.runBlocking
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class CreateAccountScreenTest : FirestoreTests() {

  /* 1. shared rule for single install */
  @get:Rule(order = 0) val compose = createComposeRule()

  private lateinit var repo: DiscussionRepository
  private lateinit var firestoreVm: DiscussionViewModel
  private lateinit var handlesRepo: HandlesRepository
  private lateinit var handlesVm: HandlesViewModel
  private lateinit var me: Account

  /* handles created by THIS test run */
  private val handlesCreated = mutableSetOf<String>()

  /* 2. drop manual report map – Checkpoint summarises itself */
  private val ck = Checkpoint()
  @get:Rule val checkpointRule = Checkpoint.rule()

  private fun checkpoint(name: String, block: () -> Unit) = ck(name, block)

  /* helper accessors */
  private fun handleField() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_FIELD)

  private fun handleError() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_ERROR)

  private fun usernameField() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_FIELD)

  private fun usernameError() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_ERROR)

  private fun submitBtn() = compose.onNodeWithTag(CreateAccountTestTags.SUBMIT_BUTTON)

  private fun ownerCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_OWNER)

  private fun renterCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_RENTER)

  @Before
  fun setup() = runBlocking {
    repo = DiscussionRepository()
    firestoreVm = DiscussionViewModel(repo)
    handlesRepo = HandlesRepository()
    handlesVm = HandlesViewModel(handlesRepo)

    val bootstrapRepo = DiscussionRepository()
    val uid = "uid_" + UUID.randomUUID().toString().take(8)
    me = bootstrapRepo.createAccount(uid, "Frank", "frank@test.com", null)

    compose.setContent {
      AppTheme(ThemeMode.DARK) {
        CreateAccountScreen(
            discussionVM = firestoreVm,
            handlesVM = handlesVm,
            account = me,
            onCreate = { /* no-op – we assert via repo */})
      }
    }
  }

  @Test
  fun full_smoke_all_cases() = runBlocking {

    /* 1. initial state */
    checkpoint("Initial state – both fields empty") {
      handleField().assertTextContains("")
      usernameField().assertTextContains("")
    }

    /* 2. empty username → button disabled */
    checkpoint("Empty username keeps submit disabled") {
      val h1 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      handleField().performTextInput(h1)
      submitBtn().assertIsNotEnabled()
    }

    /* 3. handle already taken */
    checkpoint("Taken handle shows error") {
      val taken = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      runBlocking { handlesRepo.createAccountHandle(me.uid, taken) }

      handleField().performTextClearance()
      handleField().performTextInput(taken)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()

      /* 2. shorter timeout */
      compose.waitUntil(timeoutMillis = 600) { handlesVm.errorMessage.value.isNotEmpty() }
      handleError().assertTextContains("Handle already taken", substring = true)
    }

    /* 4. empty handle → no creation */
    checkpoint("Empty handle does NOT trigger onCreate") {
      val startCallCount = runBlocking { handlesRepo.handleForAccountExists(me.uid, "") }

      handleField().performTextClearance()
      usernameField().performTextInput("Frank")
      submitBtn().performClick()
      /* 3. removed redundant waitForIdle */

      val afterCall = runBlocking { handlesRepo.handleForAccountExists(me.uid, "") }
      assertTrue("onCreate must not be called", startCallCount == afterCall)
    }

    /* 5. valid input → success */
    checkpoint("Valid creation persists handle") {
      val h2 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }

      handleField().performTextInput(h2)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()

      compose.waitUntil(timeoutMillis = 800) {
        runBlocking { handlesRepo.handleForAccountExists(me.uid, h2) }
      }
    }

    /* 6. clear username → error shown */
    checkpoint("Clearing username shows empty error") {
      usernameField().performTextClearance()
      usernameError().assertTextContains("Username cannot be empty", substring = true)
    }

    /* === 7. owner / renter checkboxes – minimum clicks, no extra waits === */
    checkpoint("Multiple clicks end with owner ON / renter OFF") {
      /* 3 clicks instead of 5 – still exercising the UI */
      ownerCheckbox().performClick() // owner ON
      renterCheckbox().performClick() // renter ON
      ownerCheckbox().performClick() // owner OFF
      renterCheckbox().performClick() // renter OFF
      ownerCheckbox().performClick() // owner ON  → final state owner=true, renter=false

      /* single short wait */
      compose.waitUntil(timeoutMillis = 400) {
        firestoreVm.accountFlow(me.uid).value?.shopOwner == true &&
            firestoreVm.accountFlow(me.uid).value?.spaceRenter == false
      }
    }
  }

  @After
  fun tearDown() = runBlocking {
    handlesCreated.forEach { runCatching { handlesRepo.deleteAccountHandle(it) } }
  }
}
