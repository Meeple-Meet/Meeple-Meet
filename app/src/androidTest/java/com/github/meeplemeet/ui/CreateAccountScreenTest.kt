/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.MainActivityViewModel
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.auth.CreateAccountViewModel
import com.github.meeplemeet.model.auth.HandlesRepository
import com.github.meeplemeet.ui.auth.CreateAccountScreen
import com.github.meeplemeet.ui.auth.CreateAccountTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.FirestoreTests
import java.util.UUID
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.runBlocking
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class CreateAccountScreenTest : FirestoreTests() {

  @get:Rule val compose = createComposeRule()

  private lateinit var mainActivityViewModel: MainActivityViewModel
  private lateinit var handlesRepo: HandlesRepository
  private lateinit var handlesVm: CreateAccountViewModel
  private lateinit var me: Account

  /* handles created by THIS test run */
  private val handlesCreated = mutableSetOf<String>()

  private val report = linkedMapOf<String, Boolean>()

  private fun handleField() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_FIELD)

  private fun handleError() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_ERROR)

  private fun usernameField() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_FIELD)

  private fun usernameError() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_ERROR)

  private fun submitBtn() = compose.onNodeWithTag(CreateAccountTestTags.SUBMIT_BUTTON)

  private fun ownerCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_OWNER)

  private fun renterCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_RENTER)

  private inline fun checkpoint(name: String, crossinline block: () -> Unit) {
    runCatching { block() }.onSuccess { report[name] = true }.onFailure { report[name] = false }
  }

  @Before
  fun setup() = runBlocking {
    mainActivityViewModel = MainActivityViewModel()
    handlesRepo = HandlesRepository()
    handlesVm = CreateAccountViewModel(handlesRepo)

    val uid = "uid_" + UUID.randomUUID().toString().take(8)
    me = accountRepository.createAccount(uid, "Frank", "frank@test.com", null)

    compose.setContent {
      AppTheme(ThemeMode.DARK) {
        CreateAccountScreen(
            account = me, viewModel = handlesVm, onCreate = { report["onCreate triggered"] = true })
      }
    }
  }

  /* ---------- single fat test that covers all old cases ---------- */
  @Test
  fun full_smoke_all_cases() = runBlocking {

    /* === 1. initial state === */
    handleField().apply { checkpoint("Handle field initially empty") { assertTextContains("") } }
    usernameField().apply {
      checkpoint("Username field initially empty") { assertTextContains("") }
    }

    /* === 2. empty username → button disabled === */
    val h1 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h1)
    submitBtn().apply { checkpoint("Button disabled with empty username") { assertIsNotEnabled() } }

    /* === 3. handle already taken === */
    val taken = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handlesRepo.createAccountHandle(me.uid, taken)
    handleField().performTextClearance()
    handleField().performTextInput(taken)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitUntil(timeoutMillis = 3_000) { handlesVm.errorMessage.value.isNotEmpty() }
    checkpoint("Error message for taken handle") {
      handleError().assertTextContains("This handle has already been assigned", substring = true)
    }

    /* === 4. empty handle → no creation === */
    val startCallCount = report["onCreate triggered"] == true
    handleField().performTextClearance()
    usernameField().performTextInput("Frank")
    submitBtn().performClick()
    compose.waitForIdle()
    checkpoint("Empty handle does NOT trigger onCreate") {
      (report["onCreate triggered"] == true) == startCallCount
    }

    /* === 5. valid input → success === */
    val h2 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h2)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitUntil(timeoutMillis = 5_000) { report.containsKey("onCreate triggered") }
    checkpoint("Valid creation persists handle") {
      runBlocking { handlesRepo.handleForAccountExists(me.uid, h2) }
    }

    /* === 6. delete username while filled → error shown === */
    usernameField().performTextClearance()
    compose.waitForIdle()
    checkpoint("Clearing username shows empty error") {
      usernameError().assertTextContains("Username cannot be empty", substring = true)
    }

    /* === 7. using the checkbox properly updates account roles */
    // Clear previous data and set up for new submission
    handleField().performTextClearance()
    usernameField().performTextClearance()

    // Click owner checkbox and submit
    ownerCheckbox().performClick()
    val h3 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h3)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitForIdle()
    Thread.sleep(1000) // Give time for async operations
    checkpoint("Owner checkbox has an impact on account") {
      runBlocking {
        val acc = accountRepository.getAccount(me.uid)
        acc.shopOwner == true
      }
    }

    // Clear and test renter checkbox
    handleField().performTextClearance()
    usernameField().performTextClearance()

    renterCheckbox().performClick()
    val h4 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h4)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitForIdle()
    Thread.sleep(1000) // Give time for async operations
    checkpoint("Renter checkbox has an impact on account") {
      runBlocking {
        val acc = accountRepository.getAccount(me.uid)
        acc.spaceRenter == true
      }
    }

    // Clear and test multiple checkbox clicks
    handleField().performTextClearance()
    usernameField().performTextClearance()

    // Owner checkbox is pressed 3 times total -> on (was on, now off, now on)
    // Renter checkbox is pressed 3 times total -> off (was on, now off, now on, now off would be 4,
    // but we do 3)
    ownerCheckbox().performClick() // off
    renterCheckbox().performClick() // off
    ownerCheckbox().performClick() // on

    val h5 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h5)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitForIdle()
    Thread.sleep(1000) // Give time for async operations
    checkpoint("Multiple checkbox clicks have an impact on account") {
      runBlocking {
        val acc = accountRepository.getAccount(me.uid)
        acc.shopOwner == true && !acc.spaceRenter
      }
    }

    /* ---------- summary ---------- */
    val failed = report.filterValues { !it }.keys
    println(
        "Smoke: ${report.size - failed.size}/${report.size} OK" +
            (if (failed.isNotEmpty()) " → $failed" else ""))
    assertTrue("Failures: $failed", failed.isEmpty())
  }

  @After
  fun tearDown() = runBlocking {
    handlesCreated.forEach { runCatching { handlesRepo.deleteAccountHandle(it) } }
  }
}
