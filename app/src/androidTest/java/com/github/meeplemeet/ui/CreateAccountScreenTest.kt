/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.MainActivityViewModel
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.auth.CreateAccountViewModel
import com.github.meeplemeet.ui.auth.CreateAccountScreen
import com.github.meeplemeet.ui.auth.CreateAccountTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import java.util.UUID
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.runBlocking
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class CreateAccountScreenTest : FirestoreTests() {

  /* 1. shared rule for single install */
  @get:Rule(order = 0) val compose = createComposeRule()
  /* ---------- Checkpoint helper ---------- */
  @get:Rule val ck = Checkpoint.rule()

  fun checkpoint(name: String, block: () -> Unit) = ck.ck(name, block)

  private lateinit var mainActivityViewModel: MainActivityViewModel
  private lateinit var handlesVm: CreateAccountViewModel
  private lateinit var me: Account

  /* handles created by THIS test run */
  private val handlesCreated = mutableSetOf<String>()

  /* helper accessors */
  private fun handleField() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_FIELD)

  private fun handleError() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_ERROR)

  private fun usernameField() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_FIELD)

  private fun usernameError() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_ERROR)

  private fun submitBtn() = compose.onNodeWithTag(CreateAccountTestTags.SUBMIT_BUTTON)

  private fun ownerCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_OWNER)

  private fun renterCheckbox() = compose.onNodeWithTag(CreateAccountTestTags.CHECKBOX_RENTER)

  @Before
  fun setup() = runBlocking {
    mainActivityViewModel = MainActivityViewModel()
    handlesVm = CreateAccountViewModel(handlesRepository)

    val uid = "uid_" + UUID.randomUUID().toString().take(8)
    me = accountRepository.createAccount(uid, "Frank", "frank@test.com", null)

    compose.setContent {
      AppTheme(ThemeMode.DARK) {
        CreateAccountScreen(account = me, onCreate = { /* no-op – we assert via repo */})
      }
    }
  }

  @Test
  fun full_smoke_all_cases() = runBlocking {

    /* 1. initial state */
    checkpoint("Initial state – both fields empty") {
      handleField().assertTextContains("")
      usernameField().assertTextContains("")
    }

    /* 2. empty username → button disabled */
    checkpoint("Empty username keeps submit disabled") {
      val h1 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      handleField().performTextInput(h1)
      submitBtn().assertIsNotEnabled()
      clearFields()
    }

    /* 3. handle already taken */
    checkpoint("Taken handle shows error") {
      val taken = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      runBlocking { handlesRepository.createAccountHandle(me.uid, taken) }

      handleField().performTextClearance()
      handleField().performTextInput(taken)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()
      compose.waitForIdle()

      handleError().assertTextContains("assigned", substring = true)
      clearFields()
    }

    /* 4. empty handle → no creation */
    checkpoint("Empty handle does NOT trigger onCreate") {
      val startCallCount = runBlocking { handlesRepository.handleForAccountExists(me.uid, "") }

      handleField().performTextClearance()
      usernameField().performTextInput("Frank")
      submitBtn().performClick()
      /* 3. removed redundant waitForIdle */

      val afterCall = runBlocking { handlesRepository.handleForAccountExists(me.uid, "") }
      assertTrue("onCreate must not be called", startCallCount == afterCall)
      clearFields()
    }

    /* 5. valid input → success */
    checkpoint("Valid creation persists handle") {
      val h2 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }

      handleField().performTextInput(h2)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()

      compose.waitUntil(timeoutMillis = 800) {
        runBlocking { handlesRepository.handleForAccountExists(me.uid, h2) }
      }
      clearFields()
    }

    /* 6. clear username → error shown */
    checkpoint("Clearing username shows empty error") {
      usernameField().performTextClearance()
      usernameError().assertTextContains("Username cannot be empty", substring = true)
      clearFields()
    }

    /* === 7. owner / renter checkboxes – minimum clicks, no extra waits === */
    checkpoint("Multiple clicks end with owner ON / renter OFF") {
      /* 3 clicks instead of 5 – still exercising the UI */
      ownerCheckbox().performClick()
      val h3 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      handleField().performTextInput(h3)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()
      compose.waitForIdle()
      checkpoint("Owner checkbox has an impact on account") {
        runBlocking {
          val acc = accountRepository.getAccount(me.uid)
          acc.shopOwner
        }
      }

      // Clear and test renter checkbox
      handleField().performTextClearance()
      usernameField().performTextClearance()

      renterCheckbox().performClick()
      val h4 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
      handleField().performTextInput(h4)
      usernameField().performTextInput("Frank")
      submitBtn().performClick()

      compose.waitForIdle()
      checkpoint("Renter checkbox has an impact on account") {
        runBlocking {
          val acc = accountRepository.getAccount(me.uid)
          acc.spaceRenter
        }
      }

      checkpoint("Checkbox clicks") {
        clearFields()
        ownerCheckbox().performClick() // off
        renterCheckbox().performClick() // off
        ownerCheckbox().performClick() // on

        val h5 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
        handleField().performTextInput(h5)
        usernameField().performTextInput("Frank")
        submitBtn().performClick()

        compose.waitForIdle()
        checkpoint("Multiple checkbox clicks have an impact on account") {
          runBlocking {
            val acc = accountRepository.getAccount(me.uid)
            acc.shopOwner && !acc.spaceRenter
          }
        }
      }
    }
  }

  @After
  fun tearDown() = runBlocking {
    handlesCreated.forEach { runCatching { handlesRepository.deleteAccountHandle(it) } }
  }

  private fun clearFields() {
    handleField().performTextClearance()
    usernameField().performTextClearance()
  }
}
