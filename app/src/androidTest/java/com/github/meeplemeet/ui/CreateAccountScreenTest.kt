/** Sections of this file were generated by ChatGPT */
package com.github.meeplemeet.ui

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.repositories.FirestoreHandlesRepository
import com.github.meeplemeet.model.repositories.FirestoreRepository
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.viewmodels.FirestoreHandlesViewModel
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.ui.theme.ThemeMode
import com.github.meeplemeet.utils.FirestoreTests
import java.util.UUID
import kotlinx.coroutines.runBlocking
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class CreateAccountScreenTest : FirestoreTests() {

  @get:Rule val compose = createComposeRule()

  private lateinit var repo: FirestoreRepository
  private lateinit var firestoreVm: FirestoreViewModel
  private lateinit var handlesRepo: FirestoreHandlesRepository
  private lateinit var handlesVm: FirestoreHandlesViewModel
  private lateinit var me: Account

  /* handles created by THIS test run */
  private val handlesCreated = mutableSetOf<String>()

  private val report = linkedMapOf<String, Boolean>()

  private fun handleField() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_FIELD)

  private fun handleError() = compose.onNodeWithTag(CreateAccountTestTags.HANDLE_ERROR)

  private fun usernameField() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_FIELD)

  private fun usernameError() = compose.onNodeWithTag(CreateAccountTestTags.USERNAME_ERROR)

  private fun submitBtn() = compose.onNodeWithTag(CreateAccountTestTags.SUBMIT_BUTTON)

  private inline fun checkpoint(name: String, crossinline block: () -> Unit) {
    runCatching { block() }.onSuccess { report[name] = true }.onFailure { report[name] = false }
  }

  @Before
  fun setup() = runBlocking {
    repo = FirestoreRepository()
    firestoreVm = FirestoreViewModel(repo)
    handlesRepo = FirestoreHandlesRepository()
    handlesVm = FirestoreHandlesViewModel(handlesRepo)

    val bootstrapRepo = FirestoreRepository()
    val uid = "uid_" + UUID.randomUUID().toString().take(8)
    me = bootstrapRepo.createAccount(uid, "Frank", "frank@test.com", null)

    compose.setContent {
      AppTheme(ThemeMode.DARK) {
        CreateAccountScreen(
            firestoreVM = firestoreVm,
            handlesVM = handlesVm,
            account = me,
            onCreate = { report["onCreate triggered"] = true })
      }
    }
  }

  /* ---------- single fat test that covers all old cases ---------- */
  @Test
  fun full_smoke_all_cases() = runBlocking {

    /* === 1. initial state === */
    handleField().apply { checkpoint("Handle field initially empty") { assertTextContains("") } }
    usernameField().apply {
      checkpoint("Username field initially empty") { assertTextContains("") }
    }

    /* === 2. empty username → button disabled === */
    val h1 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h1)
    submitBtn().apply { checkpoint("Button disabled with empty username") { assertIsNotEnabled() } }

    /* === 3. handle already taken === */
    val taken = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handlesRepo.createAccountHandle(me.uid, taken)
    handleField().performTextClearance()
    handleField().performTextInput(taken)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitUntil(timeoutMillis = 3_000) { handlesVm.errorMessage.value.isNotEmpty() }
    checkpoint("Error message for taken handle") {
      handleError().assertTextContains("Handle already taken", substring = true)
    }

    /* === 4. empty handle → no creation === */
    val startCallCount = report["onCreate triggered"] == true
    handleField().performTextClearance()
    usernameField().performTextInput("Frank")
    submitBtn().performClick()
    compose.waitForIdle()
    checkpoint("Empty handle does NOT trigger onCreate") {
      (report["onCreate triggered"] == true) == startCallCount
    }

    /* === 5. valid input → success === */
    val h2 = "h_" + UUID.randomUUID().toString().take(8).also { handlesCreated += it }
    handleField().performTextInput(h2)
    usernameField().performTextInput("Frank")
    submitBtn().performClick()

    compose.waitUntil(timeoutMillis = 5_000) { report.containsKey("onCreate triggered") }
    checkpoint("Valid creation persists handle") {
      runBlocking { handlesRepo.handleForAccountExists(me.uid, h2) }
    }

    /* === 6. delete username while filled → error shown === */
    usernameField().performTextClearance()
    compose.waitForIdle()
    checkpoint("Clearing username shows empty error") {
      usernameError().assertTextContains("Username cannot be empty", substring = true)
    }

    /* ---------- summary ---------- */
    val failed = report.filterValues { !it }.keys
    println(
        "Smoke: ${report.size - failed.size}/${report.size} OK" +
            (if (failed.isNotEmpty()) " → $failed" else ""))
    Assert.assertTrue("Failures: $failed", failed.isNotEmpty())
  }

  @After
  fun tearDown() = runBlocking {
    handlesCreated.forEach { runCatching { handlesRepo.deleteAccountHandle(it) } }
  }
}
