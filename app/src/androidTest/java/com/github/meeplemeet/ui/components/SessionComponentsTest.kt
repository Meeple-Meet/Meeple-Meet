// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
// It was then optimized using LLM and manual iterations to cover more paths in less tests
package com.github.meeplemeet.ui.components

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.shared.game.Game
import com.github.meeplemeet.model.shared.location.Location
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class SessionComponentsTest {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  private var oldLocale: Locale? = null

  @Before
  fun forceStableLocale() {
    oldLocale = Locale.getDefault()
    Locale.setDefault(Locale.US)
  }

  @After
  fun restoreLocale() {
    oldLocale?.let { Locale.setDefault(it) }
  }

  private fun set(content: @Composable () -> Unit) {
    composeRule.setContent { AppTheme { content() } }
  }

  private fun hasTextDifferentFrom(oldText: String) =
      SemanticsMatcher("Text != '$oldText'") { node ->
        node.config[SemanticsProperties.EditableText].text != oldText
      }

  /* ====================== SECTION / LABELS / TEXTFIELDS ====================== */

  @Test
  fun labeledTextField_independence_placeholder_roundtrip_and_multi_callbacks() {
    var a by mutableStateOf("")
    var b by mutableStateOf("")
    var calls = 0
    var last = ""

    set {
      Column {
        LabeledTextField(
            label = "Marco",
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              last = s
            },
            placeholder = "Root",
            singleLine = true,
            modifier = Modifier.testTag("ltf-A"))
        LabeledTextField(
            label = "Alex",
            value = b,
            onValueChange = { b = it },
            placeholder = "Spirit Island",
            singleLine = true,
            modifier = Modifier.testTag("ltf-B"))
      }
    }

    // Both placeholders visible initially
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText("Spirit Island", useUnmergedTree = true).assertExists()

    val tfA = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-A"))
    val tfB = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-B"))
    tfA.performTextInput("Arcs")
    tfB.performTextInput("Ahoy")
    tfA.assertTextEquals("Arcs")
    tfB.assertTextEquals("Ahoy")

    tfA.performTextReplacement("")
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onAllNodesWithText("Spirit Island", useUnmergedTree = true).assertCountEquals(0)

    composeRule.runOnIdle { assert(calls >= 2) }
    composeRule.runOnIdle { assert(last == "Arcs" || last.isEmpty()) }
  }

  @Test
  fun section_and_all_labeled_textfield_paths_in_one() {
    var styledValue by mutableStateOf("")
    var dynamicLabel by mutableStateOf("Game Label")

    set {
      Column {
        // Section
        SectionCard(modifier = Modifier.testTag("section-default")) {
          Text("InsideDefault", Modifier.testTag("inside-default"))
        }
        SectionCard(
            modifier = Modifier.testTag("section-custom"), contentPadding = PaddingValues(24.dp)) {
              UnderlinedLabel("CustomPad")
            }

        // 1) Single-line
        var v1 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "Game title",
            value = v1,
            onValueChange = { v1 = it },
            placeholder = "Type…",
            singleLine = true,
            modifier = Modifier.testTag("ltf-single"))

        // 2) Multiline
        var v2 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "House rules / notes",
            value = v2,
            onValueChange = { v2 = it },
            placeholder = "Multi…",
            singleLine = false,
            modifier = Modifier.testTag("ltf-multi"))

        // 3) Styled + external state + empty placeholder branch (+ dynamic label)
        LabeledTextField(
            label = dynamicLabel,
            value = styledValue,
            onValueChange = { styledValue = it },
            placeholder = "",
            labelTextStyle = MaterialTheme.typography.bodyLarge,
            labelTextColor = MaterialTheme.colorScheme.primary,
            outlinedTextStyle = MaterialTheme.typography.bodyMedium,
            singleLine = true,
            modifier = Modifier.testTag("lt-styled"))
      }
    }

    // Section bits
    composeRule.onNodeWithTag("section-default").assertExists()
    composeRule.onNodeWithTag("inside-default").assertExists()
    composeRule.onNodeWithTag("section-custom").assertExists()
    composeRule.onNodeWithTag(ComponentsTestTags.UNDERLINED_LABEL).assertExists()
    composeRule.onNodeWithText("CustomPad").assertExists()

    // Single-line
    composeRule.onNodeWithText("Game title").assertExists()
    composeRule.onNodeWithText("Type…", useUnmergedTree = true).assertExists()
    val tfSingle = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-single"))
    tfSingle.performTextInput("Catan")
    tfSingle.assertTextEquals("Catan")
    composeRule.onNode(hasTestTag("ltf-single") and hasImeAction(ImeAction.Done)).performImeAction()

    // Multiline
    composeRule
        .onNode(hasSetTextAction() and hasTestTag("ltf-multi"))
        .performTextInput("Setup:\nDraft cards\nEngine build")
    composeRule.onNodeWithTag("ltf-multi").assertTextContains("Engine build", substring = true)

    // Styled + external update + replacement round-trip + dynamic label recomposition
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("")
    composeRule.runOnUiThread { styledValue = "abc" }
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("abc")
    val tfStyled = composeRule.onNode(hasTestTag("lt-styled") and hasSetTextAction())
    tfStyled.performTextReplacement("X")
    tfStyled.performImeAction()
    tfStyled.assertTextEquals("X")
    composeRule.onNodeWithText("Game Label").assertExists()
    composeRule.runOnUiThread { dynamicLabel = "Game Label (upd)" }
    composeRule.onNodeWithText("Game Label (upd)").assertExists()
  }

  /* ====================== ICON TEXTFIELDS + COUNT BUBBLE ====================== */

  @Test
  fun iconTextField_all_paths_and_countBubble_in_one() {
    var calls = 0
    var recorded = ""

    var toggleEditable by mutableStateOf(false)
    var toggleValue by mutableStateOf("RO")

    set {
      Column {
        // 1) Editable
        var a by remember { mutableStateOf("") }
        IconTextField(
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              recorded = s
            },
            placeholder = "Find game",
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading") },
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing") },
            modifier = Modifier.testTag("iconTF-calls"))

        // 2) Read-only
        var ro by remember { mutableStateOf("Locked") }
        IconTextField(
            value = ro,
            onValueChange = { ro = it },
            placeholder = "ignored",
            editable = false,
            leadingIcon = null,
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing-only") },
            modifier = Modifier.testTag("iconTF-readonly"))

        // 3) Toggle readOnly → editable
        IconTextField(
            value = toggleValue,
            onValueChange = { toggleValue = it },
            placeholder = "ignored",
            editable = toggleEditable,
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading-on") },
            trailingIcon = null,
            modifier = Modifier.testTag("iconTF-toggle"))

        // CountBubble variants
        Column {
          CountBubble(42)
          CountBubble(0)
          CountBubble(-1)
        }
      }
    }

    // (1) Calls + icons + placeholder hide/show
    composeRule.onNodeWithContentDescription("leading").assertExists()
    composeRule.onNodeWithContentDescription("trailing").assertExists()
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()
    val tfCalls = composeRule.onNode(hasTestTag("iconTF-calls") and hasSetTextAction())
    tfCalls.performTextInput("A")
    tfCalls.performTextInput("B")
    tfCalls.assert(hasText("AB"))
    composeRule.runOnIdle { assert(calls >= 2 && recorded == "AB") }
    tfCalls.performTextReplacement("")
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()

    // (2) Read-only
    composeRule.onNodeWithContentDescription("trailing-only").assertExists()
    val ro = composeRule.onNodeWithTag("iconTF-readonly")
    ro.assert(hasSetTextAction().not())
    ro.assert(hasText("Locked"))

    // (3) Toggle
    val toggle = composeRule.onNodeWithTag("iconTF-toggle")
    toggle.assert(hasSetTextAction().not())
    toggle.assert(hasText("RO"))
    composeRule.onNodeWithContentDescription("leading-on").assertExists()
    composeRule.runOnUiThread { toggleValue = "EXT" }
    toggle.assert(hasText("EXT"))
    composeRule.runOnUiThread { toggleEditable = true }
    val editableNode = composeRule.onNode(hasTestTag("iconTF-toggle") and hasSetTextAction())
    editableNode.performTextInput("-ok")
    editableNode.assert(hasText("EXT", substring = true))
    editableNode.assert(hasText("-ok", substring = true))

    // CountBubble checks
    composeRule.onAllNodesWithTag(ComponentsTestTags.COUNT_BUBBLE_TEXT).assertCountEquals(3)
    composeRule.onAllNodesWithText("42").assertCountEquals(1)
    composeRule.onAllNodesWithText("0").assertCountEquals(1)
    composeRule.onAllNodesWithText("-1").assertCountEquals(1)
  }

  /* ====================== PARTICIPANT CHIP ====================== */

  @Test
  fun participantChip_all_paths_in_one() {
    var addCount = 0
    var removeCount = 0
    var nonClickableCount = 0
    val addName = "Reiner Knizia"
    val remName = "Uwe Rosenberg"
    val longName = "Extremely Long Eurogame Enthusiasts Guild of Basel"
    val identity = Account(uid = "x", name = "Bruno Cathala", email = "", handle = "")
    var received: Account? = null

    set {
      Column {
        ParticipantChip(
            account = Account(uid = "1", name = addName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { addCount++ },
            textColor = MaterialTheme.colorScheme.primary,
            textModifier = Modifier.testTag("chip-text-a"),
            modifier = Modifier.testTag("chip-a"))
        ParticipantChip(
            account = Account(uid = "2", name = remName, email = "", handle = ""),
            action = ParticipantAction.Remove,
            onClick = { removeCount++ },
            textModifier = Modifier.testTag("chip-text-b"),
            modifier = Modifier.testTag("chip-b"))
        ParticipantChip(
            account = Account(uid = "3", name = longName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { /* no-op */},
            modifier = Modifier.testTag("chip-long"))
        ParticipantChip(
            account = identity,
            action = ParticipantAction.Add,
            onClick = {
              received = it
              nonClickableCount++
            },
            textModifier = Modifier.testTag("chip-text-nc"),
            modifier = Modifier.testTag("chip-nc"))
      }
    }

    composeRule.onNodeWithText(addName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText(remName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-a", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-b", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-long").assertExists()

    // Exactly one clickable per chip
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-a")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-b")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-nc")))
        .assertCountEquals(1)

    // Add chip must not expose Remove tag (and vice versa)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$addName", useUnmergedTree = true)
        .assertCountEquals(0)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$remName", useUnmergedTree = true)
        .assertCountEquals(0)

    // Non-clickable text should not have a click action
    composeRule.onNodeWithTag("chip-text-nc", useUnmergedTree = true).assert(hasClickAction().not())

    // Click the action buttons
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$addName", useUnmergedTree = true)
        .performClick()
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$remName", useUnmergedTree = true)
        .performClick()

    // Click the Add button on the identity chip
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:${identity.name}", useUnmergedTree = true)
        .performClick()

    composeRule.runOnIdle {
      assert(addCount == 1)
      assert(removeCount == 1)
      assert(nonClickableCount == 1)
      assert(received === identity)
    }
  }

  /* ====================== TWO-PER-ROW GRID ====================== */

  @Test
  fun twoPerRowGrid_odd_then_even_recompose_and_rowsModifier_seen() {
    var data by mutableStateOf(listOf("Azul", "Brass", "Catan"))
    set {
      TwoPerRowGrid(
          items = data,
          modifier = Modifier.testTag("grid"),
          rowsModifier = Modifier.testTag("rowMod")) { item, mod ->
            Box(mod.semantics {}) { Text("Cell $item") }
          }
    }

    composeRule.onNodeWithText("Cell Azul").assertExists()
    composeRule.onNodeWithText("Cell Catan").assertExists()

    assert(
        composeRule
            .onAllNodes(hasTestTag("rowMod"), useUnmergedTree = true)
            .fetchSemanticsNodes()
            .isNotEmpty())

    composeRule.runOnUiThread { data = listOf("Azul", "Brass", "Catan", "Dune") }
    composeRule.onNodeWithText("Cell Dune").assertExists()
  }

  /* ====================== DATE & TIME PICKERS ====================== */

  @Test
  fun datePicker_displays_and_opens_dialog() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    var date by mutableStateOf<LocalDate?>(initial)
    set {
      Column {
        DatePickerDockedField(
            value = date,
            onValueChange = { date = it },
            label = "Game date",
            displayFormatter = fmt,
            zoneId = zone,
            editable = true,
            testTagDate = SessionTestTags.DATE_FIELD + "0")
        // Non-editable date field
        DatePickerDockedField(
            value = LocalDate.of(2024, 12, 1),
            onValueChange = {},
            label = "Read-only date",
            editable = false)
      }
    }

    // Check initial date is displayed
    composeRule.onNodeWithText(initial.format(fmt)).assertExists()

    // Check non-editable field doesn't have pick button
    composeRule.onNodeWithText("01/12/2024").assertExists()

    // External value change
    val external = LocalDate.of(2026, 6, 9)
    composeRule.runOnUiThread { date = external }
    composeRule.onNodeWithText(external.format(fmt)).assertExists()

    // Check null date handling
    composeRule.runOnUiThread { date = null }
    composeRule
        .onNodeWithTag(SessionTestTags.DATE_FIELD + "0", useUnmergedTree = true)
        .assertTextEquals("")
  }

  @Test
  fun timePicker_displays_and_opens_dialog() {
    var time by mutableStateOf<LocalTime?>(null)
    set {
      Column {
        TimePickerField(
            value = time, onValueChange = { time = it }, label = "Start time", is24Hour = true)
        // With initial value
        TimePickerField(
            value = LocalTime.of(14, 30), onValueChange = {}, label = "End time", is24Hour = false)
      }
    }

    // Check time picker button exists
    composeRule.onAllNodesWithTag(SessionTestTags.TIME_PICK_BUTTON).assertCountEquals(2)

    // Check initial time is displayed
    composeRule.onNodeWithText("14:30").assertExists()

    // External value change
    composeRule.runOnUiThread { time = LocalTime.of(19, 45) }
    composeRule.onNodeWithText("19:45").assertExists()

    // Open time picker
    composeRule.onAllNodesWithTag(SessionTestTags.TIME_PICK_BUTTON)[0].performClick()
    composeRule.onNodeWithTag(ComponentsTestTags.TIME_PICKER, useUnmergedTree = true).assertExists()

    // Click OK button to close
    composeRule
        .onNodeWithTag(SessionTestTags.TIME_PICKER_OK_BUTTON, useUnmergedTree = true)
        .performClick()
  }

  @Test
  fun datePicker_dialog_cancel_and_confirm() {
    val zone = ZoneId.of("UTC")
    val initial = LocalDate.of(2025, 3, 15)

    var date by mutableStateOf<LocalDate?>(initial)
    set {
      DatePickerDockedField(
          value = date,
          onValueChange = { date = it },
          label = "Pick date",
          zoneId = zone,
          editable = true)
    }

    // Open picker
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()

    // Cancel button should exist and dismiss dialog
    composeRule.onNodeWithTag("date-picker-cancel", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("date-picker-cancel", useUnmergedTree = true).performClick()

    // Re-open and confirm
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()

    // Date picker should be visible
    composeRule.onNodeWithTag(ComponentsTestTags.DATE_PICKER, useUnmergedTree = true).assertExists()

    // OK button should exist
    composeRule
        .onNodeWithTag(SessionTestTags.DATE_PICKER_OK_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeRule.waitForIdle()
  }

  /* ====================== SEARCH FIELDS ====================== */

  @Test
  fun searchDropdown_loading_vs_empty_and_clear_and_clickSuggestion() {
    var q by mutableStateOf("")
    var loading by mutableStateOf(false)
    var picked: String? = null
    val suggestions = listOf("Catan", "Carcassonne", "Camel Up")

    set {
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = {
            q = it
            loading = true
          },
          suggestions = if (loading) emptyList() else suggestions,
          onSuggestionClick = { picked = it },
          getPrimaryText = { it },
          isLoading = loading,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    // Loading branch visible
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_LOADING, useUnmergedTree = true)
        .assertExists()

    // Show suggestions
    composeRule.runOnUiThread { loading = false }
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .assertExists()
        .performClick()
    composeRule.runOnIdle { assert(picked == "Catan") }

    // Make query non-empty again
    composeRule.runOnUiThread { q = "C" }
    tf.performTextInput("a")
    composeRule.runOnUiThread { loading = false }

    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodesWithContentDescription("Clear", useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }
    composeRule.onNodeWithContentDescription("Clear", useUnmergedTree = true).performClick()

    // Popup should be closed after clearing
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun searchDropdown_showWhenEmptyQuery_true_and_false_behaviors() {
    var qTrue by mutableStateOf("x")
    var qFalse by mutableStateOf("")
    val data = listOf("Azul", "Brass", "Catan")

    set {
      Column {
        SearchDropdownField(
            label = "S1",
            query = qTrue,
            onQueryChange = { qTrue = it },
            suggestions = data,
            onSuggestionClick = {},
            getPrimaryText = { it },
            isLoading = false,
            showWhenEmptyQuery = true,
            placeholder = "P1")
        SearchDropdownField(
            label = "S2",
            query = qFalse,
            onQueryChange = { qFalse = it },
            suggestions = data,
            onSuggestionClick = {},
            getPrimaryText = { it },
            isLoading = false,
            showWhenEmptyQuery = false,
            placeholder = "P2")
      }
    }

    // S1: empty query still shows suggestions
    val tf1 = composeRule.onAllNodes(hasSetTextAction())[0]
    tf1.performClick()
    tf1.performTextReplacement("")
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}azul", useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}azul", useUnmergedTree = true)
        .performClick()
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)

    // S2: type then clear should hide suggestions
    val tf2 = composeRule.onAllNodes(hasSetTextAction())[1]
    tf2.performClick()
    tf2.performTextInput("ca")
    composeRule
        .onAllNodesWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .onFirst()
        .assertExists()
    tf2.performTextReplacement("")
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun searchDropdown_shows_nothing_when_no_suggestions() {
    var q by mutableStateOf("")
    val emptyList = emptyList<String>()

    set {
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList,
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = false,
          showWhenEmptyQuery = true,
          emptyText = "No games found")
    }

    // Type a query that returns no results
    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("xyz")

    // Empty state should be visible
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertDoesNotExist()
    composeRule.onNodeWithText("No games found", useUnmergedTree = true).assertDoesNotExist()
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_EMPTY, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  /* ====================== DISCRETE PILL SLIDER ====================== */

  @Test
  fun discretePillSlider_renders_with_default_and_custom_colors() {
    val range = 1f..10f
    val values = 3f..7f
    val steps = 8

    set {
      Column {
        // Default colors
        DiscretePillSlider(
            range = range,
            values = values,
            steps = steps,
            modifier = Modifier.testTag("slider-default"))

        // Custom colors
        DiscretePillSlider(
            range = range,
            values = values,
            steps = steps,
            sliderColors =
                SliderDefaults.colors(
                    activeTrackColor = MaterialTheme.colorScheme.primary,
                    inactiveTrackColor = MaterialTheme.colorScheme.secondary,
                    thumbColor = MaterialTheme.colorScheme.error),
            modifier = Modifier.testTag("slider-custom"),
            sliderModifier = Modifier.testTag("slider-inner"))
      }
    }

    composeRule.onNodeWithTag("slider-default").assertExists()
    composeRule.onNodeWithTag("slider-custom").assertExists()
    composeRule.onNodeWithTag("slider-inner").assertExists()
  }

  /* ====================== TOP BAR WITH DIVIDER ====================== */

  @Test
  fun topBarWithDivider_displays_title_and_back_button() {
    var backPressed = false

    set { TopBarWithDivider(text = "Session Details", onReturn = { backPressed = true }) }

    composeRule.onNodeWithTag(ComponentsTestTags.TOP_APP_BAR).assertExists()
    composeRule.onNodeWithText("Session Details").assertExists()
    composeRule
        .onNodeWithTag(com.github.meeplemeet.ui.navigation.NavigationTestTags.GO_BACK_BUTTON)
        .assertExists()
        .performClick()

    composeRule.runOnIdle { assert(backPressed) }
  }

  @Test
  fun topBarWithDivider_displays_with_trailing_icons() {
    var iconClicked = false

    set {
      TopBarWithDivider(
          text = "Edit Session",
          onReturn = {},
          trailingIcons = {
            IconButton(
                onClick = { iconClicked = true },
                modifier = Modifier.testTag("trailing-icon-btn")) {
                  Icon(Icons.Default.Close, contentDescription = "Close")
                }
          })
    }

    composeRule.onNodeWithTag(ComponentsTestTags.TOP_APP_BAR).assertExists()
    composeRule.onNodeWithText("Edit Session").assertExists()
    composeRule.onNodeWithTag("trailing-icon-btn").assertExists().performClick()

    composeRule.runOnIdle { assert(iconClicked) }
  }

  /* ====================== GAME & LOCATION ====================== */

  @Test
  fun game_and_location_fields_wrappers_cover_items_and_coordinates() {
    var qGame by mutableStateOf("")
    var qLoc by mutableStateOf("")
    var pickedGame: Game? = null
    var pickedLoc: Location? = null

    val g1 =
        Game(
            uid = "g1",
            name = "Catan",
            description = "",
            imageURL = "",
            minPlayers = 3,
            maxPlayers = 4,
            recommendedPlayers = 4,
            averagePlayTime = 60,
            genres = emptyList())
    val g2 =
        Game(
            uid = "g2",
            name = "Carcassonne",
            description = "",
            imageURL = "",
            minPlayers = 2,
            maxPlayers = 5,
            recommendedPlayers = 4,
            averagePlayTime = 45,
            genres = emptyList())

    val loc = Location(name = "EPFL Esplanade", latitude = 46.5191, longitude = 6.5668)

    set {
      Column {
        GameSearchField(
            query = qGame,
            onQueryChange = { qGame = it },
            results = listOf(g1, g2),
            onPick = { pickedGame = it })
        LocationSearchField(
            query = qLoc,
            onQueryChange = { qLoc = it },
            results = listOf(loc),
            onPick = { pickedLoc = it })
      }
    }

    // Game flow
    val tfGame = composeRule.onAllNodes(hasSetTextAction())[0]
    tfGame.performClick()
    tfGame.performTextInput("ca")
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .performClick()
    composeRule.runOnIdle { assert(pickedGame?.uid == "g1") }

    // Location flow + coordinates rendering
    val tfLoc = composeRule.onAllNodes(hasSetTextAction())[1]
    tfLoc.performClick()
    tfLoc.performTextInput("epfl")
    composeRule.onNodeWithText("46.51910, 6.56680").assertExists()
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.SEARCH_ITEM_PREFIX}epfl_esplanade", useUnmergedTree = true)
        .performClick()
    composeRule.runOnIdle { assert(pickedLoc?.name == "EPFL Esplanade") }
  }
}
