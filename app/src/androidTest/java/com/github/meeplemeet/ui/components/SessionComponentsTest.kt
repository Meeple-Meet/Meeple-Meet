// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
// It was then optimized using LLM and manual iterations to cover more paths in less tests
package com.github.meeplemeet.ui.components

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class SessionComponentsTest {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  private var oldLocale: Locale? = null

  @Before
  fun forceStableLocale() {
    oldLocale = Locale.getDefault()
    Locale.setDefault(Locale.US)
  }

  @After
  fun restoreLocale() {
    oldLocale?.let { Locale.setDefault(it) }
  }

  private fun set(content: @Composable () -> Unit) {
    composeRule.setContent { AppTheme { content() } }
  }

  private fun hasTextDifferentFrom(oldText: String) =
      SemanticsMatcher("Text != '$oldText'") { node ->
        node.config[SemanticsProperties.EditableText].text != oldText
      }

  /* ====================== SECTION / LABELS / TEXTFIELDS ====================== */

  @Test
  fun labeledTextField_independence_placeholder_roundtrip_and_multi_callbacks() {
    var a by mutableStateOf("")
    var b by mutableStateOf("")
    var calls = 0
    var last = ""

    set {
      Column {
        LabeledTextField(
            label = "Marco",
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              last = s
            },
            placeholder = "Root",
            singleLine = true,
            modifier = Modifier.testTag("ltf-A"))
        LabeledTextField(
            label = "Alex",
            value = b,
            onValueChange = { b = it },
            placeholder = "Spirit Island",
            singleLine = true,
            modifier = Modifier.testTag("ltf-B"))
      }
    }

    // Both placeholders visible initially
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText("Spirit Island", useUnmergedTree = true).assertExists()

    val tfA = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-A"))
    val tfB = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-B"))
    tfA.performTextInput("Arcs")
    tfB.performTextInput("Ahoy")
    tfA.assertTextEquals("Arcs")
    tfB.assertTextEquals("Ahoy")

    tfA.performTextReplacement("")
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onAllNodesWithText("Spirit Island", useUnmergedTree = true).assertCountEquals(0)

    composeRule.runOnIdle { assert(calls >= 2) }
    composeRule.runOnIdle { assert(last == "Arcs" || last.isEmpty()) }
  }

  @Test
  fun section_and_all_labeled_textfield_paths_in_one() {
    var styledValue by mutableStateOf("")
    var dynamicLabel by mutableStateOf("Game Label")

    set {
      Column {
        // Section
        SectionCard(modifier = Modifier.testTag("section-default")) {
          Text("InsideDefault", Modifier.testTag("inside-default"))
        }
        SectionCard(
            modifier = Modifier.testTag("section-custom"), contentPadding = PaddingValues(24.dp)) {
              UnderlinedLabel("CustomPad")
            }

        // 1) Single-line
        var v1 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "Game title",
            value = v1,
            onValueChange = { v1 = it },
            placeholder = "Type…",
            singleLine = true,
            modifier = Modifier.testTag("ltf-single"))

        // 2) Multiline
        var v2 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "House rules / notes",
            value = v2,
            onValueChange = { v2 = it },
            placeholder = "Multi…",
            singleLine = false,
            modifier = Modifier.testTag("ltf-multi"))

        // 3) Styled + external state + empty placeholder branch (+ dynamic label)
        LabeledTextField(
            label = dynamicLabel,
            value = styledValue,
            onValueChange = { styledValue = it },
            placeholder = "",
            labelTextStyle = MaterialTheme.typography.bodyLarge,
            labelTextColor = MaterialTheme.colorScheme.primary,
            outlinedTextStyle = MaterialTheme.typography.bodyMedium,
            singleLine = true,
            modifier = Modifier.testTag("lt-styled"))
      }
    }

    // Section bits
    composeRule.onNodeWithTag("section-default").assertExists()
    composeRule.onNodeWithTag("inside-default").assertExists()
    composeRule.onNodeWithTag("section-custom").assertExists()
    composeRule.onNodeWithTag(ComponentsTestTags.UNDERLINED_LABEL).assertExists()
    composeRule.onNodeWithText("CustomPad").assertExists()

    // Single-line
    composeRule.onNodeWithText("Game title").assertExists()
    composeRule.onNodeWithText("Type…", useUnmergedTree = true).assertExists()
    val tfSingle = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-single"))
    tfSingle.performTextInput("Catan")
    tfSingle.assertTextEquals("Catan")
    composeRule.onNode(hasTestTag("ltf-single") and hasImeAction(ImeAction.Done)).performImeAction()

    // Multiline
    composeRule
        .onNode(hasSetTextAction() and hasTestTag("ltf-multi"))
        .performTextInput("Setup:\nDraft cards\nEngine build")
    composeRule.onNodeWithTag("ltf-multi").assertTextContains("Engine build", substring = true)

    // Styled + external update + replacement round-trip + dynamic label recomposition
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("")
    composeRule.runOnUiThread { styledValue = "abc" }
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("abc")
    val tfStyled = composeRule.onNode(hasTestTag("lt-styled") and hasSetTextAction())
    tfStyled.performTextReplacement("X")
    tfStyled.performImeAction()
    tfStyled.assertTextEquals("X")
    composeRule.onNodeWithText("Game Label").assertExists()
    composeRule.runOnUiThread { dynamicLabel = "Game Label (upd)" }
    composeRule.onNodeWithText("Game Label (upd)").assertExists()
  }

  /* ====================== ICON TEXTFIELDS + COUNT BUBBLE ====================== */

  @Test
  fun iconTextField_all_paths_and_countBubble_in_one() {
    var calls = 0
    var recorded = ""

    var toggleEditable by mutableStateOf(false)
    var toggleValue by mutableStateOf("RO")

    set {
      Column {
        // 1) Editable
        var a by remember { mutableStateOf("") }
        IconTextField(
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              recorded = s
            },
            placeholder = "Find game",
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading") },
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing") },
            modifier = Modifier.testTag("iconTF-calls"))

        // 2) Read-only
        var ro by remember { mutableStateOf("Locked") }
        IconTextField(
            value = ro,
            onValueChange = { ro = it },
            placeholder = "ignored",
            editable = false,
            leadingIcon = null,
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing-only") },
            modifier = Modifier.testTag("iconTF-readonly"))

        // 3) Toggle readOnly → editable
        IconTextField(
            value = toggleValue,
            onValueChange = { toggleValue = it },
            placeholder = "ignored",
            editable = toggleEditable,
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading-on") },
            trailingIcon = null,
            modifier = Modifier.testTag("iconTF-toggle"))

        // CountBubble variants
        Column {
          CountBubble(42)
          CountBubble(0)
          CountBubble(-1)
        }
      }
    }

    // (1) Calls + icons + placeholder hide/show
    composeRule.onNodeWithContentDescription("leading").assertExists()
    composeRule.onNodeWithContentDescription("trailing").assertExists()
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()
    val tfCalls = composeRule.onNode(hasTestTag("iconTF-calls") and hasSetTextAction())
    tfCalls.performTextInput("A")
    tfCalls.performTextInput("B")
    tfCalls.assert(hasText("AB"))
    composeRule.runOnIdle { assert(calls >= 2 && recorded == "AB") }
    tfCalls.performTextReplacement("")
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()

    // (2) Read-only
    composeRule.onNodeWithContentDescription("trailing-only").assertExists()
    val ro = composeRule.onNodeWithTag("iconTF-readonly")
    ro.assert(hasSetTextAction().not())
    ro.assert(hasText("Locked"))

    // (3) Toggle
    val toggle = composeRule.onNodeWithTag("iconTF-toggle")
    toggle.assert(hasSetTextAction().not())
    toggle.assert(hasText("RO"))
    composeRule.onNodeWithContentDescription("leading-on").assertExists()
    composeRule.runOnUiThread { toggleValue = "EXT" }
    toggle.assert(hasText("EXT"))
    composeRule.runOnUiThread { toggleEditable = true }
    val editableNode = composeRule.onNode(hasTestTag("iconTF-toggle") and hasSetTextAction())
    editableNode.performTextInput("-ok")
    editableNode.assert(hasText("EXT", substring = true))
    editableNode.assert(hasText("-ok", substring = true))

    // CountBubble checks
    composeRule.onAllNodesWithTag(ComponentsTestTags.COUNT_BUBBLE_TEXT).assertCountEquals(3)
    composeRule.onAllNodesWithText("42").assertCountEquals(1)
    composeRule.onAllNodesWithText("0").assertCountEquals(1)
    composeRule.onAllNodesWithText("-1").assertCountEquals(1)
  }

  /* ====================== PARTICIPANT CHIP ====================== */

  @Test
  fun participantChip_all_paths_in_one() {
    var addCount = 0
    var removeCount = 0
    var nonClickableCount = 0
    val addName = "Reiner Knizia"
    val remName = "Uwe Rosenberg"
    val longName = "Extremely Long Eurogame Enthusiasts Guild of Basel"
    val identity = Account(uid = "x", name = "Bruno Cathala", email = "", handle = "")
    var received: Account? = null

    set {
      Column {
        ParticipantChip(
            account = Account(uid = "1", name = addName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { addCount++ },
            textColor = MaterialTheme.colorScheme.primary,
            textModifier = Modifier.testTag("chip-text-a"),
            modifier = Modifier.testTag("chip-a"))
        ParticipantChip(
            account = Account(uid = "2", name = remName, email = "", handle = ""),
            action = ParticipantAction.Remove,
            onClick = { removeCount++ },
            textModifier = Modifier.testTag("chip-text-b"),
            modifier = Modifier.testTag("chip-b"))
        ParticipantChip(
            account = Account(uid = "3", name = longName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { /* no-op */},
            modifier = Modifier.testTag("chip-long"))
        ParticipantChip(
            account = identity,
            action = ParticipantAction.Add,
            onClick = {
              received = it
              nonClickableCount++
            },
            textModifier = Modifier.testTag("chip-text-nc"),
            modifier = Modifier.testTag("chip-nc"))
      }
    }

    composeRule.onNodeWithText(addName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText(remName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-a", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-b", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-long").assertExists()

    // Exactly one clickable per chip
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-a")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-b")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-nc")))
        .assertCountEquals(1)

    // Add chip must not expose Remove tag (and vice versa)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$addName", useUnmergedTree = true)
        .assertCountEquals(0)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$remName", useUnmergedTree = true)
        .assertCountEquals(0)

    // Non-clickable text should not have a click action
    composeRule.onNodeWithTag("chip-text-nc", useUnmergedTree = true).assert(hasClickAction().not())

    // Click the action buttons
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$addName", useUnmergedTree = true)
        .performClick()
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$remName", useUnmergedTree = true)
        .performClick()

    // Click the Add button on the identity chip
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:${identity.name}", useUnmergedTree = true)
        .performClick()

    composeRule.runOnIdle {
      assert(addCount == 1)
      assert(removeCount == 1)
      assert(nonClickableCount == 1)
      assert(received === identity)
    }
  }

  /* ====================== TWO-PER-ROW GRID ====================== */

  @Test
  fun twoPerRowGrid_odd_then_even_recompose_and_rowsModifier_seen() {
    var data by mutableStateOf(listOf("Azul", "Brass", "Catan"))
    set {
      TwoPerRowGrid(
          items = data,
          key = { it },
          modifier = Modifier.testTag("grid"),
          rowsModifier = Modifier.testTag("rowMod")) { item, mod ->
            Box(mod.semantics {}) { Text("Cell $item") }
          }
    }

    composeRule.onNodeWithText("Cell Azul").assertExists()
    composeRule.onNodeWithText("Cell Catan").assertExists()

    assert(
        composeRule
            .onAllNodes(hasTestTag("rowMod"), useUnmergedTree = true)
            .fetchSemanticsNodes()
            .isNotEmpty())

    composeRule.runOnUiThread { data = listOf("Azul", "Brass", "Catan", "Dune") }
    composeRule.onNodeWithText("Cell Dune").assertExists()
  }

  /* ====================== DATE & TIME PICKERS ====================== */

  @Ignore()
  @Test
  fun datePicker_cancel_then_confirm_and_timePicker_valueFlows() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    var date by mutableStateOf<LocalDate?>(initial)
    set {
      Column {
        DatePickerDockedField(
            value = date,
            onValueChange = { date = it },
            label = "Game date",
            displayFormatter = fmt,
            zoneId = zone,
            editable = true)
        TimePickerField(value = null, onValueChange = {}, label = "Tournament time")
      }
    }

    val dateNode = composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD)
    val initialText = dateNode.fetchSemanticsNode().config[SemanticsProperties.EditableText].text

    // Open -> Cancel (use test tag in unmerged tree)
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()
    composeRule.onNodeWithTag("date-picker-cancel", useUnmergedTree = true).performClick()
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assert(hasText(initial.format(fmt)))

    // Confirm
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule
        .onNodeWithTag(ComponentsTestTags.DATE_PICKER, useUnmergedTree = true)
        .performTouchInput { click(center) }
    composeRule.onNodeWithText("OK").performClick()
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assert(hasTextDifferentFrom(initialText))

    // External value change
    val external = LocalDate.of(2026, 6, 9)
    composeRule.runOnUiThread { date = external }
    composeRule.onNodeWithText(external.format(fmt)).assertExists()

    // Field click does not open
    composeRule.onNodeWithText("Tournament time").performClick()
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.TIME_PICKER, useUnmergedTree = true)
        .assertCountEquals(0)
    composeRule.onNodeWithTag(SessionTestTags.TIME_PICK_BUTTON).performClick()
    composeRule.onNodeWithTag(SessionTestTags.TIME_PICKER_OK_BUTTON).performClick()
  }

  /* ====================== SEARCH FIELDS ====================== */

  @Test
  fun searchDropdown_loading_vs_empty_and_clear_and_clickSuggestion() {
    var q by mutableStateOf("")
    var loading by mutableStateOf(false)
    var picked: String? = null
    val suggestions = listOf("Catan", "Carcassonne", "Camel Up")

    set {
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = {
            q = it
            loading = true
          },
          suggestions = if (loading) emptyList() else suggestions,
          onSuggestionClick = { picked = it },
          getPrimaryText = { it },
          isLoading = loading,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    // Loading branch visible
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_LOADING, useUnmergedTree = true)
        .assertExists()

    // Show suggestions
    composeRule.runOnUiThread { loading = false }
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .assertExists()
        .performClick()
    composeRule.runOnIdle { assert(picked == "Catan") }

    // Make query non-empty again
    composeRule.runOnUiThread { q = "C" }
    tf.performTextInput("a")
    composeRule.runOnUiThread { loading = false }

    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodesWithContentDescription("Clear", useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }
    composeRule.onNodeWithContentDescription("Clear", useUnmergedTree = true).performClick()

    // Popup should be closed after clearing
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)
  }

  @Test
  fun searchDropdown_showWhenEmptyQuery_true_and_false_behaviors() {
    var qTrue by mutableStateOf("x")
    var qFalse by mutableStateOf("")
    val data = listOf("Azul", "Brass", "Catan")

    set {
      Column {
        SearchDropdownField(
            label = "S1",
            query = qTrue,
            onQueryChange = { qTrue = it },
            suggestions = data,
            onSuggestionClick = {},
            getPrimaryText = { it },
            isLoading = false,
            showWhenEmptyQuery = true,
            placeholder = "P1")
        SearchDropdownField(
            label = "S2",
            query = qFalse,
            onQueryChange = { qFalse = it },
            suggestions = data,
            onSuggestionClick = {},
            getPrimaryText = { it },
            isLoading = false,
            showWhenEmptyQuery = false,
            placeholder = "P2")
      }
    }

    // S1: empty query still shows suggestions
    val tf1 = composeRule.onAllNodes(hasSetTextAction())[0]
    tf1.performClick()
    tf1.performTextReplacement("")
    composeRule
        .onNodeWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}azul", useUnmergedTree = true)
        .assertExists()
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}azul", useUnmergedTree = true)
        .performClick()
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)

    // S2: type then clear should hide suggestions
    val tf2 = composeRule.onAllNodes(hasSetTextAction())[1]
    tf2.performClick()
    tf2.performTextInput("ca")
    composeRule
        .onAllNodesWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .onFirst()
        .assertExists()
    tf2.performTextReplacement("")
    composeRule
        .onAllNodesWithTag(ComponentsTestTags.SEARCH_POPUP_SURFACE, useUnmergedTree = true)
        .assertCountEquals(0)
  }

  /* ====================== GAME & LOCATION ====================== */

  @Test
  fun game_and_location_fields_wrappers_cover_items_and_coordinates() {
    var qGame by mutableStateOf("")
    var qLoc by mutableStateOf("")
    var pickedGame: com.github.meeplemeet.model.structures.Game? = null
    var pickedLoc: com.github.meeplemeet.model.structures.Location? = null

    val g1 =
        com.github.meeplemeet.model.structures.Game(
            uid = "g1",
            name = "Catan",
            description = "",
            imageURL = "",
            minPlayers = 3,
            maxPlayers = 4,
            recommendedPlayers = 4,
            averagePlayTime = 60,
            genres = emptyList())
    val g2 =
        com.github.meeplemeet.model.structures.Game(
            uid = "g2",
            name = "Carcassonne",
            description = "",
            imageURL = "",
            minPlayers = 2,
            maxPlayers = 5,
            recommendedPlayers = 4,
            averagePlayTime = 45,
            genres = emptyList())

    val loc =
        com.github.meeplemeet.model.structures.Location(
            name = "EPFL Esplanade", latitude = 46.5191, longitude = 6.5668)

    set {
      Column {
        GameSearchField(
            query = qGame,
            onQueryChange = { qGame = it },
            results = listOf(g1, g2),
            onPick = { pickedGame = it })
        LocationSearchField(
            query = qLoc,
            onQueryChange = { qLoc = it },
            results = listOf(loc),
            onPick = { pickedLoc = it })
      }
    }

    // Game flow
    val tfGame = composeRule.onAllNodes(hasSetTextAction())[0]
    tfGame.performClick()
    tfGame.performTextInput("ca")
    composeRule
        .onNodeWithTag("${ComponentsTestTags.SEARCH_ITEM_PREFIX}catan", useUnmergedTree = true)
        .performClick()
    composeRule.runOnIdle { assert(pickedGame?.uid == "g1") }

    // Location flow + coordinates rendering
    val tfLoc = composeRule.onAllNodes(hasSetTextAction())[1]
    tfLoc.performClick()
    tfLoc.performTextInput("epfl")
    composeRule.onNodeWithText("46.51910, 6.56680").assertExists()
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.SEARCH_ITEM_PREFIX}epfl_esplanade", useUnmergedTree = true)
        .performClick()
    composeRule.runOnIdle { assert(pickedLoc?.name == "EPFL Esplanade") }
  }
}
