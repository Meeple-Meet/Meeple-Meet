// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
package com.github.meeplemeet.ui.components

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.ui.SessionTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

/** Instrumentation tests for SessionComponents.kt */
@RunWith(AndroidJUnit4::class)
class SessionComponentsTest {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  private var oldLocale: Locale? = null

  @Before
  fun forceStableLocale() {
    oldLocale = Locale.getDefault()
    Locale.setDefault(Locale.US)
  }

  @After
  fun restoreLocale() {
    oldLocale?.let { Locale.setDefault(it) }
  }

  private fun set(content: @Composable () -> Unit) {
    composeRule.setContent { AppTheme { content() } }
  }
  // Custom matcher to check that the text is different from a given value
  private fun hasTextDifferentFrom(oldText: String) =
      SemanticsMatcher("Text != '$oldText'") { node ->
        node.config[SemanticsProperties.EditableText].text != oldText
      }

  private fun account(name: String = "Marco") =
      Account(uid = "1", name = name, email = "marco@epfl.ch", handle = "")

  private fun waitForText(text: String, timeoutMs: Long = 5_000, unmerged: Boolean = true) {
    composeRule.waitUntil(timeoutMs) {
      composeRule
          .onAllNodesWithText(text, useUnmergedTree = unmerged)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }
  }

  private fun waitForGone(text: String, timeoutMs: Long = 5_000, unmerged: Boolean = true) {
    composeRule.waitUntil(timeoutMs) {
      composeRule
          .onAllNodesWithText(text, useUnmergedTree = unmerged)
          .fetchSemanticsNodes()
          .isEmpty()
    }
  }

  /* ---------------- SectionCard ---------------- */

  @Test
  fun sectionCard_rendersChildContent_andAcceptsModifier() {
    set {
      SectionCard(modifier = Modifier.testTag("sectionCard")) {
        Text("Meeple inside card", Modifier.testTag("section-content"))
      }
    }
    composeRule.onNodeWithTag("sectionCard").assertExists().assertIsDisplayed()
    composeRule
        .onNodeWithTag("section-content")
        .assertIsDisplayed()
        .assertTextEquals("Meeple inside card")
  }

  @Test
  fun sectionCard_customPadding_stillDisplaysChildren() {
    set {
      SectionCard(
          modifier = Modifier.testTag("sectionCard2"), contentPadding = PaddingValues(24.dp)) {
            UnderlinedLabel("Padded setup")
          }
    }
    composeRule.onNodeWithText("Padded setup").assertIsDisplayed()
  }

  /* ---------------- UnderlinedLabel ---------------- */

  @Test
  fun underlinedLabel_showsGivenText() {
    set { UnderlinedLabel(text = "Underlined board game") }
    composeRule.onNodeWithText("Underlined board game").assertIsDisplayed()
  }

  @Test
  fun underlinedLabel_customStyleParams_stillRenders() {
    set { UnderlinedLabel(text = "Styled expansion") }
    composeRule.onNodeWithText("Styled expansion").assertIsDisplayed()
  }

  /* ---------------- LabeledTextField ---------------- */

  @Test
  fun labeledTextField_labelVisible_placeholderShows_typingUpdatesValue() {
    set {
      var value by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game title",
          value = value,
          onValueChange = { value = it },
          placeholder = "Type game…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF"))
    }

    composeRule.onNodeWithText("Game title").assertIsDisplayed()
    composeRule.onNodeWithText("Type game…", useUnmergedTree = true).assertIsDisplayed()

    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF"))
    tf.performClick()
    tf.performTextInput("Terraforming Mars")
    tf.assertTextEquals("Terraforming Mars")
    composeRule.onAllNodesWithText("Type game…").assertCountEquals(0)
  }

  @Test
  fun labeledTextField_multiline_mode_acceptsLongText() {
    set {
      var txt by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game description",
          value = txt,
          onValueChange = { txt = it },
          placeholder = "Multi…",
          singleLine = false,
          modifier = Modifier.testTag("labeledTF-multi"))
    }
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF-multi"))
    tf.performTextInput("Setup:\nDraft cards\nEngine build")
    tf.assertTextContains("Engine build", substring = true)
  }

  @Test
  fun labeledTextField_hasImeActionDone_performImeAction_noCrash() {
    set {
      var txt by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Submit",
          value = txt,
          onValueChange = { txt = it },
          placeholder = "rulebook…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF-ime"))
    }
    val tf = composeRule.onNode(hasTestTag("labeledTF-ime") and hasImeAction(ImeAction.Done))
    tf.performTextInput("Catan")
    tf.performImeAction()
    tf.assertTextEquals("Catan")
  }

  @Test
  fun labeledTextField_clearText_showsPlaceholderAgain() {
    set {
      var value by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game title",
          value = value,
          onValueChange = { value = it },
          placeholder = "Type game…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF-clear"))
    }
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF-clear"))
    tf.performTextInput("Azul")
    tf.assertTextEquals("Azul")
    tf.performTextReplacement("")
    waitForText("Type game…", unmerged = true)
    composeRule.onNodeWithText("Type game…", useUnmergedTree = true).assertIsDisplayed()
  }

  /* ---------------- IconTextField ---------------- */

  @Test
  fun iconTextField_leadingAndTrailingIcons_visible_andTextEditable() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "With meeples",
          leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading") },
          trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing") },
          modifier = Modifier.testTag("iconTF"))
    }
    composeRule.onNodeWithContentDescription("leading").assertIsDisplayed()
    composeRule.onNodeWithContentDescription("trailing").assertIsDisplayed()

    val iconTf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF"))
    iconTf.performTextInput("Carcassonne")
    iconTf.assertTextEquals("Carcassonne")
  }

  @Test
  fun iconTextField_withoutIcons_stillEditable_andShowsPlaceholder() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "No meeples",
          modifier = Modifier.testTag("iconTF-no-icons"))
    }
    waitForText("No meeples", unmerged = true)
    composeRule.onNodeWithText("No meeples", useUnmergedTree = true).assertIsDisplayed()

    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF-no-icons"))
    tf.performTextInput("Wingspan")
    tf.assertTextEquals("Wingspan")

    tf.performTextReplacement("")
    composeRule.onNodeWithTag("iconTF-no-icons").assertTextContains("No meeples", substring = true)
  }

  @Test
  fun iconTextField_longText_preserved() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "Long rulebook",
          modifier = Modifier.testTag("iconTF-long"))
    }
    val long = "x".repeat(200)
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF-long"))
    tf.performTextInput(long)
    tf.assertTextEquals(long)
  }

  /* ---------------- CountBubble ---------------- */

  @Test
  fun countBubble_displaysProvidedNumber() {
    set { CountBubble(count = 42) }
    composeRule.onNodeWithText("42").assertIsDisplayed()
  }

  @Test
  fun countBubble_handlesNegativeNumbers() {
    set { CountBubble(count = -1) }
    composeRule.onNodeWithText("-1").assertIsDisplayed()
  }

  @Test
  fun countBubble_zeroValue() {
    set { CountBubble(count = 0) }
    composeRule.onNodeWithText("0").assertIsDisplayed()
  }

  /* ---------------- DiscretePillSlider ---------------- */

  @Test
  fun discretePillSlider_drag_invokesOnValuesChange() {
    var changed: Pair<Float, Float>? = null
    set {
      DiscretePillSlider(
          range = 0f..10f,
          values = 2f..6f,
          steps = 9,
          editable = true,
          onValuesChange = { start, end -> changed = start to end },
          surroundModifier = Modifier.testTag("sliderHost"),
          sliderModifier = Modifier.testTag("slider"))
    }
    composeRule.onNodeWithTag("slider").assertExists().assertIsDisplayed()
    composeRule.onNodeWithTag("slider").performTouchInput {
      down(centerLeft)
      moveTo(centerRight)
      up()
    }
    composeRule.waitUntil(timeoutMillis = 5_000) { changed != null }
  }

  @Test
  fun discretePillSlider_withCustomColors_stillEmitsChanges() {
    var changed = false
    set {
      DiscretePillSlider(
          range = 0f..5f,
          values = 1f..1f,
          steps = 4,
          editable = true,
          onValuesChange = { _, _ -> changed = true },
          surroundModifier = Modifier.testTag("sliderHost2"),
          sliderModifier = Modifier.testTag("slider2"),
          sliderColors = SliderDefaults.colors())
    }
    composeRule.onNodeWithTag("slider2").performTouchInput {
      down(center)
      moveBy(Offset(50f, 0f))
      up()
    }
    composeRule.waitUntil(5_000) { changed }
  }

  @Test
  fun discretePillSlider_extremeDrag_clampsAndOrdersValues() {
    var last: Pair<Float, Float>? = null
    set {
      DiscretePillSlider(
          range = -10f..10f,
          values = -5f..5f,
          steps = 20,
          editable = true,
          onValuesChange = { a, b -> last = a to b },
          surroundModifier = Modifier.testTag("sliderHost3"),
          sliderModifier = Modifier.testTag("slider3"))
    }
    composeRule.onNodeWithTag("slider3").performTouchInput {
      down(centerLeft)
      moveTo(centerRight)
      up()
    }
    composeRule.waitUntil(5_000) { last != null }
    val (start, end) = last!!
    assert(start in -10f..10f && end in -10f..10f)
    assert(start <= end)
  }

  /* ---------------- ParticipantChip ---------------- */

  @Test
  fun participantChip_add_click_invokesCallback() {
    var clicked: Account? = null
    set {
      ParticipantChip(
          account = account("Reiner Knizia"),
          action = ParticipantAction.Add,
          onClick = { clicked = it },
          modifier = Modifier.testTag("chip-add"))
    }
    composeRule.onNodeWithText("Reiner Knizia").assertIsDisplayed()
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-add")))
        .onFirst()
        .performClick()
    composeRule.runOnIdle { assert(clicked?.name == "Reiner Knizia") }
  }

  @Test
  fun participantChip_remove_click_invokesCallback() {
    var clicked: Account? = null
    set {
      ParticipantChip(
          account = account("Uwe Rosenberg"),
          action = ParticipantAction.Remove,
          onClick = { clicked = it },
          modifier = Modifier.testTag("chip-remove"))
    }
    composeRule.onNodeWithText("Uwe Rosenberg").assertIsDisplayed()
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-remove")))
        .onFirst()
        .performClick()
    composeRule.runOnIdle { assert(clicked?.name == "Uwe Rosenberg") }
  }

  @Test
  fun participantChip_longName_truncates_noCrash() {
    set {
      ParticipantChip(
          account = account("A very very very very long board-game club name"),
          action = ParticipantAction.Add,
          onClick = {},
          modifier = Modifier.testTag("chip-long"))
    }
    composeRule.onNodeWithTag("chip-long").assertExists().assertIsDisplayed()
  }

  @Test
  fun participantChip_hasExactlyOneClickableChild() {
    set {
      ParticipantChip(
          account = account("Sid Sackson"),
          action = ParticipantAction.Add,
          onClick = {},
          modifier = Modifier.testTag("chip-unique"))
    }
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-unique")))
        .assertCountEquals(1)
  }

  /* ---------------- TwoPerRowGrid ---------------- */

  @Test
  fun twoPerRowGrid_rendersItems() {
    val items = (1..7).map { "Game $it" }
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid"),
          rowsModifier = Modifier) { item, _ ->
            Text(item)
          }
    }
    items.forEach { composeRule.onNodeWithText(it).assertExists() }
  }

  @Test
  fun twoPerRowGrid_oddCount_lastRowSpacers_noCrash_andModifierPropagation() {
    val items = listOf("Catan", "Azul", "Gloomhaven")
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid2"),
          rowsModifier = Modifier) { item, mod ->
            Box(mod.semantics { contentDescription = "cell-$item" }) { Text(item) }
          }
    }

    composeRule.waitForIdle()
    composeRule.onNodeWithTag("grid2").assertExists()

    items.forEach {
      composeRule.onNodeWithContentDescription("cell-$it", useUnmergedTree = true).assertExists()
      composeRule.onNodeWithText(it).assertExists()
    }
  }

  @Test
  fun twoPerRowGrid_evenCount_updatesOnRecomposition() {
    var data by mutableStateOf(listOf("Azul", "Brass"))
    set {
      TwoPerRowGrid(items = data, key = { it }, modifier = Modifier.testTag("grid3")) { item, _ ->
        Text("Cell $item")
      }
    }
    composeRule.onNodeWithText("Cell Azul").assertExists()
    composeRule.onNodeWithText("Cell Brass").assertExists()

    composeRule.runOnUiThread { data = listOf("Azul", "Brass", "Catan", "Dune") }
    composeRule.onNodeWithText("Cell Catan").assertExists()
    composeRule.onNodeWithText("Cell Dune").assertExists()
  }

  @Test
  fun twoPerRowGrid_emptyList_showsNothing() {
    set {
      TwoPerRowGrid(
          items = emptyList<String>(), key = { it }, modifier = Modifier.testTag("grid-empty")) {
              item,
              _ ->
            Text("X $item")
          }
    }
    composeRule.onNodeWithTag("grid-empty").assertExists()
    composeRule.onAllNodesWithText("X ").assertCountEquals(0)
  }

  @Test
  fun twoPerRowGrid_rowsModifier_applied_toEachRow() {
    val items = listOf("azul", "brass", "catan", "dune")
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid-rows-mod"),
          rowsModifier = Modifier.testTag("row-mod")) { item, _ ->
            Text(item)
          }
    }
    val rows =
        composeRule
            .onAllNodes(hasTestTag("row-mod"), useUnmergedTree = true)
            .fetchSemanticsNodes()
            .size
    assert(rows >= 2)
  }

  @Test
  fun twoPerRowGrid_manyItems_composesAllItems() {
    val items = (1..50).map { "Game $it" }
    set {
      TwoPerRowGrid(items = items, key = { it }, modifier = Modifier.testTag("grid-long")) { item, _
        ->
        Text(item)
      }
    }
    // Verify first and last items exist (all items are rendered in a Column)
    composeRule.onNodeWithText("Game 1").assertExists()
    composeRule.onNodeWithText("Game 50").assertExists()
  }

  @Test
  fun twoPerRowGrid_reorder_items_recomposes() {
    var data by mutableStateOf(listOf("Azul", "Brass", "Catan", "Dune", "Everdell"))
    set {
      TwoPerRowGrid(items = data, key = { it }, modifier = Modifier.testTag("grid-reorder")) {
          item,
          _ ->
        Text(item)
      }
    }
    composeRule.onNodeWithText("Azul").assertExists()
    composeRule.runOnUiThread { data = listOf("Everdell", "Dune", "Catan", "Brass", "Azul") }
    listOf("Everdell", "Dune", "Catan", "Brass", "Azul").forEach {
      composeRule.onNodeWithText(it).assertExists()
    }
  }

  /* ---------------- TimePickerField ---------------- */

  @Test
  fun datePickerDialog_nullDateDismissed() {
    var dismissed = false
    composeRule.setContent {
      AppDatePickerDialog(onDismiss = { dismissed = true }, onDateSelected = {})
    }
    composeRule.onNodeWithText("Cancel").performClick()
    composeRule.runOnIdle { assert(dismissed) }
  }

  @Test
  fun dateField_externalCallback() {
    var date = ""
    composeRule.setContent {
      DatePickerDockedField(
          value = LocalDate.now(), onValueChange = { date = it.toString() }, editable = true)
    }
    composeRule.onNodeWithText("Pick").performClick()
    composeRule.waitForIdle()
    composeRule.onNode(isDialog()).performTouchInput { click(center) }
    composeRule.onNodeWithText("OK").performClick()
    composeRule.waitForIdle()

    assert(date.isNotEmpty())
  }

  @Test
  fun timePickerField_externalValueChange_updatesDisplayedText() {
    var time by mutableStateOf<LocalTime?>(null)
    set { TimePickerField(value = time, onValueChange = { time = it }, label = "External") }
    composeRule.onAllNodesWithText("12:15").assertCountEquals(0)

    composeRule.runOnUiThread { time = LocalTime.of(12, 15) }
    composeRule.onNodeWithText("12:15").assertExists()
  }

  @Test
  fun timePickerField_clickingFieldItself_doesNotOpenDialog() {
    set { TimePickerField(value = null, onValueChange = {}, label = "Readonly game time") }
    composeRule.onNodeWithText("Readonly game time").performClick()
    composeRule.onAllNodesWithText("OK").assertCountEquals(0)
  }

  /* ---------------- DatePickerDockedField ---------------- */

  @Test
  fun datePickerDocked_selectNewDate_updatesValue() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    set {
      var state by remember { mutableStateOf<LocalDate?>(initial) }
      DatePickerDockedField(
          value = state,
          onValueChange = { state = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone,
          editable = true)
    }
    val dateNode = composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD)
    dateNode.assertIsDisplayed()

    val initialValue = dateNode.fetchSemanticsNode().config[SemanticsProperties.EditableText].text
    // Open the picker
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()

    // Simulate selecting a new date (this may need to be adapted to your picker UI)
    // For example, click on a date cell in the dialog:
    composeRule.onNode(isDialog()).performTouchInput { click(center) }
    composeRule.waitForIdle()
    composeRule.onNodeWithText("OK").performClick()

    // Assert the new date is displayed
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assertIsDisplayed()
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assert(hasTextDifferentFrom(initialValue))
  }

  @Test
  fun datePickerDocked_externalValueChange_updatesDisplayedText() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val external = LocalDate.of(2024, 12, 24)

    lateinit var holder: MutableState<LocalDate?>
    set {
      holder = remember { mutableStateOf(null) }
      DatePickerDockedField(
          value = holder.value,
          onValueChange = { holder.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone,
          editable = true)
    }

    composeRule.runOnUiThread { holder.value = external }
    composeRule.onNodeWithText(external.format(fmt)).assertIsDisplayed()
  }

  @Test
  fun datePickerDocked_togglePickerWithoutSelection_preservesValue() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2026, 6, 9)

    set {
      var state by remember { mutableStateOf<LocalDate?>(initial) }
      DatePickerDockedField(
          value = state,
          onValueChange = { state = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone,
          editable = true)
    }

    // capture the initial text
    val initialText = initial.format(fmt)
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assertTextEquals(initialText)

    // open → close twice
    repeat(2) {
      composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
      composeRule.waitForIdle()
      composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    }

    // text must still be the same
    composeRule.onNodeWithTag(SessionTestTags.DATE_FIELD).assertTextEquals(initialText)
  }

  @Test
  fun datePickerDocked_externalValueChange_updatesFieldText_again() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    lateinit var holder: MutableState<LocalDate?>

    set {
      holder = remember { mutableStateOf(null) }
      DatePickerDockedField(
          value = holder.value,
          onValueChange = { holder.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone,
          editable = true)
    }

    val first = LocalDate.of(2024, 12, 24)
    val second = LocalDate.of(2025, 1, 1)

    composeRule.runOnUiThread { holder.value = first }
    composeRule.onNodeWithText(first.format(fmt)).assertIsDisplayed()

    composeRule.runOnUiThread { holder.value = second }
    composeRule.onNodeWithText(second.format(fmt)).assertIsDisplayed()
  }

  /* ---------------- SearchDropdownField / GameSearchField / LocationSearchField ---------------- */

  @Test
  fun searchDropdown_showsLoadingState_whenIsLoadingTrue_afterTyping() {
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = true,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    waitForText("Searching…")
    composeRule.onNodeWithText("Searching…").assertExists()
  }

  @Test
  fun searchDropdown_showsEmptyText_whenNoResultsAndNotLoading() {
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = false,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("xyz")

    waitForText("No results")
    composeRule.onNodeWithText("No results").assertExists()
  }

  @Test
  fun searchDropdown_clickingSuggestion_callsCallback_andClosesPopup() {
    var picked: String? = null
    val suggestions = listOf("Catan", "Carcassonne", "Camel Up")
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = suggestions,
          onSuggestionClick = { picked = it },
          getPrimaryText = { it },
          isLoading = false,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    waitForText("Catan")
    composeRule.onNodeWithText("Catan").assertExists().performClick()

    composeRule.runOnIdle { assert(picked == "Catan") }

    waitForGone("Catan")
    composeRule.onAllNodesWithText("Catan").assertCountEquals(0)
  }

  @Test
  fun searchDropdown_trailingClearButton_clearsQuery_andHidesPopup() {
    val suggestions = listOf("Catan")
    set {
      var q by remember { mutableStateOf("C") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = suggestions,
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = false,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("a")

    composeRule.waitUntil(5_000) {
      composeRule
          .onAllNodesWithContentDescription("Clear", useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }
    composeRule
        .onNodeWithContentDescription("Clear", useUnmergedTree = true)
        .assertExists()
        .performClick()

    waitForGone("Catan")
    composeRule.onAllNodesWithText("Catan").assertCountEquals(0)
  }

  @Test
  fun gameSearchField_typingShowsGameSuggestions_andOnPickReturnsGame() {
    var q by mutableStateOf("")
    var picked: com.github.meeplemeet.model.structures.Game? = null

    val g1 =
        com.github.meeplemeet.model.structures.Game(
            uid = "g1",
            name = "Catan",
            description = "Trade, build, settle.",
            imageURL = "",
            minPlayers = 3,
            maxPlayers = 4,
            recommendedPlayers = 4,
            averagePlayTime = 60,
            genres = emptyList())
    val g2 =
        com.github.meeplemeet.model.structures.Game(
            uid = "g2",
            name = "Carcassonne",
            description = "Tile-laying.",
            imageURL = "",
            minPlayers = 2,
            maxPlayers = 5,
            recommendedPlayers = 4,
            averagePlayTime = 45,
            genres = emptyList())

    set {
      GameSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(g1, g2),
          onPick = { picked = it },
          isLoading = false,
          modifier = Modifier)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    waitForText("Catan")
    composeRule.onNodeWithText("Catan").assertExists()

    waitForText("Carcassonne")
    composeRule.onNodeWithText("Carcassonne").assertExists()

    composeRule.onNodeWithText("Catan").performClick()
    composeRule.runOnIdle { assert(picked?.uid == "g1" && picked?.name == "Catan") }
  }

  @Test
  fun locationSearchField_rendersCustomItemContent_withCoordinates_andOnPick() {
    var q by mutableStateOf("")
    var picked: com.github.meeplemeet.model.structures.Location? = null

    val loc =
        com.github.meeplemeet.model.structures.Location(
            name = "EPFL Esplanade", latitude = 46.5191, longitude = 6.5668)

    set {
      LocationSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(loc),
          onPick = { picked = it },
          isLoading = false,
          modifier = Modifier)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("epfl")

    waitForText("EPFL Esplanade")
    composeRule.onNodeWithText("EPFL Esplanade").assertExists()

    val coordsDot = "46.51910, 6.56680"
    val coordsComma = "46,51910, 6,56680"
    composeRule.waitUntil(5_000) {
      val nodesDot = composeRule.onAllNodesWithText(coordsDot).fetchSemanticsNodes().isNotEmpty()
      val nodesComma =
          composeRule.onAllNodesWithText(coordsComma).fetchSemanticsNodes().isNotEmpty()
      nodesDot || nodesComma
    }
    if (composeRule.onAllNodesWithText(coordsDot).fetchSemanticsNodes().isNotEmpty()) {
      composeRule.onNodeWithText(coordsDot).assertExists()
    } else {
      composeRule.onNodeWithText(coordsComma).assertExists()
    }

    composeRule.onNodeWithText("EPFL Esplanade").performClick()
    composeRule.runOnIdle {
      assert(picked?.name == "EPFL Esplanade")
      assert(picked?.latitude == 46.5191 && picked?.longitude == 6.5668)
    }
  }

  @Test
  fun gameSearchField_doesNotShowDescriptions_onlyNames() {
    val g =
        com.github.meeplemeet.model.structures.Game(
            uid = "g",
            name = "Everdell",
            description = "Woodland engine building",
            imageURL = "",
            minPlayers = 1,
            maxPlayers = 4,
            recommendedPlayers = 3,
            averagePlayTime = 90,
            genres = emptyList())
    set {
      var q by remember { mutableStateOf("") }
      GameSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(g),
          onPick = {},
          isLoading = false)
    }
    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ever")

    waitForText("Everdell")
    composeRule.onNodeWithText("Everdell").assertExists()
    composeRule.onAllNodesWithText("Woodland engine building").assertCountEquals(0)
  }

  @Test
  fun locationSearchField_noResults_showsDefaultEmptyText() {
    set {
      var q by remember { mutableStateOf("") }
      LocationSearchField(
          query = q,
          onQueryChange = { q = it },
          results = emptyList(),
          onPick = {},
          isLoading = false)
    }
    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("somewhere")

    waitForText("No results")
    composeRule.onNodeWithText("No results").assertExists()
  }

  @Test
  fun locationSearchField_multipleLocations_showAll_andPickSecond() {
    val l1 =
        com.github.meeplemeet.model.structures.Location(
            name = "Local Game Store", latitude = 46.0, longitude = 6.0)
    val l2 =
        com.github.meeplemeet.model.structures.Location(
            name = "Community Center", latitude = 46.12345, longitude = 6.98765)

    var picked: com.github.meeplemeet.model.structures.Location? = null
    set {
      var q by remember { mutableStateOf("") }
      LocationSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(l1, l2),
          onPick = { picked = it },
          isLoading = false)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("c")

    waitForText("Local Game Store")
    composeRule.onNodeWithText("Local Game Store").assertExists()

    waitForText("Community Center")
    composeRule.onNodeWithText("Community Center").assertExists()

    composeRule.onNodeWithText("Community Center").performClick()
    composeRule.runOnIdle {
      assert(picked?.name == "Community Center")
      assert(picked?.latitude == 46.12345 && picked?.longitude == 6.98765)
    }
  }

  @Test
  fun locationSearchField_coordinatesFormatting_isFixedToFiveDecimals_evenForShorterInputs() {
    val l =
        com.github.meeplemeet.model.structures.Location(
            name = "Place", latitude = 46.5, longitude = 6.2)
    set {
      var q by remember { mutableStateOf("") }
      LocationSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(l),
          onPick = {},
          isLoading = false)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("pl")

    val dot = "46.50000, 6.20000"
    val comma = "46,50000, 6,20000"
    composeRule.waitUntil(5_000) {
      val hasDot = composeRule.onAllNodesWithText(dot).fetchSemanticsNodes().isNotEmpty()
      val hasComma = composeRule.onAllNodesWithText(comma).fetchSemanticsNodes().isNotEmpty()
      hasDot || hasComma
    }
    if (composeRule.onAllNodesWithText(dot).fetchSemanticsNodes().isNotEmpty()) {
      composeRule.onNodeWithText(dot).assertExists()
    } else {
      composeRule.onNodeWithText(comma).assertExists()
    }
  }

  @Test
  fun searchDropdown_typing_then_setLoadingTrue_switchesToSpinner_withoutClosing() {
    set {
      var q by remember { mutableStateOf("") }
      var loading by remember { mutableStateOf(false) }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = {
            q = it
            loading = true
          },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = loading)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("du")

    waitForText("Searching…")
    composeRule.onNodeWithText("Searching…").assertExists()
  }

  @Test
  fun searchDropdown_showWhenEmptyQuery_true_showsSuggestions_evenWhenQueryEmpty_afterReplacement() {
    val data = listOf("Azul", "Brass", "Catan")
    set {
      var q by remember { mutableStateOf("x") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = data,
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = false,
          showWhenEmptyQuery = true,
          placeholder = "Type…")
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextReplacement("")

    waitForText("Azul")
    composeRule.onNodeWithText("Azul").assertExists()
    composeRule.onNodeWithText("Brass").assertExists()
    composeRule.onNodeWithText("Catan").assertExists()
  }

  @Test
  fun searchDropdown_spinnerOnly_whenLoading_andNoResults() {
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = true)
    }
    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("abc")

    waitForText("Searching…")
    composeRule.onNodeWithText("Searching…").assertExists()
    composeRule.onAllNodesWithText("No results").assertCountEquals(0)
  }

  @Test
  fun searchDropdown_placeholder_and_label_render_andPlaceholderDisappearsOnInput() {
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Label",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          placeholder = "Type here…")
    }

    composeRule.onNodeWithText("Label").assertExists()

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    waitForText("Type here…", unmerged = true)
    composeRule.onNodeWithText("Type here…", useUnmergedTree = true).assertExists()

    tf.performTextInput("x")
    waitForGone("Type here…")
    composeRule.onAllNodesWithText("Type here…").assertCountEquals(0)
  }

  @Test
  fun gameSearchField_clickingOutsideClearsSuggestions_whenQueryEmptiedAfterwards() {
    val g =
        com.github.meeplemeet.model.structures.Game(
            uid = "g1",
            name = "Azul",
            description = "",
            imageURL = "",
            minPlayers = 2,
            maxPlayers = 4,
            recommendedPlayers = 4,
            averagePlayTime = 30,
            genres = emptyList())

    set {
      var q by remember { mutableStateOf("") }
      GameSearchField(
          query = q,
          onQueryChange = { q = it },
          results = listOf(g),
          onPick = {},
          isLoading = false)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("a")

    waitForText("Azul")
    composeRule.onNodeWithText("Azul").assertExists()

    tf.performTextReplacement("")
    waitForGone("Azul")
    composeRule.onAllNodesWithText("Azul").assertCountEquals(0)
  }

  @Test
  fun searchDropdown_showWhenEmptyQuery_false_hidesSuggestions_whenQueryBecomesEmpty() {
    val data = listOf("Azul", "Brass", "Catan")

    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Search",
          query = q,
          onQueryChange = { q = it },
          suggestions = data,
          onSuggestionClick = {},
          getPrimaryText = { it },
          isLoading = false,
          showWhenEmptyQuery = false)
    }

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    tf.performTextInput("ca")

    waitForText("Catan")
    composeRule.onNodeWithText("Catan").assertExists()

    tf.performTextReplacement("")
    waitForGone("Catan")
    composeRule.onAllNodesWithText("Catan").assertCountEquals(0)
  }

  @Test
  fun searchDropdown_placeholder_and_label_render_and_textEditable() {
    set {
      var q by remember { mutableStateOf("") }
      SearchDropdownField(
          label = "Game",
          query = q,
          onQueryChange = { q = it },
          suggestions = emptyList<String>(),
          onSuggestionClick = {},
          getPrimaryText = { it },
          placeholder = "Search games…")
    }

    composeRule.onNodeWithText("Game").assertExists()

    val tf = composeRule.onNode(hasSetTextAction())
    tf.performClick()
    waitForText("Search games…", unmerged = true)
    composeRule.onNodeWithText("Search games…", useUnmergedTree = true).assertExists()

    tf.performTextInput("Brass")
    composeRule.waitForIdle()

    tf.assert(hasText("Brass", substring = false, ignoreCase = false))
  }
}
