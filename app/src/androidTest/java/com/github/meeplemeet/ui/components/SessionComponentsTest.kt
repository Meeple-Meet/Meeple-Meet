// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
package com.github.meeplemeet.ui.components

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.ui.theme.AppTheme
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

/** Instrumentation tests for SessionComponents.kt */
@RunWith(AndroidJUnit4::class)
class SessionComponentsTest {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  private fun set(content: @Composable () -> Unit) {
    composeRule.setContent { AppTheme { content() } }
  }

  private fun account(name: String = "Marco") =
      Account(uid = "1", name = name, email = "marco@epfl.ch", handle = "")

  /* ---------------- SectionCard ---------------- */

  @Test
  fun sectionCard_rendersChildContent_andAcceptsModifier() {
    set {
      SectionCard(modifier = Modifier.testTag("sectionCard")) {
        Text("Meeple inside card", Modifier.testTag("section-content"))
      }
    }
    composeRule.onNodeWithTag("sectionCard").assertExists().assertIsDisplayed()
    composeRule
        .onNodeWithTag("section-content")
        .assertIsDisplayed()
        .assertTextEquals("Meeple inside card")
  }

  @Test
  fun sectionCard_customPadding_stillDisplaysChildren() {
    set {
      SectionCard(
          modifier = Modifier.testTag("sectionCard2"), contentPadding = PaddingValues(24.dp)) {
            UnderlinedLabel("Padded setup")
          }
    }
    composeRule.onNodeWithText("Padded setup").assertIsDisplayed()
  }

  /* ---------------- UnderlinedLabel ---------------- */

  @Test
  fun underlinedLabel_showsGivenText() {
    set { UnderlinedLabel(text = "Underlined board game") }
    composeRule.onNodeWithText("Underlined board game").assertIsDisplayed()
  }

  @Test
  fun underlinedLabel_customStyleParams_stillRenders() {
    set { UnderlinedLabel(text = "Styled expansion") }
    composeRule.onNodeWithText("Styled expansion").assertIsDisplayed()
  }

  /* ---------------- LabeledTextField ---------------- */

  @Test
  fun labeledTextField_labelVisible_placeholderShows_typingUpdatesValue() {
    set {
      var value by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game title",
          value = value,
          onValueChange = { value = it },
          placeholder = "Type game…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF"))
    }

    composeRule.onNodeWithText("Game title").assertIsDisplayed()
    composeRule.onNodeWithText("Type game…").assertIsDisplayed()

    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF"))
    tf.performClick()
    tf.performTextInput("Terraforming Mars")
    tf.assertTextEquals("Terraforming Mars")
    composeRule.onNodeWithText("Type game…").assertDoesNotExist()
  }

  @Test
  fun labeledTextField_multiline_mode_acceptsLongText() {
    set {
      var txt by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game description",
          value = txt,
          onValueChange = { txt = it },
          placeholder = "Multi…",
          singleLine = false,
          modifier = Modifier.testTag("labeledTF-multi"))
    }
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF-multi"))
    tf.performTextInput("Setup:\nDraft cards\nEngine build")
    tf.assertTextContains("Engine build", substring = true)
  }

  @Test
  fun labeledTextField_hasImeActionDone_performImeAction_noCrash() {
    set {
      var txt by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Submit",
          value = txt,
          onValueChange = { txt = it },
          placeholder = "rulebook…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF-ime"))
    }
    val tf = composeRule.onNode(hasTestTag("labeledTF-ime") and hasImeAction(ImeAction.Done))
    tf.performTextInput("Catan")
    tf.performImeAction()
    tf.assertTextEquals("Catan")
  }

  @Test
  fun labeledTextField_clearText_showsPlaceholderAgain() {
    set {
      var value by remember { mutableStateOf("") }
      LabeledTextField(
          label = "Game title",
          value = value,
          onValueChange = { value = it },
          placeholder = "Type game…",
          singleLine = true,
          modifier = Modifier.testTag("labeledTF-clear"))
    }
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("labeledTF-clear"))
    tf.performTextInput("Azul")
    tf.assertTextEquals("Azul")
    tf.performTextReplacement("")
    composeRule.onNodeWithText("Type game…").assertIsDisplayed()
  }

  /* ---------------- IconTextField ---------------- */

  @Test
  fun iconTextField_leadingAndTrailingIcons_visible_andTextEditable() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "With meeples",
          leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading") },
          trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing") },
          modifier = Modifier.testTag("iconTF"))
    }
    composeRule.onNodeWithContentDescription("leading").assertIsDisplayed()
    composeRule.onNodeWithContentDescription("trailing").assertIsDisplayed()

    val iconTf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF"))
    iconTf.performTextInput("Carcassonne")
    iconTf.assertTextEquals("Carcassonne")
  }

  @Test
  fun iconTextField_withoutIcons_stillEditable_andShowsPlaceholder() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "No meeples",
          modifier = Modifier.testTag("iconTF-no-icons"))
    }
    composeRule.onNodeWithText("No meeples").assertIsDisplayed()

    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF-no-icons"))
    tf.performTextInput("Wingspan")
    tf.assertTextEquals("Wingspan")

    tf.performTextReplacement("")
    composeRule.onNodeWithTag("iconTF-no-icons").assertTextContains("No meeples", substring = true)
  }

  @Test
  fun iconTextField_longText_preserved() {
    set {
      var value by remember { mutableStateOf("") }
      IconTextField(
          value = value,
          onValueChange = { value = it },
          placeholder = "Long rulebook",
          modifier = Modifier.testTag("iconTF-long"))
    }
    val long = "x".repeat(200)
    val tf = composeRule.onNode(hasSetTextAction() and hasTestTag("iconTF-long"))
    tf.performTextInput(long)
    tf.assertTextEquals(long)
  }

  /* ---------------- CountBubble ---------------- */

  @Test
  fun countBubble_displaysProvidedNumber() {
    set { CountBubble(count = 42) }
    composeRule.onNodeWithText("42").assertIsDisplayed()
  }

  @Test
  fun countBubble_handlesNegativeNumbers() {
    set { CountBubble(count = -1) }
    composeRule.onNodeWithText("-1").assertIsDisplayed()
  }

  @Test
  fun countBubble_zeroValue() {
    set { CountBubble(count = 0) }
    composeRule.onNodeWithText("0").assertIsDisplayed()
  }

  /* ---------------- DiscretePillSlider ---------------- */

  @Test
  fun discretePillSlider_drag_invokesOnValuesChange() {
    var changed: Pair<Float, Float>? = null
    set {
      DiscretePillSlider(
          range = 0f..10f,
          values = 2f..6f,
          steps = 9,
          onValuesChange = { start, end -> changed = start to end },
          surroundModifier = Modifier.testTag("sliderHost"),
          sliderModifier = Modifier.testTag("slider"))
    }
    composeRule.onNodeWithTag("slider").assertExists().assertIsDisplayed()
    composeRule.onNodeWithTag("slider").performTouchInput {
      down(centerLeft)
      moveTo(centerRight)
      up()
    }
    composeRule.waitUntil(timeoutMillis = 2_000) { changed != null }
  }

  @Test
  fun discretePillSlider_withCustomColors_stillEmitsChanges() {
    var changed = false
    set {
      DiscretePillSlider(
          range = 0f..5f,
          values = 1f..1f,
          steps = 4,
          onValuesChange = { _, _ -> changed = true },
          surroundModifier = Modifier.testTag("sliderHost2"),
          sliderModifier = Modifier.testTag("slider2"),
          sliderColors = SliderDefaults.colors())
    }
    composeRule.onNodeWithTag("slider2").performTouchInput {
      down(center)
      moveBy(Offset(50f, 0f))
      up()
    }
    composeRule.waitUntil(1_500) { changed }
  }

  @Test
  fun discretePillSlider_extremeDrag_clampsAndOrdersValues() {
    var last: Pair<Float, Float>? = null
    set {
      DiscretePillSlider(
          range = -10f..10f,
          values = -5f..5f,
          steps = 20,
          onValuesChange = { a, b -> last = a to b },
          surroundModifier = Modifier.testTag("sliderHost3"),
          sliderModifier = Modifier.testTag("slider3"))
    }
    composeRule.onNodeWithTag("slider3").performTouchInput {
      down(centerLeft)
      moveTo(centerRight)
      up()
    }
    composeRule.waitUntil(2_000) { last != null }
    val (start, end) = last!!
    assert(start in -10f..10f && end in -10f..10f)
    assert(start <= end)
  }

  /* ---------------- ParticipantChip ---------------- */

  @Test
  fun participantChip_add_click_invokesCallback() {
    var clicked: Account? = null
    set {
      ParticipantChip(
          account = account("Reiner Knizia"),
          action = ParticipantAction.Add,
          onClick = { clicked = it },
          modifier = Modifier.testTag("chip-add"))
    }
    composeRule.onNodeWithText("Reiner Knizia").assertIsDisplayed()
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-add")))
        .onFirst()
        .performClick()
    composeRule.runOnIdle { assert(clicked?.name == "Reiner Knizia") }
  }

  @Test
  fun participantChip_remove_click_invokesCallback() {
    var clicked: Account? = null
    set {
      ParticipantChip(
          account = account("Uwe Rosenberg"),
          action = ParticipantAction.Remove,
          onClick = { clicked = it },
          modifier = Modifier.testTag("chip-remove"))
    }
    composeRule.onNodeWithText("Uwe Rosenberg").assertIsDisplayed()
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-remove")))
        .onFirst()
        .performClick()
    composeRule.runOnIdle { assert(clicked?.name == "Uwe Rosenberg") }
  }

  @Test
  fun participantChip_longName_truncates_noCrash() {
    set {
      ParticipantChip(
          account = account("A very very very very long board-game club name"),
          action = ParticipantAction.Add,
          onClick = {},
          modifier = Modifier.testTag("chip-long"))
    }
    composeRule.onNodeWithTag("chip-long").assertExists().assertIsDisplayed()
  }

  @Test
  fun participantChip_hasExactlyOneClickableChild() {
    set {
      ParticipantChip(
          account = account("Sid Sackson"),
          action = ParticipantAction.Add,
          onClick = {},
          modifier = Modifier.testTag("chip-unique"))
    }
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-unique")))
        .assertCountEquals(1)
  }

  /* ---------------- TwoPerRowGrid ---------------- */

  @Test
  fun twoPerRowGrid_rendersItems_andIsScrollable() {
    val items = (1..7).map { "Game $it" }
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid"),
          rowsModifier = Modifier) { item, _ ->
            Text(item)
          }
    }
    items.forEach { composeRule.onNodeWithText(it).assertExists() }
    composeRule.onNodeWithTag("grid").performTouchInput { swipeUp() }
    composeRule.onNodeWithTag("grid").performTouchInput { swipeDown() }
  }

  @Test
  fun twoPerRowGrid_oddCount_lastRowSpacers_noCrash_andModifierPropagation() {
    val items = listOf("Catan", "Azul", "Gloomhaven")
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid2"),
          rowsModifier = Modifier) { item, mod ->
            Box(mod.semantics { contentDescription = "cell-$item" }) { Text(item) }
          }
    }

    composeRule.waitForIdle()
    composeRule.onNodeWithTag("grid2").assertExists()

    items.forEach {
      composeRule.onNodeWithContentDescription("cell-$it", useUnmergedTree = true).assertExists()
      composeRule.onNodeWithText(it).assertExists()
    }

    composeRule.onNodeWithTag("grid2").performTouchInput { swipeUp() }
    composeRule.onNodeWithTag("grid2").performTouchInput { swipeDown() }
  }

  @Test
  fun twoPerRowGrid_evenCount_updatesOnRecomposition() {
    var data by mutableStateOf(listOf("Azul", "Brass"))
    set {
      TwoPerRowGrid(items = data, key = { it }, modifier = Modifier.testTag("grid3")) { item, _ ->
        Text("Cell $item")
      }
    }
    composeRule.onNodeWithText("Cell Azul").assertExists()
    composeRule.onNodeWithText("Cell Brass").assertExists()

    composeRule.runOnUiThread { data = listOf("Azul", "Brass", "Catan", "Dune") }
    composeRule.onNodeWithText("Cell Catan").assertExists()
    composeRule.onNodeWithText("Cell Dune").assertExists()
  }

  @Test
  fun twoPerRowGrid_emptyList_showsNothing() {
    set {
      TwoPerRowGrid(
          items = emptyList<String>(), key = { it }, modifier = Modifier.testTag("grid-empty")) {
              item,
              _ ->
            Text("X $item")
          }
    }
    composeRule.onNodeWithTag("grid-empty").assertExists()
    composeRule.onAllNodesWithText("X ").assertCountEquals(0)
  }

  @Test
  fun twoPerRowGrid_rowsModifier_applied_toEachRow() {
    val items = listOf("azul", "brass", "catan", "dune")
    set {
      TwoPerRowGrid(
          items = items,
          key = { it },
          modifier = Modifier.testTag("grid-rows-mod"),
          rowsModifier = Modifier.testTag("row-mod")) { item, _ ->
            Text(item)
          }
    }
    val rows =
        composeRule
            .onAllNodes(hasTestTag("row-mod"), useUnmergedTree = true)
            .fetchSemanticsNodes()
            .size
    assert(rows >= 2)
  }

  @Test
  fun twoPerRowGrid_manyItems_scrollsToBottom_composesLastItem() {
    val items = (1..50).map { "Game $it" }
    set {
      TwoPerRowGrid(items = items, key = { it }, modifier = Modifier.testTag("grid-long")) { item, _
        ->
        Text(item)
      }
    }
    repeat(6) { composeRule.onNodeWithTag("grid-long").performTouchInput { swipeUp() } }
    composeRule.onNodeWithText("Game 50").assertExists()
  }

  @Test
  fun twoPerRowGrid_reorder_items_recomposes() {
    var data by mutableStateOf(listOf("Azul", "Brass", "Catan", "Dune", "Everdell"))
    set {
      TwoPerRowGrid(items = data, key = { it }, modifier = Modifier.testTag("grid-reorder")) {
          item,
          _ ->
        Text(item)
      }
    }
    composeRule.onNodeWithText("Azul").assertExists()
    composeRule.runOnUiThread { data = listOf("Everdell", "Dune", "Catan", "Brass", "Azul") }
    listOf("Everdell", "Dune", "Catan", "Brass", "Azul").forEach {
      composeRule.onNodeWithText(it).assertExists()
    }
  }

  /* ---------------- TimePickerField ---------------- */

  @Test
  fun timePickerField_openDialog_confirm_setsDefault1900() {
    var time: LocalTime? = null
    set { TimePickerField(value = time, onValueChange = { time = it }, label = "Game time") }
    composeRule.onNodeWithContentDescription("Select time").assertIsDisplayed().performClick()
    composeRule.onNodeWithText("Game time").assertExists()
    composeRule.onNodeWithText("OK").assertIsDisplayed().performClick()
    composeRule.runOnIdle { assert(time == LocalTime.of(19, 0)) }
  }

  @Test
  fun timePickerField_cancel_doesNotChangeValue() {
    var time: LocalTime? = null
    set { TimePickerField(value = time, onValueChange = { time = it }, label = "Game time") }
    composeRule.onNodeWithContentDescription("Select time").performClick()
    composeRule.onNodeWithText("Cancel").performClick()
    composeRule.runOnIdle { assert(time == null) }
  }

  @Test
  fun timePickerField_withInitialValue_showsFormattedText_andConfirmKeepsValue() {
    val initial = LocalTime.of(8, 30)
    var time: LocalTime? = initial
    set {
      TimePickerField(
          value = time,
          onValueChange = { time = it },
          label = "Pick time",
          is24Hour = false,
          displayFormatter = DateTimeFormatter.ofPattern("HH:mm"))
    }
    composeRule.onNodeWithText("08:30").assertIsDisplayed()

    composeRule.onNodeWithText("08:30").performClick()
    composeRule.onAllNodesWithText("OK").assertCountEquals(0)

    composeRule.onNodeWithContentDescription("Select time").performClick()
    composeRule.onNodeWithText("OK").performClick()
    composeRule.runOnIdle { assert(time == initial) }
  }

  @Test
  fun timePickerField_backDismiss_doesNotChangeValue() {
    var time: LocalTime? = null
    set { TimePickerField(value = time, onValueChange = { time = it }, label = "BackDismiss") }

    composeRule.onNodeWithContentDescription("Select time").performClick()
    composeRule.onNodeWithText("OK").assertIsDisplayed()

    composeRule.activityRule.scenario.onActivity { it.onBackPressedDispatcher.onBackPressed() }

    composeRule.runOnIdle { assert(time == null) }
    composeRule.onAllNodesWithText("OK").assertCountEquals(0)
  }

  @Test
  fun timePickerField_externalValueChange_updatesDisplayedText() {
    var time by mutableStateOf<LocalTime?>(null)
    set { TimePickerField(value = time, onValueChange = { time = it }, label = "External") }
    composeRule.onAllNodesWithText("12:15").assertCountEquals(0)

    composeRule.runOnUiThread { time = LocalTime.of(12, 15) }
    composeRule.onNodeWithText("12:15").assertExists()
  }

  @Test
  fun timePickerField_clickingFieldItself_doesNotOpenDialog() {
    set { TimePickerField(value = null, onValueChange = {}, label = "Readonly game time") }
    composeRule.onNodeWithText("Readonly game time").performClick()
    composeRule.onAllNodesWithText("OK").assertCountEquals(0)
  }

  /* ---------------- DatePickerDockedField ---------------- */

  @Test
  fun datePickerDocked_withInitialValue_showsFormattedText_andToggleDoesNotCrash() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    set {
      var value by remember { mutableStateOf<LocalDate?>(initial) }
      DatePickerDockedField(
          value = value,
          onValueChange = { value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    composeRule.onNodeWithText(initial.format(fmt)).assertIsDisplayed()

    val icon = composeRule.onNodeWithContentDescription("Select date")
    icon.performClick()
    icon.performClick()
  }

  @Test
  fun datePickerDocked_externalValueChange_updatesDisplayedText() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val external = LocalDate.of(2024, 12, 24)

    lateinit var holder: MutableState<LocalDate?>
    set {
      holder = remember { mutableStateOf<LocalDate?>(null) }
      DatePickerDockedField(
          value = holder.value,
          onValueChange = { holder.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    composeRule.runOnUiThread { holder.value = external }
    composeRule.onNodeWithText(external.format(fmt)).assertIsDisplayed()
  }

  @Test
  fun datePickerDocked_openAndCloseWithoutSelecting_doesNotChangeValue() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")

    lateinit var picked: MutableState<LocalDate?>
    set {
      picked = remember { mutableStateOf<LocalDate?>(null) }
      DatePickerDockedField(
          value = picked.value,
          onValueChange = { picked.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    val icon = composeRule.onNodeWithContentDescription("Select date")
    icon.performClick()
    icon.performClick()

    composeRule.runOnIdle { assert(picked.value == null) }
  }

  @Test
  fun datePickerDocked_withInitialValue_showsFormattedText_andToggleOpenClose() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    lateinit var picked: MutableState<LocalDate?>
    set {
      picked = remember { mutableStateOf<LocalDate?>(initial) }
      DatePickerDockedField(
          value = picked.value,
          onValueChange = { picked.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    composeRule.onNodeWithText(initial.format(fmt)).assertIsDisplayed()

    val icon = composeRule.onNodeWithContentDescription("Select date")
    icon.performClick()
    icon.performClick()
    composeRule.onNodeWithText(initial.format(fmt)).assertIsDisplayed()
    composeRule.runOnIdle { assert(picked.value == initial) }
  }

  @Test
  fun datePickerDocked_labelVisible_and_multipleToggles_noSelection_noChange() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    lateinit var picked: MutableState<LocalDate?>

    set {
      picked = remember { mutableStateOf<LocalDate?>(null) }
      DatePickerDockedField(
          value = picked.value,
          onValueChange = { picked.value = it },
          label = "Game night",
          displayFormatter = fmt,
          zoneId = zone)
    }

    composeRule.onNodeWithText("Game night").assertIsDisplayed()

    val icon = composeRule.onNodeWithContentDescription("Select date")
    icon.performClick()
    icon.performClick()
    icon.performClick()
    icon.performClick()
    composeRule.runOnIdle { assert(picked.value == null) }
  }

  @Test
  fun datePickerDocked_initialValue_persistsAcrossToggles() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2026, 6, 9)
    lateinit var picked: MutableState<LocalDate?>

    set {
      picked = remember { mutableStateOf<LocalDate?>(initial) }
      DatePickerDockedField(
          value = picked.value,
          onValueChange = { picked.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    composeRule.onNodeWithText(initial.format(fmt)).assertIsDisplayed()
    val icon = composeRule.onNodeWithContentDescription("Select date")
    icon.performClick()
    icon.performClick()
    composeRule.onNodeWithText(initial.format(fmt)).assertIsDisplayed()
    composeRule.runOnIdle { assert(picked.value == initial) }
  }

  @Test
  fun datePickerDocked_externalValueChange_updatesFieldText_again() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    lateinit var holder: MutableState<LocalDate?>

    set {
      holder = remember { mutableStateOf<LocalDate?>(null) }
      DatePickerDockedField(
          value = holder.value,
          onValueChange = { holder.value = it },
          label = "Game date",
          displayFormatter = fmt,
          zoneId = zone)
    }

    val first = LocalDate.of(2024, 12, 24)
    val second = LocalDate.of(2025, 1, 1)

    composeRule.runOnUiThread { holder.value = first }
    composeRule.onNodeWithText(first.format(fmt)).assertIsDisplayed()

    composeRule.runOnUiThread { holder.value = second }
    composeRule.onNodeWithText(second.format(fmt)).assertIsDisplayed()
  }
}
