// This file was generated by ChatGPT Thinking Extend and then adjusted by hand
// Several ones of them were first given as idea to LLM (telling what to test, which combination)
// It was then optimized using LLM and manual iterations to cover more paths in less tests
package com.github.meeplemeet.ui.components

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CalendarToday
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SliderDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.testTag
import androidx.compose.ui.semantics.SemanticsProperties
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.unit.dp
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.github.meeplemeet.model.auth.Account
import com.github.meeplemeet.model.sessions.CreateSessionViewModel
import com.github.meeplemeet.model.shared.game.Game
import com.github.meeplemeet.model.shared.location.Location
import com.github.meeplemeet.ui.sessions.SessionTestTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.utils.FirestoreTests
import java.time.LocalDate
import java.time.LocalTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Locale
import org.junit.*
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class SessionComponentsTest : FirestoreTests() {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  private var oldLocale: Locale? = null

  private lateinit var createSessionViewModel: CreateSessionViewModel

  @Before
  fun forceStableLocale() {
    oldLocale = Locale.getDefault()
    Locale.setDefault(Locale.US)

    // Initialize real repositories and view model
    createSessionViewModel = CreateSessionViewModel(sessionRepository, gameRepository)
  }

  @After
  fun restoreLocale() {
    oldLocale?.let { Locale.setDefault(it) }
  }

  private fun set(content: @Composable () -> Unit) {
    composeRule.setContent { AppTheme { content() } }
  }

  private fun hasTextDifferentFrom(oldText: String) =
      SemanticsMatcher("Text != '$oldText'") { node ->
        node.config[SemanticsProperties.EditableText].text != oldText
      }

  /* ====================== SECTION / LABELS / TEXTFIELDS ====================== */

  @Test
  fun labeledTextField_independence_placeholder_roundtrip_and_multi_callbacks() {
    var a by mutableStateOf("")
    var b by mutableStateOf("")
    var calls = 0
    var last = ""

    set {
      Column {
        LabeledTextField(
            label = "Marco",
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              last = s
            },
            placeholder = "Root",
            singleLine = true,
            modifier = Modifier.testTag("ltf-A"))
        LabeledTextField(
            label = "Alex",
            value = b,
            onValueChange = { b = it },
            placeholder = "Spirit Island",
            singleLine = true,
            modifier = Modifier.testTag("ltf-B"))
      }
    }

    // Both placeholders visible initially
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText("Spirit Island", useUnmergedTree = true).assertExists()

    val tfA = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-A"))
    val tfB = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-B"))
    tfA.performTextInput("Arcs")
    tfB.performTextInput("Ahoy")
    tfA.assertTextEquals("Arcs")
    tfB.assertTextEquals("Ahoy")

    tfA.performTextReplacement("")
    composeRule.onNodeWithText("Root", useUnmergedTree = true).assertExists()
    composeRule.onAllNodesWithText("Spirit Island", useUnmergedTree = true).assertCountEquals(0)

    composeRule.runOnIdle { assert(calls >= 2) }
    composeRule.runOnIdle { assert(last == "Arcs" || last.isEmpty()) }
  }

  @Test
  fun section_and_all_labeled_textfield_paths_in_one() {
    var styledValue by mutableStateOf("")
    var dynamicLabel by mutableStateOf("Game Label")

    set {
      Column {
        // Section
        SectionCard(modifier = Modifier.testTag("section-default")) {
          Text("InsideDefault", Modifier.testTag("inside-default"))
        }
        SectionCard(
            modifier = Modifier.testTag("section-custom"), contentPadding = PaddingValues(24.dp)) {
              UnderlinedLabel("CustomPad")
            }

        // 1) Single-line
        var v1 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "Game title",
            value = v1,
            onValueChange = { v1 = it },
            placeholder = "Type…",
            singleLine = true,
            modifier = Modifier.testTag("ltf-single"))

        // 2) Multiline
        var v2 by remember { mutableStateOf("") }
        LabeledTextField(
            label = "House rules / notes",
            value = v2,
            onValueChange = { v2 = it },
            placeholder = "Multi…",
            singleLine = false,
            modifier = Modifier.testTag("ltf-multi"))

        // 3) Styled + external state + empty placeholder branch (+ dynamic label)
        LabeledTextField(
            label = dynamicLabel,
            value = styledValue,
            onValueChange = { styledValue = it },
            placeholder = "",
            labelTextStyle = MaterialTheme.typography.bodyLarge,
            labelTextColor = MaterialTheme.colorScheme.primary,
            outlinedTextStyle = MaterialTheme.typography.bodyMedium,
            singleLine = true,
            modifier = Modifier.testTag("lt-styled"))
      }
    }

    // Section bits
    composeRule.onNodeWithTag("section-default").assertExists()
    composeRule.onNodeWithTag("inside-default").assertExists()
    composeRule.onNodeWithTag("section-custom").assertExists()
    composeRule.onNodeWithTag(ComponentsTestTags.UNDERLINED_LABEL).assertExists()
    composeRule.onNodeWithText("CustomPad").assertExists()

    // Single-line
    composeRule.onNodeWithText("Game title").assertExists()
    composeRule.onNodeWithText("Type…", useUnmergedTree = true).assertExists()
    val tfSingle = composeRule.onNode(hasSetTextAction() and hasTestTag("ltf-single"))
    tfSingle.performTextInput("Catan")
    tfSingle.assertTextEquals("Catan")
    composeRule.onNode(hasTestTag("ltf-single") and hasImeAction(ImeAction.Done)).performImeAction()

    // Multiline
    composeRule
        .onNode(hasSetTextAction() and hasTestTag("ltf-multi"))
        .performTextInput("Setup:\nDraft cards\nEngine build")
    composeRule.onNodeWithTag("ltf-multi").assertTextContains("Engine build", substring = true)

    // Styled + external update + replacement round-trip + dynamic label recomposition
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("")
    composeRule.runOnUiThread { styledValue = "abc" }
    composeRule.onNodeWithTag("lt-styled").assertTextEquals("abc")
    val tfStyled = composeRule.onNode(hasTestTag("lt-styled") and hasSetTextAction())
    tfStyled.performTextReplacement("X")
    tfStyled.performImeAction()
    tfStyled.assertTextEquals("X")
    composeRule.onNodeWithText("Game Label").assertExists()
    composeRule.runOnUiThread { dynamicLabel = "Game Label (upd)" }
    composeRule.onNodeWithText("Game Label (upd)").assertExists()
  }

  /* ====================== ICON TEXTFIELDS + COUNT BUBBLE ====================== */

  @Test
  fun iconTextField_all_paths_and_countBubble_in_one() {
    var calls = 0
    var recorded = ""

    var toggleEditable by mutableStateOf(false)
    var toggleValue by mutableStateOf("RO")

    set {
      Column {
        // 1) Editable
        var a by remember { mutableStateOf("") }
        IconTextField(
            value = a,
            onValueChange = { s ->
              a = s
              calls++
              recorded = s
            },
            placeholder = "Find game",
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading") },
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing") },
            modifier = Modifier.testTag("iconTF-calls"))

        // 2) Read-only
        var ro by remember { mutableStateOf("Locked") }
        IconTextField(
            value = ro,
            onValueChange = { ro = it },
            placeholder = "ignored",
            editable = false,
            leadingIcon = null,
            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "trailing-only") },
            modifier = Modifier.testTag("iconTF-readonly"))

        // 3) Toggle readOnly → editable
        IconTextField(
            value = toggleValue,
            onValueChange = { toggleValue = it },
            placeholder = "ignored",
            editable = toggleEditable,
            leadingIcon = { Icon(Icons.Default.CalendarToday, contentDescription = "leading-on") },
            trailingIcon = null,
            modifier = Modifier.testTag("iconTF-toggle"))

        // CountBubble variants
        Column {
          CountBubble(42)
          CountBubble(0)
          CountBubble(-1)
        }
      }
    }

    // (1) Calls + icons + placeholder hide/show
    composeRule.onNodeWithContentDescription("leading").assertExists()
    composeRule.onNodeWithContentDescription("trailing").assertExists()
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()
    val tfCalls = composeRule.onNode(hasTestTag("iconTF-calls") and hasSetTextAction())
    tfCalls.performTextInput("A")
    tfCalls.performTextInput("B")
    tfCalls.assert(hasText("AB"))
    composeRule.runOnIdle { assert(calls >= 2 && recorded == "AB") }
    tfCalls.performTextReplacement("")
    composeRule.onNodeWithText("Find game", useUnmergedTree = true).assertExists()

    // (2) Read-only
    composeRule.onNodeWithContentDescription("trailing-only").assertExists()
    val ro = composeRule.onNodeWithTag("iconTF-readonly")
    ro.assert(hasSetTextAction().not())
    ro.assert(hasText("Locked"))

    // (3) Toggle
    val toggle = composeRule.onNodeWithTag("iconTF-toggle")
    toggle.assert(hasSetTextAction().not())
    toggle.assert(hasText("RO"))
    composeRule.onNodeWithContentDescription("leading-on").assertExists()
    composeRule.runOnUiThread { toggleValue = "EXT" }
    toggle.assert(hasText("EXT"))
    composeRule.runOnUiThread { toggleEditable = true }
    val editableNode = composeRule.onNode(hasTestTag("iconTF-toggle") and hasSetTextAction())
    editableNode.performTextInput("-ok")
    editableNode.assert(hasText("EXT", substring = true))
    editableNode.assert(hasText("-ok", substring = true))

    // CountBubble checks
    composeRule.onAllNodesWithTag(ComponentsTestTags.COUNT_BUBBLE_TEXT).assertCountEquals(3)
    composeRule.onAllNodesWithText("42").assertCountEquals(1)
    composeRule.onAllNodesWithText("0").assertCountEquals(1)
    composeRule.onAllNodesWithText("-1").assertCountEquals(1)
  }

  /* ====================== PARTICIPANT CHIP ====================== */

  @Test
  fun participantChip_all_paths_in_one() {
    var addCount = 0
    var removeCount = 0
    var nonClickableCount = 0
    val addName = "Reiner Knizia"
    val remName = "Uwe Rosenberg"
    val longName = "Extremely Long Eurogame Enthusiasts Guild of Basel"
    val identity = Account(uid = "x", name = "Bruno Cathala", email = "", handle = "")
    var received: Account? = null

    set {
      Column {
        ParticipantChip(
            account = Account(uid = "1", name = addName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { addCount++ },
            textColor = MaterialTheme.colorScheme.primary,
            textModifier = Modifier.testTag("chip-text-a"),
            modifier = Modifier.testTag("chip-a"))
        ParticipantChip(
            account = Account(uid = "2", name = remName, email = "", handle = ""),
            action = ParticipantAction.Remove,
            onClick = { removeCount++ },
            textModifier = Modifier.testTag("chip-text-b"),
            modifier = Modifier.testTag("chip-b"))
        ParticipantChip(
            account = Account(uid = "3", name = longName, email = "", handle = ""),
            action = ParticipantAction.Add,
            onClick = { /* no-op */},
            modifier = Modifier.testTag("chip-long"))
        ParticipantChip(
            account = identity,
            action = ParticipantAction.Add,
            onClick = {
              received = it
              nonClickableCount++
            },
            textModifier = Modifier.testTag("chip-text-nc"),
            modifier = Modifier.testTag("chip-nc"))
      }
    }

    composeRule.onNodeWithText(addName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithText(remName, useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-a", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-text-b", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("chip-long").assertExists()

    // Exactly one clickable per chip
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-a")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-b")))
        .assertCountEquals(1)
    composeRule
        .onAllNodes(hasClickAction() and hasAnyAncestor(hasTestTag("chip-nc")))
        .assertCountEquals(1)

    // Add chip must not expose Remove tag (and vice versa)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$addName", useUnmergedTree = true)
        .assertCountEquals(0)
    composeRule
        .onAllNodesWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$remName", useUnmergedTree = true)
        .assertCountEquals(0)

    // Non-clickable text should not have a click action
    composeRule.onNodeWithTag("chip-text-nc", useUnmergedTree = true).assert(hasClickAction().not())

    // Click the action buttons
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:$addName", useUnmergedTree = true)
        .performClick()
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Remove:$remName", useUnmergedTree = true)
        .performClick()

    // Click the Add button on the identity chip
    composeRule
        .onNodeWithTag(
            "${ComponentsTestTags.PARTICIPANT_ACTION}:Add:${identity.name}", useUnmergedTree = true)
        .performClick()

    composeRule.runOnIdle {
      assert(addCount == 1)
      assert(removeCount == 1)
      assert(nonClickableCount == 1)
      assert(received === identity)
    }
  }

  /* ====================== TWO-PER-ROW GRID ====================== */

  @Test
  fun twoPerRowGrid_odd_then_even_recompose_and_rowsModifier_seen() {
    var data by mutableStateOf(listOf("Azul", "Brass", "Catan"))
    set {
      TwoPerRowGrid(
          items = data,
          modifier = Modifier.testTag("grid"),
          rowsModifier = Modifier.testTag("rowMod")) { item, mod ->
            Box(mod.semantics {}) { Text("Cell $item") }
          }
    }

    composeRule.onNodeWithText("Cell Azul").assertExists()
    composeRule.onNodeWithText("Cell Catan").assertExists()

    assert(
        composeRule
            .onAllNodes(hasTestTag("rowMod"), useUnmergedTree = true)
            .fetchSemanticsNodes()
            .isNotEmpty())

    composeRule.runOnUiThread { data = listOf("Azul", "Brass", "Catan", "Dune") }
    composeRule.onNodeWithText("Cell Dune").assertExists()
  }

  /* ====================== DATE & TIME PICKERS ====================== */

  @Test
  fun datePicker_displays_and_opens_dialog() {
    val zone = ZoneId.of("UTC")
    val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val initial = LocalDate.of(2025, 1, 5)

    var date by mutableStateOf<LocalDate?>(initial)
    set {
      Column {
        DatePickerDockedField(
            value = date,
            onValueChange = { date = it },
            label = "Game date",
            displayFormatter = fmt,
            zoneId = zone,
            editable = true,
            testTagDate = SessionTestTags.DATE_FIELD + "0")
        // Non-editable date field
        DatePickerDockedField(
            value = LocalDate.of(2024, 12, 1),
            onValueChange = {},
            label = "Read-only date",
            editable = false)
      }
    }

    // Check initial date is displayed
    composeRule.onNodeWithText(initial.format(fmt)).assertExists()

    // Check non-editable field doesn't have pick button
    composeRule.onNodeWithText("01/12/2024").assertExists()

    // External value change
    val external = LocalDate.of(2026, 6, 9)
    composeRule.runOnUiThread { date = external }
    composeRule.onNodeWithText(external.format(fmt)).assertExists()

    // Check null date handling
    composeRule.runOnUiThread { date = null }
    composeRule
        .onNodeWithTag(SessionTestTags.DATE_FIELD + "0", useUnmergedTree = true)
        .assertTextEquals("")
  }

  @Test
  fun timePicker_displays_and_opens_dialog() {
    var time by mutableStateOf<LocalTime?>(null)
    set {
      Column {
        TimePickerField(
            value = time, onValueChange = { time = it }, label = "Start time", is24Hour = true)
        // With initial value
        TimePickerField(
            value = LocalTime.of(14, 30), onValueChange = {}, label = "End time", is24Hour = false)
      }
    }

    // Check time picker button exists
    composeRule.onAllNodesWithTag(SessionTestTags.TIME_PICK_BUTTON).assertCountEquals(2)

    // Check initial time is displayed
    composeRule.onNodeWithText("14:30").assertExists()

    // External value change
    composeRule.runOnUiThread { time = LocalTime.of(19, 45) }
    composeRule.onNodeWithText("19:45").assertExists()

    // Open time picker
    composeRule.onAllNodesWithTag(SessionTestTags.TIME_PICK_BUTTON)[0].performClick()
    composeRule.onNodeWithTag(ComponentsTestTags.TIME_PICKER, useUnmergedTree = true).assertExists()

    // Click OK button to close
    composeRule
        .onNodeWithTag(SessionTestTags.TIME_PICKER_OK_BUTTON, useUnmergedTree = true)
        .performClick()
  }

  @Test
  fun datePicker_dialog_cancel_and_confirm() {
    val zone = ZoneId.of("UTC")
    val initial = LocalDate.of(2025, 3, 15)

    var date by mutableStateOf<LocalDate?>(initial)
    set {
      DatePickerDockedField(
          value = date,
          onValueChange = { date = it },
          label = "Pick date",
          zoneId = zone,
          editable = true)
    }

    // Open picker
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()

    // Cancel button should exist and dismiss dialog
    composeRule.onNodeWithTag("date-picker-cancel", useUnmergedTree = true).assertExists()
    composeRule.onNodeWithTag("date-picker-cancel", useUnmergedTree = true).performClick()

    // Re-open and confirm
    composeRule.onNodeWithTag(SessionTestTags.DATE_PICK_BUTTON).performClick()
    composeRule.waitForIdle()

    // Date picker should be visible
    composeRule.onNodeWithTag(ComponentsTestTags.DATE_PICKER, useUnmergedTree = true).assertExists()

    // OK button should exist
    composeRule
        .onNodeWithTag(SessionTestTags.DATE_PICKER_OK_BUTTON, useUnmergedTree = true)
        .assertExists()
        .performClick()

    composeRule.waitForIdle()
  }

  /* ====================== DISCRETE PILL SLIDER ====================== */

  @Test
  fun discretePillSlider_renders_with_default_and_custom_colors() {
    val range = 1f..10f
    val values = 3f..7f
    val steps = 8

    set {
      Column {
        // Default colors
        DiscretePillSlider(
            range = range,
            values = values,
            steps = steps,
            modifier = Modifier.testTag("slider-default"))

        // Custom colors
        DiscretePillSlider(
            range = range,
            values = values,
            steps = steps,
            sliderColors =
                SliderDefaults.colors(
                    activeTrackColor = MaterialTheme.colorScheme.primary,
                    inactiveTrackColor = MaterialTheme.colorScheme.secondary,
                    thumbColor = MaterialTheme.colorScheme.error),
            modifier = Modifier.testTag("slider-custom"),
            sliderModifier = Modifier.testTag("slider-inner"))
      }
    }

    composeRule.onNodeWithTag("slider-default").assertExists()
    composeRule.onNodeWithTag("slider-custom").assertExists()
    composeRule.onNodeWithTag("slider-inner").assertExists()
  }

  /* ====================== TOP BAR WITH DIVIDER ====================== */

  @Test
  fun topBarWithDivider_displays_title_and_back_button() {
    var backPressed = false

    set { TopBarWithDivider(text = "Session Details", onReturn = { backPressed = true }) }

    composeRule.onNodeWithTag(ComponentsTestTags.TOP_APP_BAR).assertExists()
    composeRule.onNodeWithText("Session Details").assertExists()
    composeRule
        .onNodeWithTag(com.github.meeplemeet.ui.navigation.NavigationTestTags.GO_BACK_BUTTON)
        .assertExists()
        .performClick()

    composeRule.runOnIdle { assert(backPressed) }
  }

  @Test
  fun topBarWithDivider_displays_with_trailing_icons() {
    var iconClicked = false

    set {
      TopBarWithDivider(
          text = "Edit Session",
          onReturn = {},
          trailingIcons = {
            IconButton(
                onClick = { iconClicked = true },
                modifier = Modifier.testTag("trailing-icon-btn")) {
                  Icon(Icons.Default.Close, contentDescription = "Close")
                }
          })
    }

    composeRule.onNodeWithTag(ComponentsTestTags.TOP_APP_BAR).assertExists()
    composeRule.onNodeWithText("Edit Session").assertExists()
    composeRule.onNodeWithTag("trailing-icon-btn").assertExists().performClick()

    composeRule.runOnIdle { assert(iconClicked) }
  }

  /* ====================== SEARCH BAR WRAPPERS ====================== */

  @Test
  fun sessionGameSearchBar_renders_with_default_test_tags() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1")

    set { SessionGameSearchBar(account, discussion, createSessionViewModel) }

    // Verify the input field exists with default test tag
    composeRule.onNodeWithTag(ComponentsTestTags.SESSION_GAME_SEARCH_INPUT).assertExists()

    // Verify label exists
    composeRule.onNodeWithText("Game").assertExists()

    // Type into the search field
    composeRule
        .onNodeWithTag(ComponentsTestTags.SESSION_GAME_SEARCH_INPUT)
        .performTextInput("Catan")

    // Verify that the query was updated in the view model
    composeRule.waitForIdle()
    composeRule.runOnIdle {
      assert(createSessionViewModel.gameUIState.value.gameQuery.contains("Catan"))
    }
  }

  @Test
  fun sessionGameSearchBar_displays_initial_game() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1")

    val initialGame =
        Game(
            uid = "game1",
            name = "Ticket to Ride",
            description = "Train game",
            imageURL = "",
            minPlayers = 2,
            maxPlayers = 5,
            recommendedPlayers = 4,
            averagePlayTime = 45,
            minAge = 10)

    set { SessionGameSearchBar(account, discussion, createSessionViewModel, initial = initialGame) }

    // Verify initial game name is displayed
    composeRule.onNodeWithText("Ticket to Ride").assertExists()
  }

  @Test
  fun sessionGameSearchBar_allows_custom_test_tags() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1")

    set {
      SessionGameSearchBar(
          account,
          discussion,
          createSessionViewModel,
          inputFieldTestTag = "custom_game_input",
          dropdownItemTestTag = "custom_game_item")
    }

    // Verify custom test tag works
    composeRule.onNodeWithTag("custom_game_input").assertExists()
  }

  @Test
  fun sessionLocationSearchBar_renders_with_default_test_tags() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1")

    set { SessionLocationSearchBar(account, discussion, createSessionViewModel) }

    // Verify the input field exists with default test tag
    composeRule.onNodeWithTag(ComponentsTestTags.SESSION_LOCATION_SEARCH_INPUT).assertExists()

    // Verify label exists
    composeRule.onNodeWithText("Location").assertExists()

    // Type into the search field
    composeRule
        .onNodeWithTag(ComponentsTestTags.SESSION_LOCATION_SEARCH_INPUT)
        .performTextInput("EPFL")

    // Verify that the query was updated in the view model
    composeRule.waitForIdle()
    composeRule.runOnIdle {
      assert(createSessionViewModel.locationUIState.value.locationQuery.contains("EPFL"))
    }
  }

  @Test
  fun sessionLocationSearchBar_displays_initial_location() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val initialLocation =
        Location(latitude = 46.518888, longitude = 6.566666, name = "Rolex Learning Center")

    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1",
            session =
                com.github.meeplemeet.model.sessions.Session(
                    name = "Test Session",
                    gameId = "game1",
                    date = com.google.firebase.Timestamp.now(),
                    location = initialLocation,
                    participants = listOf("user1")))

    set { SessionLocationSearchBar(account, discussion, createSessionViewModel) }

    // Verify initial location name is displayed
    composeRule.onNodeWithText("Rolex Learning Center").assertExists()
  }

  @Test
  fun sessionLocationSearchBar_allows_custom_test_tags() {
    val account = Account(uid = "user1", handle = "player1", name = "Player One", email = "p1@test")
    val discussion =
        com.github.meeplemeet.model.discussions.Discussion(
            uid = "disc1",
            name = "Game Night",
            description = "",
            participants = listOf("user1"),
            admins = listOf("user1"),
            creatorId = "user1")

    set {
      SessionLocationSearchBar(
          account,
          discussion,
          createSessionViewModel,
          inputFieldTestTag = "custom_location_input",
          dropdownItemTestTag = "custom_location_item")
    }

    // Verify custom test tag works
    composeRule.onNodeWithTag("custom_location_input").assertExists()
  }
}
