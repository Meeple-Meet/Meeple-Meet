// This file was generated by ChatGPT-5 Extended Thinking based on a by-hand first draft
// and user combinations instructions. Improvements were then added by hand.
package com.github.meeplemeet.ui

import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.test.assertHasClickAction
import androidx.compose.ui.test.assertTextEquals
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.RelationshipStatus
import com.github.meeplemeet.model.posts.Comment
import com.github.meeplemeet.model.posts.Post
import com.github.meeplemeet.model.posts.PostViewModel
import com.github.meeplemeet.ui.posts.COMMENT_TEXT_ZONE_PLACEHOLDER
import com.github.meeplemeet.ui.posts.PostScreen
import com.github.meeplemeet.ui.posts.PostTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import com.google.firebase.Timestamp
import kotlinx.coroutines.runBlocking
import org.junit.Before
import org.junit.Rule
import org.junit.Test

class PostScreenTest : FirestoreTests() {

  @get:Rule val compose = createComposeRule()
  @get:Rule val ck = Checkpoint.Rule()

  private fun checkpoint(name: String, block: () -> Unit) = ck.ck(name, block)

  /* Canonical accounts for examples */
  private lateinit var marco: Account
  private lateinit var alex: Account
  private lateinit var dany: Account
  private val ts = Timestamp(1_725_000_000, 0)

  private fun testComment(id: String, text: String, author: Account, vararg children: Comment) =
      Comment(
          id = id,
          text = text,
          timestamp = ts,
          authorId = author.uid,
          children = children.toMutableList())

  private lateinit var postByAlex: Post
  private lateinit var postByMarco: Post
  private lateinit var postWithBlockedComments: Post

  /* ViewModels */
  private lateinit var postVM: PostViewModel

  /* Query helpers */
  private fun findNodeByTag(tag: String) = compose.onNodeWithTag(tag, useUnmergedTree = true)

  private fun findNodeByText() =
      compose.onNodeWithText(COMMENT_TEXT_ZONE_PLACEHOLDER, useUnmergedTree = true)

  @Before
  fun setup() = runBlocking {
    // Use postRepository from FirestoreTests parent class
    postVM = PostViewModel(postRepository)

    // Create accounts in Firestore
    marco = accountRepository.createAccount("u_marco", "Marco", "marco@meeple.ch", null)
    alex = accountRepository.createAccount("u_alex", "Alex", "alex@meeple.ch", null)
    dany = accountRepository.createAccount("u_dany", "Dany", "dany@meeple.ch", null)

    val c1_1_1 = testComment("c1_1_1", "Deep reply about Spirit Island combos", dany)
    val c1_1 = testComment("c1_1", "Marco: let's bring Slay the Spire IRL?", marco, c1_1_1)
    val c1_2 = testComment("c1_2", "Alex: Root needs 4, I'm in", alex)
    val c1 = testComment("c1", "Dany: root thread starter", dany, c1_1, c1_2)
    val c2 = testComment("c2", "Marco: also up for Ark Nova", marco)

    postByAlex =
        Post(
            id = "p1",
            title = "Friday Root Night",
            body = "Who wants to play Root or Ark Nova?",
            timestamp = ts,
            authorId = alex.uid,
            tags = listOf("boardgames", "lausanne"),
            comments = listOf(c1, c2))
    postByMarco = postByAlex.copy(id = "p2", authorId = marco.uid)

    // Create a post with comments from blocked users for testing
    val blockedComment = testComment("c_blocked", "This should not be visible", dany)
    val normalComment = testComment("c_normal", "This should be visible", alex)
    postWithBlockedComments =
        Post(
            id = "p_blocked",
            title = "Post with blocked user comments",
            body = "Testing blocked user functionality",
            timestamp = ts,
            authorId = alex.uid,
            tags = listOf("test"),
            comments = listOf(blockedComment, normalComment))
  }

  @Test
  fun all_post_screen_tests() {
    var backCount = 0
    val postIdState = mutableStateOf("p_nonexistent")

    compose.setContent {
      AppTheme {
        PostScreen(
            account = marco,
            postId = postIdState.value,
            postViewModel = postVM,
            accountViewModel = postVM,
            onBack = { backCount++ })
      }
    }

    checkpoint("loading_then_content_and_topbar_back_navigation") {
      findNodeByTag(PostTags.SCREEN).assertExists()
      findNodeByTag(PostTags.LOADING_BOX).assertExists()
      findNodeByTag(PostTags.LOADING_SPINNER).assertExists()

      findNodeByTag(PostTags.TOP_BAR).assertExists()
      findNodeByTag(PostTags.TOP_BAR_DIVIDER).assertExists()
      findNodeByTag(PostTags.TOP_TITLE).assertExists()
      findNodeByTag(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
      compose.waitForIdle()
      assert(backCount == 1)
    }

    checkpoint("topbar_back_default_onBack_no_crash") {
      // Test back button again - it should work multiple times
      findNodeByTag(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
      compose.waitForIdle()
      assert(backCount == 2)
    }

    checkpoint("composer_bar_exists_and_interactions") {
      // Switch to a different post ID
      postIdState.value = "p_test"
      compose.waitForIdle()

      findNodeByTag(PostTags.COMPOSER_BAR).assertExists()
      findNodeByText().assertExists()
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextInput("Hello Root!")
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement("   test   ")
      findNodeByTag(PostTags.COMPOSER_ATTACH).assertExists().performClick()
    }

    checkpoint("tags_display_correctly") {
      postIdState.value = "p_tags"
      compose.waitForIdle()
    }

    checkpoint("character_counter_not_visible_initially") {
      postIdState.value = "p_test"
      compose.waitForIdle()

      // Counter should not be visible initially
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertDoesNotExist()
    }

    checkpoint("character_counter_appears_when_approaching_limit") {
      // Type text to get close to limit (2048 - 100 = 1948 chars to trigger counter)
      val longText = "a".repeat(1950)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(longText)
      compose.waitForIdle()

      // Counter should now be visible
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      // Should show remaining chars (2048 - 1950 = 98)
      compose.onNodeWithText("98").assertExists()
    }

    checkpoint("character_counter_shows_warning_when_low") {
      // Type text to leave less than 20 chars
      val longText = "a".repeat(2030)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(longText)
      compose.waitForIdle()

      // Counter should be visible showing 18 chars remaining
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      compose.onNodeWithText("18").assertExists()
    }

    checkpoint("character_limit_enforced") {
      // Type exactly 2048 characters
      val maxText = "a".repeat(2048)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(maxText)
      compose.waitForIdle()

      // Counter should show 0 chars remaining
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      compose.onNodeWithText("0").assertExists()

      // Verify we can't type more - text input should still be exactly 2048 chars
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextInput("b")
      compose.waitForIdle()

      // Counter should still show 0 (input rejected)
      compose.onNodeWithText("0").assertExists()
    }
  }

  @Test
  fun blocked_user_comments_are_hidden() = runBlocking {
    // Create marco with dany blocked
    val marcoWithBlockedDany =
        marco.copy(relationships = mapOf(dany.uid to RelationshipStatus.BLOCKED).toMutableMap())

    // Insert the test post with comments from dany and others
    val createdPost =
        postRepository.createPost(
            postWithBlockedComments.title,
            postWithBlockedComments.body,
            postWithBlockedComments.authorId,
            postWithBlockedComments.tags)
    val postId = createdPost.id

    // Add comments
    postRepository.addComment(postId, "This should not be visible", dany.uid, postId)
    val id = postRepository.addComment(postId, "This should be visible", alex.uid, postId)

    compose.setContent {
      AppTheme {
        PostScreen(
            account = marcoWithBlockedDany,
            postId = postId,
            postViewModel = postVM,
            accountViewModel = postVM,
            onBack = {})
      }
    }

    // Wait for post content to load
    compose.waitUntil(timeoutMillis = 5000) {
      compose
          .onAllNodesWithText(postWithBlockedComments.title, useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    // Wait for comments to load - wait for any comment-related text to appear
    compose.waitUntil(timeoutMillis = 5000) {
      compose
          .onAllNodesWithText(
              "comment", substring = true, ignoreCase = true, useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    checkpoint("blocked_user_comment_shows_placeholder_text") {
      // Should show placeholder instead of actual comment
      compose.onNodeWithText("Blocked User").assertExists()
      compose.onNodeWithText("Comment from blocked user").assertExists()
      compose.onNodeWithText("This should not be visible").assertDoesNotExist()
    }

    checkpoint("normal_user_shows_real_content") {
      // Should show actual username and comment for non-blocked user
      compose
          .onNodeWithTag(PostTags.commentAuthor(id), useUnmergedTree = true)
          .assertTextEquals(alex.name)
      compose.onNodeWithText("This should be visible").assertExists()
    }
  }
}
