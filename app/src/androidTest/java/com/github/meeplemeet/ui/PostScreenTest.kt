// This file was generated by ChatGPT-5 Extended Thinking based on a by-hand first draft
// and user combinations instructions. Improvements were then added by hand.
package com.github.meeplemeet.ui

import android.content.Context
import androidx.compose.runtime.mutableStateOf
import androidx.compose.ui.test.assertHasClickAction
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.github.meeplemeet.model.account.Account
import com.github.meeplemeet.model.account.AccountViewModel
import com.github.meeplemeet.model.posts.Comment
import com.github.meeplemeet.model.posts.Post
import com.github.meeplemeet.model.posts.PostViewModel
import com.github.meeplemeet.ui.posts.COMMENT_TEXT_ZONE_PLACEHOLDER
import com.github.meeplemeet.ui.posts.PostScreen
import com.github.meeplemeet.ui.posts.PostTags
import com.github.meeplemeet.ui.theme.AppTheme
import com.github.meeplemeet.utils.Checkpoint
import com.github.meeplemeet.utils.FirestoreTests
import com.google.firebase.Timestamp
import kotlinx.coroutines.CoroutineScope
import org.junit.Before
import org.junit.Rule
import org.junit.Test

class PostScreenTest : FirestoreTests() {

  @get:Rule val compose = createComposeRule()
  @get:Rule val ck = Checkpoint.Rule()

  private fun checkpoint(name: String, block: () -> Unit) = ck.ck(name, block)

  /* Canonical accounts for examples */
  private val marco =
      Account(uid = "u_marco", handle = "marco", name = "Marco", email = "marco@meeple.ch")
  private val alex =
      Account(uid = "u_alex", handle = "alex", name = "Alex", email = "alex@meeple.ch")
  private val dany =
      Account(uid = "u_dany", handle = "dany", name = "Dany", email = "dany@meeple.ch")
  private val ts = Timestamp(1_725_000_000, 0)

  private fun testComment(id: String, text: String, author: Account, vararg children: Comment) =
      Comment(
          id = id,
          text = text,
          timestamp = ts,
          authorId = author.uid,
          children = children.toMutableList())

  private lateinit var postByAlex: Post
  private lateinit var postByMarco: Post

  /* Fake AccountViewModel */
  private inner class FakeAccountViewModel : ViewModel(), AccountViewModel {
    override val scope: CoroutineScope
      get() = viewModelScope

    private val accounts = mutableMapOf(marco.uid to marco, alex.uid to alex, dany.uid to dany)

    override fun getAccount(id: String, context: Context, onResult: (Account?) -> Unit) {
      if (id.isBlank()) return
      accounts[id]?.let { onResult(it) }
    }

    fun addAccount(account: Account) {
      accounts[account.uid] = account
    }
  }

  /* ViewModels */
  private lateinit var postVM: PostViewModel
  private lateinit var accountVM: FakeAccountViewModel

  /* Query helpers */
  private fun findNodeByTag(tag: String) = compose.onNodeWithTag(tag, useUnmergedTree = true)

  private fun findNodeByText() =
      compose.onNodeWithText(COMMENT_TEXT_ZONE_PLACEHOLDER, useUnmergedTree = true)

  private fun settleAnimations() {
    compose.mainClock.advanceTimeBy(700)
    compose.waitForIdle()
  }

  private fun setContent(account: Account = marco, postId: String = "p1", onBack: () -> Unit = {}) {
    compose.setContent {
      AppTheme {
        PostScreen(
            account = account,
            postId = postId,
            verified = true,
            postViewModel = postVM,
            accountViewModel = accountVM,
            onBack = onBack)
      }
    }
  }

  @Before
  fun setup() {
    val c1_1_1 = testComment("c1_1_1", "Deep reply about Spirit Island combos", dany)
    val c1_1 = testComment("c1_1", "Marco: let's bring Slay the Spire IRL?", marco, c1_1_1)
    val c1_2 = testComment("c1_2", "Alex: Root needs 4, I'm in", alex)
    val c1 = testComment("c1", "Dany: root thread starter", dany, c1_1, c1_2)
    val c2 = testComment("c2", "Marco: also up for Ark Nova", marco)

    postByAlex =
        Post(
            id = "p1",
            title = "Friday Root Night",
            body = "Who wants to play Root or Ark Nova?",
            timestamp = ts,
            authorId = alex.uid,
            tags = listOf("boardgames", "lausanne"),
            comments = listOf(c1, c2))
    postByMarco = postByAlex.copy(id = "p2", authorId = marco.uid)

    // Use postRepository from FirestoreTests parent class
    postVM = PostViewModel(postRepository)
    accountVM = FakeAccountViewModel()
  }

  @Test
  fun all_post_screen_tests() {
    var backCount = 0
    val postIdState = mutableStateOf("p_nonexistent")

    compose.setContent {
      AppTheme {
        PostScreen(
            account = marco,
            postId = postIdState.value,
            verified = true,
            postViewModel = postVM,
            accountViewModel = accountVM,
            onBack = { backCount++ })
      }
    }

    checkpoint("loading_then_content_and_topbar_back_navigation") {
      findNodeByTag(PostTags.SCREEN).assertExists()
      findNodeByTag(PostTags.LOADING_BOX).assertExists()
      findNodeByTag(PostTags.LOADING_SPINNER).assertExists()

      findNodeByTag(PostTags.TOP_BAR).assertExists()
      findNodeByTag(PostTags.TOP_BAR_DIVIDER).assertExists()
      findNodeByTag(PostTags.TOP_TITLE).assertExists()
      findNodeByTag(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
      compose.waitForIdle()
      assert(backCount == 1)
    }

    checkpoint("topbar_back_default_onBack_no_crash") {
      // Test back button again - it should work multiple times
      findNodeByTag(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
      compose.waitForIdle()
      assert(backCount == 2)
    }

    checkpoint("composer_bar_exists_and_interactions") {
      // Switch to a different post ID
      postIdState.value = "p_test"
      compose.waitForIdle()

      findNodeByTag(PostTags.COMPOSER_BAR).assertExists()
      findNodeByText().assertExists()
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextInput("Hello Root!")
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement("   test   ")
      findNodeByTag(PostTags.COMPOSER_ATTACH).assertExists().performClick()
    }

    checkpoint("tags_display_correctly") {
      postIdState.value = "p_tags"
      compose.waitForIdle()
    }

    checkpoint("character_counter_not_visible_initially") {
      postIdState.value = "p_test"
      compose.waitForIdle()

      // Counter should not be visible initially
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertDoesNotExist()
    }

    checkpoint("character_counter_appears_when_approaching_limit") {
      // Type text to get close to limit (2048 - 100 = 1948 chars to trigger counter)
      val longText = "a".repeat(1950)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(longText)
      compose.waitForIdle()

      // Counter should now be visible
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      // Should show remaining chars (2048 - 1950 = 98)
      compose.onNodeWithText("98").assertExists()
    }

    checkpoint("character_counter_shows_warning_when_low") {
      // Type text to leave less than 20 chars
      val longText = "a".repeat(2030)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(longText)
      compose.waitForIdle()

      // Counter should be visible showing 18 chars remaining
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      compose.onNodeWithText("18").assertExists()
    }

    checkpoint("character_limit_enforced") {
      // Type exactly 2048 characters
      val maxText = "a".repeat(2048)
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextReplacement(maxText)
      compose.waitForIdle()

      // Counter should show 0 chars remaining
      findNodeByTag(PostTags.COMPOSER_CHAR_COUNTER).assertExists()
      compose.onNodeWithText("0").assertExists()

      // Verify we can't type more - text input should still be exactly 2048 chars
      findNodeByTag(PostTags.COMPOSER_INPUT).performTextInput("b")
      compose.waitForIdle()

      // Counter should still show 0 (input rejected)
      compose.onNodeWithText("0").assertExists()
    }
  }
}
