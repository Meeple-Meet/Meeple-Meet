// This file was generated by ChatGPT-5 Extended Thinking based on a by-hand first draft
// and user combinations instructions. Improvements were then added by hand.
package com.github.meeplemeet.ui

import androidx.compose.runtime.getValue
import androidx.compose.runtime.key
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.test.assertHasClickAction
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.assertIsEnabled
import androidx.compose.ui.test.assertIsNotEnabled
import androidx.compose.ui.test.hasTestTag
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.compose.ui.test.performImeAction
import androidx.compose.ui.test.performTextInput
import androidx.compose.ui.test.performTextReplacement
import com.github.meeplemeet.model.repositories.FirestorePostRepository
import com.github.meeplemeet.model.structures.Account
import com.github.meeplemeet.model.structures.Comment
import com.github.meeplemeet.model.structures.Post
import com.github.meeplemeet.model.viewmodels.FirestoreViewModel
import com.github.meeplemeet.model.viewmodels.PostViewModel
import com.github.meeplemeet.ui.theme.AppTheme
import com.google.firebase.Timestamp
import io.mockk.clearMocks
import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import io.mockk.spyk
import io.mockk.verify
import java.util.concurrent.atomic.AtomicInteger
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import org.junit.Before
import org.junit.Rule
import org.junit.Test

class PostScreenTest {

  @get:Rule val compose = createComposeRule()

  /* ViewModels and flows */
  private lateinit var postVM: PostViewModel
  private lateinit var usersVM: FirestoreViewModel
  private lateinit var postFlowP1: MutableStateFlow<Post?>

  /* Canonical accounts for examples */
  private val marco =
      Account(uid = "u_marco", handle = "marco", name = "Marco", email = "marco@meeple.ch")
  private val alex =
      Account(uid = "u_alex", handle = "alex", name = "Alex", email = "alex@meeple.ch")
  private val dany =
      Account(uid = "u_dany", handle = "dany", name = "Dany", email = "dany@meeple.ch")
  private val ts = Timestamp(1_725_000_000, 0)

  private fun c(id: String, text: String, author: Account, vararg children: Comment) =
      Comment(
          id = id,
          text = text,
          timestamp = ts,
          authorId = author.uid,
          children = children.toMutableList())

  private lateinit var postByAlex: Post
  private lateinit var postByMarco: Post

  /* access PostViewModel.postFlows */
  private fun flowsMapOf(vm: PostViewModel): MutableMap<String, StateFlow<Post?>> {
    val f = PostViewModel::class.java.getDeclaredField("postFlows").apply { isAccessible = true }
    @Suppress("UNCHECKED_CAST") return f.get(vm) as MutableMap<String, StateFlow<Post?>>
  }

  private fun injectPost(id: String, flow: StateFlow<Post?>) {
    flowsMapOf(postVM)[id] = flow
  }

  private fun injectStaticPost(id: String, post: Post) {
    injectPost(id, MutableStateFlow(post))
  }

  private fun setContent(account: Account = marco, postId: String = "p1", onBack: () -> Unit = {}) {
    compose.setContent {
      AppTheme {
        PostScreen(
            account = account,
            postId = postId,
            postViewModel = postVM,
            usersViewModel = usersVM,
            onBack = onBack)
      }
    }
  }

  /* Query helpers */
  private fun n(tag: String) = compose.onNodeWithTag(tag, useUnmergedTree = true)

  private fun t(text: String, unmerged: Boolean = true) =
      compose.onNodeWithText(text, useUnmergedTree = unmerged)

  private fun settleAnimations() {
    compose.mainClock.advanceTimeBy(700)
    compose.waitForIdle()
  }

  /** Controls to mutate PostScreen inputs without re-calling setContent. */
  private data class HostControls(
      val setAccount: (Account) -> Unit,
      val setPostId: (String) -> Unit,
      val setOnBack: (((() -> Unit))?) -> Unit,
      val setPostVM: (PostViewModel) -> Unit,
      val resetScreen: () -> Unit
  )

  private fun renderHost(
      initialAccount: Account = marco,
      postId: String = "p1",
      initialPostVM: PostViewModel = postVM,
      initialUsersVM: FirestoreViewModel = usersVM,
      initialOnBack: (() -> Unit)? = {}
  ): HostControls {
    lateinit var controls: HostControls
    compose.setContent {
      AppTheme {
        var account by remember { mutableStateOf(initialAccount) }
        var currentPostId by remember { mutableStateOf(postId) }
        var onBack by remember { mutableStateOf(initialOnBack) }
        var vm by remember { mutableStateOf(initialPostVM) }
        var screenKey by remember { mutableStateOf(0) }

        controls =
            HostControls(
                setAccount = { account = it },
                setPostId = { currentPostId = it },
                setOnBack = { onBack = it },
                setPostVM = { vm = it },
                resetScreen = { screenKey++ })

        key(screenKey) {
          if (onBack == null) {
            PostScreen(
                account = account,
                postId = currentPostId,
                postViewModel = vm,
                usersViewModel = initialUsersVM)
          } else {
            PostScreen(
                account = account,
                postId = currentPostId,
                postViewModel = vm,
                usersViewModel = initialUsersVM,
                onBack = onBack!!)
          }
        }
      }
    }
    return controls
  }

  @Before
  fun setup() {
    val c1_1_1 = c("c1_1_1", "Deep reply about Spirit Island combos", dany)
    val c1_1 = c("c1_1", "Marco: let's bring Slay the Spire IRL?", marco, c1_1_1)
    val c1_2 = c("c1_2", "Alex: Root needs 4, Iâ€™m in", alex)
    val c1 = c("c1", "Dany: root thread starter", dany, c1_1, c1_2)
    val c2 = c("c2", "Marco: also up for Ark Nova", marco)

    postByAlex =
        Post(
            id = "p1",
            title = "Friday Root Night",
            body = "Who wants to play Root or Ark Nova?",
            timestamp = ts,
            authorId = alex.uid,
            tags = listOf("boardgames", "lausanne"),
            comments = listOf(c1, c2))
    postByMarco = postByAlex.copy(id = "p2", authorId = marco.uid)

    val repo = mockk<FirestorePostRepository>(relaxed = true)
    postVM = spyk(PostViewModel(repo))
    postFlowP1 = MutableStateFlow(null)
    injectPost("p1", postFlowP1)
    injectStaticPost("p2", postByMarco)

    usersVM = mockk(relaxed = true)
    every { usersVM.getOtherAccount(any(), any()) } answers
        {
          val uid = firstArg<String>()
          val cb = secondArg<(Account) -> Unit>()
          cb(
              when (uid) {
                marco.uid -> marco
                alex.uid -> alex
                dany.uid -> dany
                else -> Account(uid, "h$uid", "User-$uid", "x@$uid")
              })
        }
  }

  @Test
  fun loading_then_content_and_topbar_back_navigation() {
    val backCount = AtomicInteger(0)
    setContent(postId = "p1", onBack = { backCount.incrementAndGet() })

    n(PostTags.SCREEN).assertExists()
    n(PostTags.LOADING_BOX).assertExists()
    n(PostTags.LOADING_SPINNER).assertExists()

    postFlowP1.value = postByAlex
    n(PostTags.LIST).assertExists()
    n(PostTags.postCard("p1")).assertExists()
    n(PostTags.POST_TITLE).assertIsDisplayed()
    n(PostTags.POST_BODY).assertIsDisplayed()

    n(PostTags.TOP_BAR).assertExists()
    n(PostTags.TOP_BAR_DIVIDER).assertExists()
    n(PostTags.TOP_TITLE).assertExists()
    n(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
    compose.waitUntil(1_000) { backCount.get() == 1 }
  }

  @Test
  fun topbar_back_default_onBack_no_crash() {
    renderHost(postId = "p1", initialOnBack = null)
    postFlowP1.value = postByAlex
    n(PostTags.NAV_BACK_BTN).assertHasClickAction().performClick()
  }

  @Test
  fun post_card_details_and_delete_permission() {
    val host = renderHost(postId = "p1", initialOnBack = {})
    postFlowP1.value = postByAlex

    n(PostTags.POST_TAGS_ROW).assertExists()
    n(PostTags.tagChip("boardgames")).assertExists().assertIsNotEnabled()
    n(PostTags.tagChip("lausanne")).assertExists().assertIsNotEnabled()
    n(PostTags.POST_HEADER).assertExists()
    n(PostTags.POST_AVATAR).assertExists()
    n(PostTags.POST_AUTHOR).assertExists()
    n(PostTags.POST_DATE).assertExists()

    n(PostTags.POST_DELETE_BTN).assertDoesNotExist()

    val backCount = AtomicInteger(0)
    host.setOnBack { backCount.incrementAndGet() }
    host.setPostId("p2")
    n(PostTags.POST_DELETE_BTN).assertExists().performClick()
    verify(exactly = 1) { postVM.deletePost(marco, match { it.id == "p2" }) }
    compose.waitUntil(1_000) { backCount.get() == 1 }
  }

  @Test
  fun switching_account_updates_isMine_and_delete_buttons() {
    lateinit var setAcc: (Account) -> Unit
    compose.setContent {
      AppTheme {
        var acc by remember { mutableStateOf(marco) }
        setAcc = { acc = it }
        PostScreen(account = acc, postId = "p1", postViewModel = postVM, usersViewModel = usersVM)
      }
    }
    postFlowP1.value = postByAlex

    n(PostTags.commentDeleteBtn("c2")).assertExists()
    n(PostTags.commentDeleteBtn("c1")).assertDoesNotExist()

    compose.runOnUiThread { setAcc(dany) }
    compose.waitForIdle()
    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentDeleteBtn("c1")).assertExists()
  }

  @Test
  fun composer_end_to_end_behaviors() {
    val host = renderHost(postId = "p1", initialOnBack = {})

    // Pre-post: disabled & placeholder
    n(PostTags.COMPOSER_BAR).assertExists()
    t(COMMENT_TEXT_ZONE_PLACEHOLDER, true).assertExists()
    n(PostTags.COMPOSER_INPUT).performTextInput("Hello Root!")
    n(PostTags.COMPOSER_SEND).assertIsNotEnabled()

    // Post arrives -> enabled, send by click with trimming
    postFlowP1.value = postByAlex
    n(PostTags.COMPOSER_SEND).assertIsEnabled()
    n(PostTags.COMPOSER_INPUT).performTextReplacement("   slay the spire   ")
    n(PostTags.COMPOSER_SEND).performClick()
    verify { postVM.addComment(marco, postByAlex, "p1", "slay the spire") }

    // Placeholder toggles & whitespace disables
    t(COMMENT_TEXT_ZONE_PLACEHOLDER, true).assertExists()
    n(PostTags.COMPOSER_INPUT).performTextReplacement("x")
    t(COMMENT_TEXT_ZONE_PLACEHOLDER, true).assertDoesNotExist()
    n(PostTags.COMPOSER_INPUT).performTextReplacement("     ")
    n(PostTags.COMPOSER_SEND).assertIsNotEnabled()

    // Attach (no-op visual)
    n(PostTags.COMPOSER_ATTACH).assertExists().performClick()
    n(PostTags.COMPOSER_BAR).assertExists()

    // Swap a delaying repo -> send via IME; check disabled while sending
    val delayingRepo = mockk<FirestorePostRepository>(relaxed = true)
    coEvery { delayingRepo.addComment(any(), any(), any(), any()) } coAnswers
        {
          kotlinx.coroutines.delay(400)
          Unit.toString()
        }
    postVM = spyk(PostViewModel(delayingRepo))
    injectPost("p1", MutableStateFlow(postByAlex))
    host.setPostVM(postVM)

    n(PostTags.COMPOSER_INPUT).performTextReplacement("root meetup!")
    n(PostTags.COMPOSER_INPUT).performImeAction()
    n(PostTags.COMPOSER_SEND).assertIsNotEnabled()
    compose.mainClock.advanceTimeBy(500)
    verify { postVM.addComment(marco, postByAlex, "p1", "root meetup!") }
  }

  @Test
  fun threads_expand_collapse_flow_and_gutters() {
    setContent(postId = "p1")
    postFlowP1.value = postByAlex

    // Roots present
    n(PostTags.threadCard("c1")).assertExists()
    n(PostTags.threadCard("c2")).assertExists()

    // Expand c1 -> children visible
    n(PostTags.commentText("c1_1")).assertDoesNotExist()
    n(PostTags.commentText("c1_2")).assertDoesNotExist()
    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1")).assertExists()
    n(PostTags.commentText("c1_2")).assertExists()

    // Expand c1_1 -> grandchild visible + gutters present
    n(PostTags.commentText("c1_1_1")).assertDoesNotExist()
    n(PostTags.commentCard("c1_1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1_1")).assertExists()
    n(PostTags.treeDepth(1)).assertExists()
    n(PostTags.gutterDepth(1)).assertExists()
    n(PostTags.treeDepth(2)).assertExists()
    n(PostTags.gutterDepth(2)).assertExists()

    // Leaf click no-op
    n(PostTags.commentCard("c1_2")).performClick()
    settleAnimations()
    n(PostTags.treeDepth(3)).assertDoesNotExist()

    // Collapse nested -> hides only its branch
    n(PostTags.commentCard("c1_1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1_1")).assertDoesNotExist()

    // Collapse root -> hides children
    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1")).assertDoesNotExist()
  }

  @Test
  fun threads_independent_expand_state_per_roots() {
    val c2Child = c("c2_1", "Marco: Ark Nova engine?", marco)
    val c2WithChild =
        postByAlex.comments.first { it.id == "c2" }.copy(children = mutableListOf(c2Child))
    val c1Same = postByAlex.comments.first { it.id == "c1" }
    val post = postByAlex.copy(id = "p_indep", comments = listOf(c1Same, c2WithChild))
    injectStaticPost("p_indep", post)

    setContent(postId = "p_indep")

    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1")).assertExists()
    n(PostTags.commentText("c2_1")).assertDoesNotExist()

    n(PostTags.commentCard("c2")).performClick()
    settleAnimations()
    n(PostTags.commentText("c2_1")).assertExists()
  }

  @Test
  fun threads_expansion_persists_across_recomposition() {
    setContent(postId = "p1")
    postFlowP1.value = postByAlex

    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentText("c1_1")).assertExists()

    postFlowP1.value = postByAlex.copy(title = "Friday Root Night (updated)")
    compose.waitForIdle()
    n(PostTags.commentText("c1_1")).assertExists()
  }

  @Test
  fun threads_depth3_gutter_visible_when_deeper() {
    val c1_1_1_1 = c("c1_1_1_1", "Dany: stack your relics!", dany)

    val c1_1_1_deeper =
        postByAlex.comments
            .first { it.id == "c1" }
            .children
            .first { it.id == "c1_1" }
            .children
            .first { it.id == "c1_1_1" }
            .copy(children = mutableListOf(c1_1_1_1))

    val c1_1_deeper =
        postByAlex.comments
            .first { it.id == "c1" }
            .children
            .first { it.id == "c1_1" }
            .copy(children = mutableListOf(c1_1_1_deeper))

    val c1_deeper =
        postByAlex.comments
            .first { it.id == "c1" }
            .copy(
                children =
                    mutableListOf(
                        c1_1_deeper,
                        postByAlex.comments
                            .first { it.id == "c1" }
                            .children
                            .first { it.id == "c1_2" }))

    val post =
        postByAlex.copy(
            id = "p_depth3",
            comments = listOf(c1_deeper, postByAlex.comments.first { it.id == "c2" }))
    injectStaticPost("p_depth3", post)

    setContent(postId = "p_depth3")

    n(PostTags.commentCard("c1")).performClick()
    n(PostTags.commentCard("c1_1")).performClick()
    n(PostTags.commentCard("c1_1_1")).performClick()
    settleAnimations()

    n(PostTags.treeDepth(3)).assertExists()
    n(PostTags.gutterDepth(3)).assertExists()
  }

  @Test
  fun replies_end_to_end_toggle_placeholder_send_ime_trim_close() {
    setContent(postId = "p1")
    postFlowP1.value = postByAlex

    // Open root, toggle reply -> field + placeholder
    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentReplyToggle("c1")).performClick()
    settleAnimations()
    n(PostTags.commentReplyField("c1")).assertExists()
    compose.onNodeWithText(REPLY_TEXT_ZONE_PLACEHOLDER, useUnmergedTree = true).assertExists()
    n(PostTags.commentReplySend("c1")).assertIsNotEnabled()

    // Send with trimming by click
    n(PostTags.commentReplyField("c1")).performTextReplacement("   root is great   ")
    n(PostTags.commentReplySend("c1")).performClick()
    settleAnimations()
    n(PostTags.commentReplyField("c1")).assertDoesNotExist()
    verify { postVM.addComment(marco, postByAlex, "c1", "root is great") }

    // Open another node, IME send path
    n(PostTags.commentReplyToggle("c1_1")).performClick()
    settleAnimations()
    n(PostTags.commentReplyField("c1_1")).performTextReplacement("via ime send")
    n(PostTags.commentReplyField("c1_1")).performImeAction()
    verify { postVM.addComment(marco, postByAlex, "c1_1", "via ime send") }

    // Toggle twice closes, no send on blank
    n(PostTags.commentReplyToggle("c1_2")).performClick()
    settleAnimations()
    n(PostTags.commentReplySend("c1_2")).assertIsNotEnabled()
    n(PostTags.commentReplyToggle("c1_2")).performClick()
    settleAnimations()
    n(PostTags.commentReplyField("c1_2")).assertDoesNotExist()
  }

  @Test
  fun permissions_delete_buttons_for_post_and_comments() {
    setContent(postId = "p1")
    postFlowP1.value = postByAlex

    n(PostTags.commentDeleteBtn("c2")).assertExists().performClick()
    val c2 = postByAlex.comments.first { it.id == "c2" }
    verify { postVM.removeComment(marco, postByAlex, c2) }

    n(PostTags.commentDeleteBtn("c1")).assertDoesNotExist()
    verify(exactly = 1) { postVM.removeComment(any(), any(), any()) }

    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentDeleteBtn("c1_1")).assertExists().performClick()
    val c11 = postByAlex.comments.first { it.id == "c1" }.children.first { it.id == "c1_1" }
    verify { postVM.removeComment(marco, postByAlex, c11) }
  }

  @Test
  fun user_resolution_placeholders_and_caching_behaviour() {
    val host = renderHost(postId = "p1")
    postFlowP1.value = postByAlex
    compose.mainClock.advanceTimeByFrame()
    compose.waitForIdle()

    n(PostTags.commentCard("c1")).performClick()
    settleAnimations()
    n(PostTags.commentAuthor("c1")).assertExists()
    n(PostTags.commentAuthor("c1_1")).assertExists()
    n(PostTags.commentAuthor("c1_2")).assertExists()

    n(PostTags.tagChip("boardgames")).assertExists().assertIsNotEnabled()
    n(PostTags.tagChip("lausanne")).assertExists().assertIsNotEnabled()

    val noTags = postByAlex.copy(id = "p_no_tags", tags = emptyList())
    injectStaticPost("p_no_tags", noTags)
    host.setPostId("p_no_tags")
    n(PostTags.POST_TAGS_ROW).assertDoesNotExist()

    host.setPostId("p1")
    postFlowP1.value = postByAlex
    compose.waitForIdle()
    clearMocks(usersVM, answers = false, recordedCalls = true, verificationMarks = true)

    val newChildFromDany = c("c2_dany_extra", "Dany adds Ark Nova tip", dany)
    val c2orig = postByAlex.comments.first { it.id == "c2" }
    postFlowP1.value =
        postByAlex.copy(
            comments =
                listOf(
                    postByAlex.comments.first { it.id == "c1" },
                    c2orig.copy(children = (c2orig.children + newChildFromDany).toMutableList())))
    compose.waitForIdle()
    verify(exactly = 0) { usersVM.getOtherAccount(dany.uid, any()) }

    every { usersVM.getOtherAccount(eq(alex.uid), any()) } answers { /* unresolved */}
    val noAuthor = postByAlex.copy(id = "p_author_unresolved", comments = emptyList())
    injectStaticPost("p_author_unresolved", noAuthor)
    host.setPostId("p_author_unresolved")
    host.resetScreen()
    settleAnimations()
    compose
        .onNode(
            hasTestTag(PostTags.POST_AUTHOR).and(hasText(UNKNOWN_USER_PLACEHOLDER, false, false)),
            useUnmergedTree = true)
        .assertExists()

    val nilUid = "u_nil"
    every { usersVM.getOtherAccount(eq(nilUid), any()) } answers { /* unresolved */}
    val nilComment =
        c(
                "c_nil",
                "Nil: anyone bringing Root expansion?",
                Account(uid = nilUid, handle = "", name = "", email = ""))
            .copy(authorId = nilUid)
    val withNil = postByAlex.copy(id = "p_nil_comment", comments = listOf(nilComment))
    injectStaticPost("p_nil_comment", withNil)
    host.setPostId("p_nil_comment")
    host.resetScreen()
    settleAnimations()
    compose
        .onNode(
            hasTestTag(PostTags.commentAuthor("c_nil"))
                .and(hasText(UNKNOWN_USER_PLACEHOLDER, false, false)),
            useUnmergedTree = true)
        .assertExists()
    verify(atLeast = 1) { usersVM.getOtherAccount(eq(nilUid), any()) }

    val blank = c("c_blank", "Anonymous meeple", marco.copy(uid = "")).copy(authorId = "")
    val blankPost = postByAlex.copy(id = "p_blank", comments = listOf(blank))
    injectStaticPost("p_blank", blankPost)
    host.setPostId("p_blank")
    host.resetScreen()
    settleAnimations()
    compose
        .onNode(
            hasTestTag(PostTags.commentAuthor("c_blank"))
                .and(hasText(UNKNOWN_USER_PLACEHOLDER, false, false)),
            useUnmergedTree = true)
        .assertExists()
    verify(exactly = 0) { usersVM.getOtherAccount("", any()) }

    host.setPostId("p1")
    host.resetScreen()
    postFlowP1.value = postByAlex
    compose.mainClock.advanceTimeByFrame()
    compose.waitForIdle()
    verify(timeout = 1500, atLeast = 1) { usersVM.getOtherAccount(alex.uid, any()) }
    verify(timeout = 1500, atLeast = 1) { usersVM.getOtherAccount(dany.uid, any()) }
  }

  @Test
  fun tags_flow_wrap_and_empty_comments_case() {
    val manyTags = (1..24).map { i -> "averyverylongtag_${i}" + "_".repeat(18) }
    injectStaticPost("p_many_tags", postByAlex.copy(id = "p_many_tags", tags = manyTags))

    val host = renderHost(postId = "p_many_tags")

    n(PostTags.POST_TAGS_ROW).assertExists()
    n(PostTags.tagChip(manyTags.first())).assertExists().assertIsNotEnabled()
    n(PostTags.tagChip(manyTags.last())).assertExists().assertIsNotEnabled()

    val noComments = postByAlex.copy(id = "p_empty_comments", comments = emptyList())
    injectStaticPost("p_empty_comments", noComments)
    host.setPostId("p_empty_comments")
    n(PostTags.threadCard("anything")).assertDoesNotExist()
    n(PostTags.treeDepth(1)).assertDoesNotExist()
  }
}
